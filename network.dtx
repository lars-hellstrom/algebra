% 
% \iffalse
%<*driver>
\documentclass{tclldoc}
\usepackage{amsmath,amssymb}
\usepackage{longtable}
\PageIndex
\CodelineNumbered
\setcounter{IndexColumns}{2}
\begin{document}
\DocInput{network.dtx}
\PrintIndex
\end{document}
%</driver>
% \fi
% 
% \title{Linear network algebra}
% \author{Lars Hellstr\"om}
% \maketitle
% 
% \begin{abstract}
%   This file contains code for calculations with networks having the 
%   following characteristics: (i)~all edges are directed, (ii)~all 
%   ports of a vertex are distinct, (iii)~the vertices are decorated, 
%   (iv)~the inputs and outputs are ordered (i.e., not unordered). 
%   Furthermore, there will probably not be any feedback.
%   
%   The network data structure permits the inclusion of graphical data, 
%   but not all operations will preserve or update that information. 
%   Some ``sproing''-like operations are provided to generate 
%   decent graphical presentation of abstract networks.
% \end{abstract}
% 
% \begin{tcl}
%<*pkg>
package require Tcl 8.4
namespace eval network {}
% \end{tcl}
% \setnamespace{network}
% 
% 
% \tableofcontents
% 
% 
% \section{Introduction}
% 
% The code below is written in \Tcllogo~(see \textsc{http:}/\slash 
% \texttt{www.tcl.tk}/ for general information on this language) for 
% portability, simplicity, and robustness. The source format is a 
% variation\footnote{See \textit{The \textsf{tclldoc} package and 
% class}, \LaTeXe\ macro package, 2000~(v\,2.10), 2003~(v\,2.40);
% \textsc{ftp}:/\slash \texttt{ftp.tex.ac.uk}\slash
% \texttt{tex-archive}\slash \texttt{macros}\slash \texttt{latex}\slash 
% \texttt{contrib}\slash \texttt{tclldoc}/. However if you were able to 
% typeset this you probably already has this package installed.}
% on the \textsc{docstrip} format used for the \LaTeXe\ core and most 
% contemporary \LaTeX\ packages.
% 
% Section~\ref{Sec:NetworkBasics} implements basic operations on 
% networks, such as various forms of compositions, but the emphasis is 
% on operations needed to perform rewriting. These include |searchsub| 
% (which finds subnetworks of a given network that are isomorphic to a 
% given network), |replace| (which replaces a subnetwork by another 
% network with the same interface), and in particular |ambiguities| 
% (which lists all ambiguities that can be produced from a pair of 
% networks).
% 
% Section~\ref{Sec:VertexTypes} briefly deals with different types of 
% vertices, i.e., vertices corresponding to different operations. In 
% practice this mostly means that the type of a vertex determines its 
% arity (number of inputs) and coarity (number of outputs).
% 
% Section~\ref{Sec:Grafik} deals with information necessary to give a 
% graphical presentation of networks. There are currectly two ways of 
% doing this: interactively on the Tk |canvas|, or more statically as 
% PDF graphics. Edges are simply curves; there are no arrows, instead 
% information is thought to flow from the top of the network to the 
% bottom. The appearence of vertices can be more complicated and depends 
% on the type. In the example set of ``Hopf algebra vertex types'', the 
% antipode is drawn as a square, whereas all other vertex types are 
% drawn as circles (they can anyway be recognised by the number of 
% inputs and outputs).
% 
% Sections~\ref{Sec:Springs} and~\ref{Sec:Molecules} address the problem 
% of how to generate decent graphical presentations of networks that 
% were generated by splicing other networks---a problem that mostly 
% boils down to choosing coordinates for the vertices. The corresponding 
% problem for standard graphs is known to be very hard, but there exist 
% a number of heuristics which perform adequately in many situations. 
% In Section~\ref{Sec:Springs}, the ``sproing'' heuristic---a physical 
% simulation, where edges are modelled as springs and vertices are 
% masses, the idea being that an equilibrium should be aestetically 
% pleasing---is implemented. This turns out to work well for shaping the 
% edges (using the |elastic_edges| procedure), but not so well for 
% repositioning vertices (|sproing1|). In Section~\ref{Sec:Molecules} a 
% different model more inspired by the way that bonds between atoms 
% shape molecules is implemented (|sproing2|). This produces more 
% aestetically pleasing results.
% 
% In Section~\ref{Sec:Tillslutning} all of the above is combined into a 
% utility for completing a set of rewrite rules. This was mostly written 
% for testing purposes, and is therefore far more explicit (graphically 
% displaying intermediate results of calculations as they proceed, and 
% running rather slowly so that the data shown can be checked by the 
% human operator) than what is necessary for the sake of just 
% computations, but has nonetheless been used to carry out 
% some useful calculations.
% 
% 
% \subsection*{Preliminaries}
% 
% Some utility procedures which may come in handy in procedures below. 
% These are placed in the same |network| namespace as everything else, 
% but could just as well have been in the global namespace.
% 
% \begin{proc}{lsetappend}
%   The |lsetappend| procedure is designed to provide 
%   forward-compatibility with an important special case of the |end+1| 
%   syntax proposed in TIP~\#176, namely that
%   \begin{quote}
%     |lsetappend| \word{variable} \meta{indices} |end+1| \word{value}
%   \end{quote}
%   will have the effect of appending the \word{value} to the list 
%   returned by |lindex [set |\word{variable}|] |\meta{indices} and then 
%   storing this sublist back into its place in the \word{variable}.
%   \begin{tcl}
proc network::lsetappend {var args} {
   upvar 1 $var L
   set L2 [eval [list lindex $L] [lrange $args 0 end-2]]
   eval [list lset L] [lrange $args 0 end-1]
   lappend L2 [lindex $args end]
   eval [list lset L] [lrange $args 0 end-2] [list $L2]
}
%   \end{tcl}
%   Should the TIP be implemented, |lsetappend| could alternatively be 
%   implemented as an alias for |lset|.
%   
%   \begin{proc}{lsetappend1}
%     This is a special case of |lsetappend| for the case that there is 
%     precisely one index. It avoids the |eval| commands, so that all 
%     of it can be byte-compiled.
%     \begin{tcl}
proc network::lsetappend1 {var index end+1 val} {
   upvar 1 $var L
   set L2 [lindex $L $index]
   lset L $index {}
   lappend L2 $val
   lset L $index $L2
}
%     \end{tcl}
%   \end{proc}
% \end{proc}
% 
% 
% \begin{proc}{breakeval}
% \begin{proc}{breakeval-aware}
%   These are two utility control structures. If something is 
%   |breakeval-aware| then you can use |breakeval| to break out of it 
%   and then have a command evaluated.
%   \begin{tcl}
proc network::breakeval {script} {return -code 10 $script}
proc network::breakeval-aware {args} {
   set code [catch {uplevel 1 $args} res]
   if {$code == 10} then {
      set code [catch {uplevel 1 $res} res]
   }
   if {$code == 1} then {
      return -code $code -errorinfo $::errorInfo\
        -errorcode $::errorCode $res
   } else {
      return -code $code $res
   }
}
%   \end{tcl}
% \end{proc}\end{proc}
% 
% 
% \section{Basic network data structure}
% \label{Sec:NetworkBasics}
% 
% In keeping with \emph{everything is a string}, a network will be a 
% \Tcllogo\ value. All references to things will be indices of things in 
% that same data structure. On the top level, a network is a list
% \begin{quote}
%   \word{vertices} \word{edges} \word{legs} \word{info}
%   \word{other}\regstar
% \end{quote}
% The \word{vertices} here is a list of vertex descriptions and 
% \word{edges} is a list of edge descriptions. The \word{legs} is a list 
% \begin{quote}
%   \word{output-legs} \word{input-legs} \word{other}\regstar
% \end{quote}
% where \word{output-legs} and \word{input-legs} are both lists of 
% indices into the \word{edges} list, specifying which edges are the 
% output and the input legs respectively. \word{info} is a dictionary 
% in which miscellaneous information can be stored. Finally, the 
% network and \word{legs} lists may contain any number of the 
% \word{other} elements, but the meanings of these are unspecified and 
% commands operating on networks are not required to preserve or update 
% any of that information. Some more specialised sets of operations 
% stick information into such list elements for easy access.
% 
% A \word{vertex-description} is a list
% \begin{quote}
%   \word{decoration} \word{incidence} \word{info} \word{other}\regstar
% \end{quote}
% where the \word{decoration} is simply a string, \word{incidence} is a 
% list of (indices of) those edges to which the vertex is incident (in 
% the order of the ports for this kind of vertex), and \word{info} is a 
% dictionary with miscellaneous information. As with networks as a 
% whole, the \word{other} elements are allowed, not required, and 
% completely unspecified.
% 
% An \word{edge-description} similarly is a list
% \begin{quote}
%   \word{out-vertex} \word{in-vertex} \word{info} \word{other}\regstar
% \end{quote}
% where \word{out-vertex} and \word{in-vertex} are the indices of the 
% vertices to which this edge is incident. In case this edge is input 
% leg $n$ (and its input thus is not attached to any vertex), the 
% \word{in-vertex} will be $-n-1$, and similarly in case this edge is 
% output leg $n$ (and its output thus is not attached to any vertex), 
% the \word{out-vertex} will be $-n-1$. As above, the \word{info} is a 
% dictionary with miscellaneous information and any \word{other} 
% elements are unspecified and not required.
% 
% The following is an example of a single vertex network.
% \begin{quote}
%   |{{m {2 0 1} {}}}|\\
%   |{{0 -1 {}} {0 -2 {}} {-1 0 {}}}|\\
%   |{2 {0 1}}|\\
%   |{}|
% \end{quote}
% The following is a network for the Hopf algebra expression \( m \circ 
% (\mathrm{id} \otimes\nobreak S) \circ \Delta\):
% \begin{quote}
%   |{{m {0 1 2} {}} {S {2 3} {}} {Delta {1 3 4} {}}}|\\
%   |{{-1 0 {}} {0 2 {}} {0 1 {}} {1 2 {}} {2 -1 {}}}|\\
%   |{0 4}|\\
%   |{}|
% \end{quote}
% 
% 
% \subsection{PROPpy operations}
% 
% \begin{proc}{tensorprod}
%   This procedure computes the tensor product (in PROP sense) of a list 
%   of networks, i.e., it places them all side by side. The syntax is
%   \begin{quote}
%     |network::tensorprod| \word{network}\regplus
%   \end{quote}
%   and the return value is the resulting network. All \word{other} 
%   values of vertices and edges are preserved, but not updated. The 
%   first \word{other} of the individual networks are concatenated 
%   (probably equivalent to a |dict merge|).
%   
%   The implementation simply appends elements to the \word{vertices},  
%   \word{edges}, and \word{legs} lists, renumbering the incides as 
%   necessary.
%   \begin{tcl}
proc network::tensorprod {NW args} {
   foreach {V E L D} $NW {break}
   foreach {Lo Li} $L {break}
   foreach NW2 $args {
      set vdiff [llength $V]
      set ediff [llength $E]
      set lidiff [expr {-[llength $Li]}]
      set lodiff [expr {-[llength $Lo]}]
      foreach {V2 E2 L2 D2} $NW2 {break}
      foreach v $V2 {
         set I [list]
         foreach i [lindex $v 1] {
            lappend I [expr {$i+$ediff}]
         }
         lappend V [lreplace $v 1 1 $I]
      }
      foreach e $E2 {
         set i [lindex $e 1]
         if {$i>=0} then {incr i $vdiff} else {incr i $lidiff}
         set o [lindex $e 0]
         if {$o>=0} then {incr o $vdiff} else {incr o $lodiff}
         lappend E [lreplace $e 0 1 $o $i]
      }
      foreach i [lindex $L2 1] {
         lappend Li [expr {$i + $ediff}]
      }
      foreach o [lindex $L2 0] {
         lappend Lo [expr {$o + $ediff}]
      }
      eval [list lappend D] $D2
   }
   return [list $V $E [list $Lo $Li] $D]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{compose}
%   The |compose| procedure composes networks by connecting the inputs 
%   of one network to the outputs of another. The syntax is
%   \begin{quote}
%     |network::compose| \word{network} \begin{regblock}[\regstar]^^A
%     \meta{option}\regstar \word{network}\end{regblock}
%   \end{quote}
%   and the return value is the composed network. The outputs of the 
%   composite network will be the outputs of the first \word{network}, 
%   whereas the inputs of the composite network will be the inputs of 
%   the last \word{network}.
%   
%   The \meta{option}s may consist of one or several words, but the 
%   first word of an option must be a list of length one, typically a 
%   string beinning with a hyphen, and that word determines how many 
%   words the option consists of. The only option currently defined is 
%   |-nocomplain| (one word) which changes the behaviour with respect to 
%   handling the situation that the number of inputs to connect is 
%   different from the number of outputs to which they are to be 
%   connected. This is normally an error, but when |-nocomplain| is 
%   specified the extra inputs or outputs on the right are carried 
%   through to become inputs\slash outputs of the composite network.
%   
%   \begin{tcl}
proc network::compose {NW args} {
   set complain 1
   foreach arg $args {
      if {[llength $arg] == 1} then {
         switch -- $arg -nocomplain {
            set complain 0
         } default {
            error "Unknown option '$arg'."
         }
         continue
      }
%   \end{tcl}
%   The following complains, or appends extra edges as needed. These 
%   extra edges are improper in that they connect an input to an output 
%   (no intermediate vertex), but that is almost immediately corrected 
%   in the actual composition.
%   \begin{tcl}
      while {[llength [lindex $NW 2 1]] > [llength [lindex $arg 2 0]]} {
         if {$complain} then {
            error "More inputs than outputs for:\n$NW\ncirc\n$arg"
         }
         set n [llength [lindex $arg 1]]
         lset arg 2 0 [linsert [lindex $arg 2 0] end $n]
         lset arg 2 1 [linsert [lindex $arg 2 1] end $n]
         lset arg 1 [linsert [lindex $arg 1] end [
           list -[llength [lindex $arg 2 0]]\
             -[llength [lindex $arg 2 1]] {}
         ]]
      }
      while {[llength [lindex $NW 2 1]] < [llength [lindex $arg 2 0]]} {
         if {$complain} then {
            error "More outputs than inputs for:\n$NW\ncirc\n$arg"
         }
         set n [llength [lindex $NW 1]]
         lset NW 2 0 [linsert [lindex $NW 2 0] end $n]
         lset NW 2 1 [linsert [lindex $NW 2 1] end $n]
         lset NW 1 [linsert [lindex $NW 1] end [
           list -[llength [lindex $NW 2 0]]\
             -[llength [lindex $NW 2 1]] {}
         ]]
      }
%   \end{tcl}
%   The composed network is built by appending the elements of |arg| to 
%   the relevant parts of |NW|, with the exception for the 
%   legs-being-joined which are instead modified in place. The indices 
%   of the vertices thus added to |NW| are simply the shifted indices of 
%   these vertices in |arg|. Since edge index changes are less 
%   predictable, an array |Emap| is constructed which map old indices in 
%   |arg| to new indices in the extended |NW|.
%   
%   The very first step is too join the legs. Here the first 
%   \word{other} elements are concatenated, with the data from the left 
%   component placed last (thus for dictionary interpretation overriding 
%   corresponding data from the left). 
%   \begin{tcl}
      set vshift [llength [lindex $NW 0]]
      array unset Emap
      foreach i [lindex $NW 2 1] o [lindex $arg 2 0] {
         set Emap($o) $i
         set v [lindex $arg 1 $o 1]
         if {$v>=0} then {incr v $vshift}
         lset NW 1 $i 1 $v
         lset NW 1 $i 2 [concat [lindex $arg 1 $o 2] [lindex $NW 1 $i 2]]
      }
%   \end{tcl}
%   Then the remaining edges are copied as they are. The list of edges 
%   is pulled out so that it can be |lappend|ed to, and the |NW| 
%   element is temporarily cleared to avoid unnecessary copying. It is 
%   used that all of the edges copied here end in a vertex, since none 
%   of them is an output leg.
%   \begin{tcl}
      set E [lindex $NW 1]; lset NW 1 {}
      set i 0
      foreach e [lindex $arg 1] {
         if {![info exists Emap($i)]} then {
            set Emap($i) [llength $E]
            lset e 0 [expr {[lindex $e 0] + $vshift}]
            set v [lindex $e 1]
            if {$v>=0} then {incr v $vshift}
            lset e 1 $v
            lappend E $e
         }
         incr i
      }
      lset NW 1 $E
%   \end{tcl}
%   Vertices are similarly copied as they are, only the incidences are 
%   changed. The inputs are replaced. The \word{info}s are merged.
%   \begin{tcl}
      set V [lindex $NW 0]; lset NW 0 {}
      foreach v [lindex $arg 0] {
         set L [list]
         foreach i [lindex $v 1] {lappend L $Emap($i)}
         lappend V [lreplace $v 1 1 $L]
      }
      lset NW 0 $V
      set L [list]
      foreach i [lindex $arg 2 1] {lappend L $Emap($i)}
      lset NW 2 1 $L
      lset NW 3 [concat [lindex $arg 3] [lindex $NW 3]]
   }
   return $NW
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{levels_list}
%   The |levels_list| procedure organises the vertices of a network 
%   into levels and returns a list of the vertex numbers organised by 
%   level. The syntax is
%   \begin{quote}
%     |network::levels_list| \word{network}
%   \end{quote}
%   where \word{network} is the network to look at. The return value 
%   is a list of levels, starting with the bottommost and continuing 
%   upwards. Each level is a list (in no particular order) of the numbers 
%   of the vertices that belong to that level.
%   \changes{alpha}{2004/07/23}{Removed type-array argument; the 
%     network itself contains all the necessary information. (LH)}
%   
%   In order to belong to a level, a vertex must have all its outputs to 
%   lower level vertices or legs of the vertex as a whole. Note that 
%   this requires that all vertices without outputs are placed in the 
%   lowest level---something which is not necessarily what one would 
%   expect, but in practice necessary. It is an \emph{error} (which will 
%   be detected) if the network has a directed cycle.
%   
%   The algorithm maintains a set of ``active edges''---edges going 
%   from a completed level to something outside the completed 
%   levels---and looks for vertices for the next level among those at 
%   the input end of these active edges. The first level is however 
%   built in a loop over all vertices, since also vertices without 
%   outputs must be caught by the algorithm.
%   \begin{tcl}
proc network::levels_list {NW} {
   set res [list]
   set left [llength [lindex $NW 0]]
   foreach i [lindex $NW 2 0] {set A($i) 0}
   set V [list]
   set newE [list]
   set n 0
   foreach v [lindex $NW 0] {
      set here 1
      foreach i [lindex $v 1] {
         if {[lindex $NW 1 $i 1]==$n && ![info exists A($i)]} then {
            set here 0; break
         }
      }
      if {$here} then {
         lappend V $n; incr left -1
         foreach i [lindex $v 1] {
            if {[info exists A($i)]} then {
               unset A($i)
            } else {
               lappend newE $i
            }
         }
      }
      incr n
   }
   lappend res $V
   while {$left>0 && [llength [lindex $res end]]} {
      foreach i $newE {set A($i) [llength $res]}
      set newE [list]
      set V [list]
      foreach i [array names A] {
         if {![info exists A($i)]} then {continue}
         set n [lindex $NW 1 $i 1]
         if {$n<0} then {unset A($i); continue}
         set here 1
         foreach j [lindex $NW 0 $n 1] {
            if {[lindex $NW 1 $j 1]==$n && ![info exists A($j)]} then {
               set here 0; break
            }
         }
         if {$here} then {
            lappend V $n; incr left -1
            foreach j [lindex $NW 0 $n 1] {
               if {[info exists A($j)]} then {
                  unset A($j)
               } else {
                  lappend newE $j
               }
            }
         }
      }
      lappend res $V
   }
   if {$left>0} then {
      error "Cycle in network $NW; see edges [array names A]."
   } else {
      return $res
   }
}
%   \end{tcl}  
% \end{proc}
% 
% 
% \begin{proc}{avglex_levels}
%   The |avglex_levels| procedure computes a list of levels in the 
%   network, not unlike |levels_list|, but |deglex_levels| also tries 
%   to compute reasonable horizontal positions for the vertices. The 
%   call syntax is
%   \begin{quote}
%     |network::avglex_levels| \word{network}
%   \end{quote}
%   and the return value is a list of levels, starting with the one 
%   closest to the output. The levels are lists where each element is 
%   either the number of a vertex or |-1| meaning ``empty spot''.
%   
%   \begin{proc}{avglex_levels,step}
%     The |avglex_levels,step| procedure is a helper for 
%     |avglex_levels| that computes one level in the network. The 
%     syntax is
%     \begin{quote}
%       |network::avglex_levels,step| \word{levels-var} \word{cut-var} 
%       \word{network}
%     \end{quote}
%     where \word{levels-var} and \word{cut-var} are names of variables 
%     in the local context of the caller. The computed level will be 
%     appended to the list in the \word{levels-var}. The \word{cut-var} 
%     contains the current cut (a list of edge numbers); the previous 
%     cut before the call and the next cut upon return. The 
%     \word{network} is the network to find a level in. The return 
%     value is the number of vertices that were placed in the level.
%     
%     The order of items in the level is based on the ordering of the 
%     cut (a set of edges) between the previous level and the current. 
%     To each upper endpoint (usually a vertex, but could also be an 
%     input) of an edge in the cut is assigned the set of indices in 
%     the cut of the edges that end there. These sets are then ordered 
%     ``average-lexicographically'': primarily the average of the 
%     indices are compared, then sets with equal averages are compared 
%     lexicographically (or perhaps rather reverse lexicographically 
%     \dots). The upper endpoints that belong to this level get their 
%     numbers put in the list, whereas the endpoints that do not are 
%     represented by |-1| elements.
%     
%     The new cut is a refinement of the order in the level, meaning 
%     edges that correspond to the same endpoint appear in sequence. 
%     Those edges within a group that merely pass through a level keep 
%     their previous order. Those edges that have their output ends at 
%     a vertex in the level appear in the order that they are listed in 
%     the incidence list of the vertex.
%     
%     \begin{tcl}
proc network::avglex_levels,step {levelsvar cutvar NW} {
   upvar 1 $levelsvar levels $cutvar cut
   set count 0
   set n 0; foreach e $cut {
      lappend Set([lindex $NW 1 $e 1]) $n $e
      set Seen($e) {}
      incr n
   }
   set Ends [list]
   foreach v [array names Set] {
      set sum 0
      set L [list]
      foreach {n e} $Set($v) {
         incr sum $n
         lappend L $n
      }
      lappend Ends [list $v "[expr {round ($sum*60.0/[llength $L])}]\
        [lsort -integer -decreasing $L]"]
   }
   set level [list]
   set cut [list]
   foreach v [lsort -index 1 -dictionary $Ends] {
      set v [lindex $v 0]
      if {$v < 0} then {
         lappend level -1
         foreach {n e} $Set($v) {lappend cut $e}
      } else {
         set Up [list]
         set Down [list]
         set here 1
         foreach e [lindex $NW 0 $v 1] {
            if {[lindex $NW 1 $e 0] == $v} then {
               lappend Up $e
            } elseif {[info exists Seen($e)]} then {
               lappend Down $e
            } else {
               set here 0
            }
         }
         if {$here} then {
            lappend level $v
            incr count
            eval [list lappend cut] $Up
         } else {
            lappend level -1
            eval [list lappend cut] $Down
         }
      }
   }
   lappend levels $level
   return $count
}
%     \end{tcl}
%   \end{proc}
% 
%   \begin{tcl}
proc network::avglex_levels {NW} {
   set res [list]
   set left [llength [lindex $NW 0]]
   set cut [lindex $NW 2 0]
   set left [expr {$left - [avglex_levels,step res cut $NW]}]
   set level [lindex $res 0]
   set n 0; foreach v [lindex $NW 0] {
      set down 0
      set Up [list]
      foreach i [lindex $v 1] {
         if {[lindex $NW 1 $i 0]==$n} then {
            lappend Up $i
         } else {
            incr down
         }
      }
      if {$down==0} then {
         lappend level $n
         eval [list lappend cut] $Up
         incr left -1
      }
      incr n
   }
   lset res 0 $level
   while {$left>0} {
      set size [avglex_levels,step res cut $NW]
      if {$size == 0} then {
         error "Cycle in network $NW, above edges $cut."
      }
      set left [expr {$left - $size}]
   }
   return $res
}
%   \end{tcl}  
% \end{proc}
% 
% 
% 
% \subsection{Sheaf operations}
% 
% 
% \begin{proc}{induced}
%   The |induced| procedure returns the subnetwork induced by a set of 
%   vertices. The syntax is
%   \begin{quote}
%     |network::induced| \word{network} \word{vertex-list}
%     \begin{regblock}[\regopt]\word{output-list}
%     \word{input-list}\end{regblock}
%   \end{quote}
%   where the \word{output-list} and \word{input-list} arguments can be 
%   used to control the order of the legs (which should be considered 
%   an artefact of the implementation rather than a property of the 
%   mathematical object).
%   
%   The \word{vertex-list} is a list of vertex numbers in the 
%   \word{network}. They will be picked in that order and placed in the 
%   new network. Edges are numbered as they are encountered when the 
%   incidence lists of the vertices are read. Finally the lists of legs 
%   are built, starting with those listed in the \word{output-list} and 
%   \word{input-list} (these default to empty, and edges listed which 
%   are not a leg or the wrong kind of leg are ignored). Unlisted legs 
%   appear last, in their edge number order from the \word{network}.
%   
%   The most important data structure used below is the |M| array. It 
%   maps edge numbers in the \word{network} to an end (encoded as a list 
%   \word{edge number} \word{0 or 1}) of an edge in the result network. 
%   Entires in this array are created when edges are added to the list 
%   |E| of edges and removed when both ends of the edge have been 
%   attached to something. The \word{0 or 1} is the index in the edge 
%   (seen as a list) of the element that remains to be set.
%   \begin{tcl}
proc network::induced {NW VL {OL {}} {IL {}}} {
   set V [list]
   set E [list]
   foreach n $VL {
      set v [lindex $NW 0 $n]
      set iL [list]
      foreach i [lindex $v 1] {
         if {[info exists M($i)]} then {
            lappend iL [lindex $M($i) 0]
            eval [list lset E] $M($i) [list [llength $V]]
            unset M($i)
         } else {
            lappend iL [llength $E]
            lappend E [lreplace [lindex $NW 1 $i] 0 1 {} {}]
            if {[lindex $NW 1 $i 0] == $n} then {
               lset E end 0 [llength $V]
               set M($i) [list [lindex $iL end] 1]
            } else {
               set M($i) [list [lindex $iL end] 0]
               lset E end 1 [llength $V]
            }
         }
      }
      lset v 1 $iL
      lappend V $v
   }
   set oL [list]
   foreach n $OL {
      if {![info exists M($n)] || [lindex $M($n) 1] != 0}\
        then {continue}
      lappend oL [lindex $M($n) 0]
      eval [list lset E] $M($n) [list [expr {-[llength $oL]}]]
      unset M($n)
   }
   set iL [list]
   foreach n $IL {
      if {![info exists M($n)] || [lindex $M($n) 1] != 1}\
        then {continue}
      lappend iL [lindex $M($n) 0]
      eval [list lset E] $M($n) [list [expr {-[llength $iL]}]]
      unset M($n)
   }
   foreach n [lsort -integer [array names M]] {
      if {[lindex $M($n) 1]} then {
         lappend iL [lindex $M($n) 0]
         eval [list lset E] $M($n) [list [expr {-[llength $iL]}]]
      } else {
         lappend oL [lindex $M($n) 0]
         eval [list lset E] $M($n) [list [expr {-[llength $oL]}]]
      }
   }
   list $V $E [list $oL $iL] [lindex $NW 3]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{replace}
%   The |replace| procedure replaces the subnetwork induced by a set of 
%   vertices with another network, and returns the network produced by 
%   this operation. The syntax is
%   \begin{quote}
%     |network::replace| \word{in-network} \word{vertex-list}
%     \begin{regblock}[\regopt]\word{output-list}
%     \word{input-list}\end{regblock} \word{with-network}
%   \end{quote}
%   where \word{in-network} is the network to replace a piece of and 
%   \word{with-network} what that piece should be replaced with. The 
%   \word{vertex-list} is the list (but the order is irrelevant) of 
%   vertices in the \word{in-network} that should be replaced. The 
%   \word{output-list} and \word{input-list} specify how legs of the 
%   \word{with-network} should be indentified with edges in the 
%   \word{in-netowrk}. If they are omitted, then the edges are taken in 
%   their numerical order from the \word{in-network}. The 
%   \word{output-list} and \word{input-list} may not be incomplete or 
%   contain extra elements.
%   
%   The first part does some checking of arguments and computes the two 
%   optional arguments if they have not been given explicitly.
%   \begin{tcl}
proc network::replace {NW1 VL args} {
   if {[llength $args] == 3} then {
      foreach {outlegL inlegL NW2} $args {break}
   } elseif {[llength $args] == 1} then {
      set NW2 [lindex $args 0]
      set outlegL [list]
      set inlegL [list]
      for {set n 0} {$n < [llength [lindex $NW1 1]]} {incr n} {
         set t [expr { 
           (
             [lsearch -exact -integer $VL [lindex $NW1 1 $n 0]] >= 0
           ) + 2*(
             [lsearch -exact -integer $VL [lindex $NW1 1 $n 1]] >= 0
           )
         }]
         if {$t==1} then {
            lappend inlegL $n
         } elseif {$t==2} then {
            lappend outlegL $n
         }
      }
   } else {
      error "Wrong number of arguments.\nShould be:\
        network::replace in-network vertex-list ?output-list\
        input-list? with-network"
   }
   if {[llength $outlegL] != [llength [lindex $NW2 2 0]]} then {
      error "Interface mismatch. Cannot attach\
        [llength [lindex $NW2 2 0]] output legs to [llength $outlegL]\
        edges."
   }
   if {[llength $inlegL] != [llength [lindex $NW2 2 1]]} then {
      error "Interface mismatch. Cannot attach\
        [llength [lindex $NW2 2 1]] input legs to [llength $inlegL]\
        edges."
   }
%   \end{tcl}
%   Then comes the actual construction of a new network. It starts from 
%   the \word{with-network} (since all vertices and edges in that will 
%   be present in the result) and appends additional vertices and edges 
%   as necessary. The |MV| and |ME| arrays map vertex and edge numbers 
%   from the \word{in-network} |NW1| to their counterparts in the result 
%   network.
%   \begin{tcl}
   foreach {V E} $NW2 {break}
   foreach l $outlegL i [lindex $NW2 2 0] {set ME($l) $i}
   foreach l $inlegL  i [lindex $NW2 2 1] {set ME($l) $i}
   for {set n 0} {$n < [llength [lindex $NW1 0]]} {incr n} {
      if {[lsearch -exact -integer $VL $n] >= 0} then {continue}
      set MV($n) [llength $V]
      set v [lindex $NW1 0 $n]
      set iL [list]
      foreach i [lindex $v 1] {
         if {![info exists ME($i)]} then {
            set ME($i) [llength $E]
            lappend E [lreplace [lindex $NW1 1 $i] 0 1 {} {}]
         }
         lappend iL $ME($i)
         lset E $ME($i) [expr {[lindex $NW1 1 $i 1] == $n}] $MV($n)
      }
      lset v 1 $iL
      lappend V $v
   }
   set oL [list]
   set n -1
   foreach l [lindex $NW1 2 0] {
      lappend oL $ME($l)
      lset E $ME($l) 0 $n
      incr n -1
   }
   set iL [list]
   set n -1
   foreach l [lindex $NW1 2 1] {
      lappend iL $ME($l)
      lset E $ME($l) 1 $n
      incr n -1
   }
   list $V $E [lreplace [lindex $NW1 2] 0 1 $oL $iL] [lindex $NW1 3]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{renumber}
%   The |renumber| procedure renumbers the vertices and edges of a 
%   network, returning the thus modified network. The syntax is
%   \begin{quote}
%     |network::renumber| \word{network} \word{vertex-map} 
%     \word{edge-map}
%   \end{quote}
%   where \word{vertex-map} and \word{edge-map} are dictionaries mapping 
%   old vertex\slash edge indices to new such indices. It is an error if 
%   the domain and ranges of these maps are not $\bigl\{ 0, \dotsc, 
%   \lvert V\rvert -\nobreak 1 bigr\}$ and $\bigl\{ 0, \dotsc, 
%   \lvert E\rvert -\nobreak 1 bigr\}$ respectively.
%   
%   The \word{other} data (if there is any) in the network is not 
%   affected by this operation.
%   
%   \begin{tcl}
proc network::renumber {NW Vmap Emap} {
   array set VA $Vmap
   if {[array size VA] != [llength [lindex $NW 0]]} then {
      error "Bad vertex renumbering map."
   }
   array set EA $Emap
   if {[array size EA] != [llength [lindex $NW 1]]} then {
      error "Bad edge renumbering map."
   }
   foreach {old new} $Vmap {set invVA($new) $old}
   set VL [list]
   for {set n 0} {$n<[llength [lindex $NW 0]]} {incr n} {
      set v [lindex $NW 0 $invVA($n)]
      set iL [list]
      foreach i [lindex $v 1] {lappend iL $EA($i)}
      lappend VL [lreplace $v 1 1 $iL]
   }
   foreach {old new} $Emap {set invEA($new) $old}
   set EL [list]
   for {set n 0} {$n<[llength [lindex $NW 1]]} {incr n} {
      set e [lindex $NW 1 $invEA($n)]
      set i [lindex $e 1]
      if {$i>=0} then {set i $VA($i)}
      set o [lindex $e 0]
      if {$o>=0} then {set o $VA($o)}
      lappend EL [lreplace $e 0 1 $o $i]
   }
   set iL [list]
   foreach i [lindex $NW 2 1] {lappend iL $EA($i)}
   set oL [list]
   foreach o [lindex $NW 2 0] {lappend oL $EA($o)}
   return [lreplace $NW 0 2 $VL $EL [list $oL $iL]]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{canonical_form}
%   The |canonical_form| procedure tries to compute a canonical form 
%   of a network, by renumbering the vertices and edges in a way that 
%   is independent of their numbers in the input network, clearing all 
%   \word{info} entries, and removing all \word{other} entries. This 
%   canonical form may be used to test network equality and as array 
%   index.
%   
%   The syntax is
%   \begin{quote}
%     |network::canonical_form| \word{network} 
%     \word{components-var}\regopt
%   \end{quote}
%   where the \word{components-var}, if it is included, if the name of 
%   a variable in the local context of the caller which will be set to 
%   the number of components in the network. The return value is the 
%   canonical form of the network. 
%   \emph{This procedure may however throw an error.} Errors are thrown 
%   for networks with isolated (not reachable from any leg) components, 
%   since I haven't worked out a way to canonise such parts.
%   
%   The algorithm does a breadth first search through the network, 
%   starting from output leg $0$. Edges around a vertex are looked at in 
%   the order of incidence at that vertex. If an entire component has 
%   been examined but not all vertices of the network, then the search 
%   starts again with the next output leg, or is all such have been 
%   visited, with the next input leg.
%   \begin{tcl}
proc network::canonical_form {NW {componentsvar {}}} {
   set V [list]
   set E [list]
   set VL [string repeat "-1 " [llength [lindex $NW 0]]]
   set EL [string repeat "-1 " [llength [lindex $NW 1]]]
   set count 0
   set side 0
   set legindex 0
   while {[lsearch -integer $VL -1] >= 0} {
      while {$side<=1} {
         if {$legindex >= [llength [lindex $NW 2 $side]]} then {
            incr side
            set legindex 0
         } elseif {[lindex $EL [lindex $NW 2 $side $legindex]] != -1}\
         then {
            incr legindex
         } else {
            break
         }
      }
      if {$side > 1} then {
         error "Vertex assignment is\n$VL\nbut all legs have been\ 
           processed."
      }
      incr count
      set EQ [list [lindex $NW 2 $side $legindex]]
      while {[llength $EQ]} {
         set VQ [list]
         foreach e $EQ {
            if {[lindex $EL $e] != -1} then {continue}
            lset EL $e [llength $E]
            lappend E [lreplace [lindex $NW 1 $e] 2 end {}]
            lappend VQ [lindex $NW 1 $e 0] [lindex $NW 1 $e 1]
         }
         set EQ [list]
         foreach v $VQ {
            if {[lindex $VL $v] != -1} then {continue}
            lset VL $v [llength $V]
            lappend V [lreplace [lindex $NW 0 $v] 2 end {}]
            foreach e [lindex $NW 0 $v 1] {lappend EQ $e}
         }
      }
   }
   if {[string length $componentsvar]} then {
      uplevel 1 [list set $componentsvar $count]
   }
   for {set v 0} {$v < [llength $V]} {incr v} {
      for {set i 0} {$i < [llength [lindex $V $v 1]]} {incr i} {
         lset V $v 1 $i [lindex $EL [lindex $V $v 1 $i]]
      }
   }
   for {set e 0} {$e < [llength $E]} {incr e} {
      if {[lindex $E $e 0] >= 0} then {
         lset E $e 0 [lindex $VL [lindex $E $e 0]]
      }
      if {[lindex $E $e 1] >= 0} then {
         lset E $e 1 [lindex $VL [lindex $E $e 1]]
      }
   }
   set Out [list]
   foreach l [lindex $NW 2 0] {lappend Out [lindex $EL $l]}
   set In [list]
   foreach l [lindex $NW 2 1] {lappend In [lindex $EL $l]}
   return [list $V $E [list $Out $In] {}]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Searching for subnetworks}
% 
% \begin{proc}{searchsub}
%   The |searchsub| procedure searches for subnetworks of a given 
%   network that are isomorphic to another network. It returns the list 
%   of those occurrencies it finds, where each occurence is a list
%   \begin{quote}
%     \word{vertex-list} \word{output-list} \word{input-list}
%   \end{quote}
%   Element $n$ in the \word{vertex-list} is the number in the whole 
%   network of the vertex which corresponds to vertex $n$ in the 
%   network searched for. Similarly element $n$ in the \word{output-list} 
%   or \word{input-list} is the number in the whole network of the edge 
%   which corresponds to output or input leg $n$ in the network searched 
%   for.
%   
%   The syntax is
%   \begin{quote}
%     |network::searchsub| \word{in-network} \word{for-network}
%       |-all|\regopt
%   \end{quote}
%   Without the |-all| option, the procedure returns after finding one 
%   occurrence; with it, all occurrencies are found.
%   
%   An important data structure used in this procedure is the ``vertex 
%   map'' |VM|. This is a list indexed by vertex number in the 
%   \word{in-network}, and its elements may be vertex numbers in the 
%   \word{for-network}. It may also be a negative number (if the vertex 
%   was reached by going over a leg and thus cannot be part of the 
%   subnetwork) or an empty string (if it is currently unassigned). 
%   Somewhat analogous is the ``edge map'' |EM|, which is like |VM| 
%   but throughout deals with edge numbers instead.
%   
%   The nature of the problem that the |searchsub| procedure has to 
%   deal with is such that it sometimes has to make choices. For the 
%   sake of being able to undo choices, it maintains a |Stack|. 
%   This is a list with the structure
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{vertices} 
%     \word{edges}\end{regblock}
%   \end{quote}
%   where \word{vertices} and \word{edges} are lists of indices in |VM| 
%   and |EM| respectively that were assigned in the same round, and thus 
%   need to be unassigned simultaneously. 
%   
%   \begin{proc}{searchsub_expandable?}
%     The |searchsub_expandable?| procedure is a helper for |searchsub| 
%     and assumes to be called from the latter (directly accessing 
%     several of its variables). The call syntax is
%     \begin{quote}
%       |network::searchsub_expandable?| \word{v1} \word{v2}
%     \end{quote}
%     and this poses the question whether |VM| can consistently be 
%     extended so that \word{v1} is mapped to \word{v2}. If the answer 
%     is |1| (yes) then |VM|, |EM|, and |Stack| are updated accordingly. 
%     If the answer is |0|, then these lists are the same after the call 
%     as before it.
%     
%     The procedure happily assumes that the answer will be |1| and sets 
%     entries in |VM| and |EM| as it discovers what values they should 
%     have. If it encounters a contradiction then it will undo these 
%     assignments and return |0|.
%     
%     The implementation is based on a queue of things to assign; when 
%     this queue becomes empty, the maps have been fully updated and it 
%     is clear that no contradiction occurred. The elements of this 
%     queue are lists with the structure
%     \begin{quote}
%       \word{vertex?} \word{1-index} \word{2-index}
%     \end{quote}
%     where \word{vertex?} is |1| for vertices and |0| for edges. The 
%     \word{1-index} is index in |NW1| and the \word{2-index} is index 
%     in |NW2|.
%     \begin{tcl}
proc network::searchsub_expandable? {v1 v2} {
   upvar 1 NW1 NW1 NW2 NW2 VM VM EM EM Stack Stack
   set VL [list]
   set EL [list]
   set queue [list [list 1 $v1 $v2]]
   while 1 {
      if {![llength $queue]} then {
         lappend Stack $VL $EL
         return 1
      }
      foreach {type i1 i2} [lindex $queue 0] break
      set queue [lreplace $queue [set queue 0] 0]
      if {$type} then {
         if {[lindex $VM $i1] == $i2} then {continue}
         if {[string length [lindex $VM $i1]]} then {break}
         if {[lindex $NW1 0 $i1 0] ne [lindex $NW2 0 $i2 0]} then {break}
         lset VM $i1 $i2
         lappend VL $i1
         foreach e1 [lindex $NW1 0 $i1 1] e2 [lindex $NW2 0 $i2 1] {
            lappend queue [list 0 $e1 $e2]
         }
      } else {
         if {[lindex $EM $i1] == $i2} then {continue}
         if {[string length [lindex $EM $i1]]} then {break}
         lset EM $i1 $i2
         lappend EL $i1
% \smallskip
         set v1 [lindex $NW1 1 $i1 0]
         set v2 [lindex $NW2 1 $i2 0]
         if {$v2>=0} then {
            if {$v1<0} then {break}
            lappend queue [list 1 $v1 $v2]
         } elseif {$v1>=0} then {
            if {![string length [lindex $VM $v1]]} then {
               lset VM $v1 $v2
               lappend VL $v1
            } else {
               if {[lindex $VM $v1] >= 0} then {break}
            }
         }
% \smallskip
         set v1 [lindex $NW1 1 $i1 1]
         set v2 [lindex $NW2 1 $i2 1]
         if {$v2>=0} then {
            if {$v1<0} then {break}
            lappend queue [list 1 $v1 $v2]
         } elseif {$v1>=0} then {
            if {![string length [lindex $VM $v1]]} then {
               lset VM $v1 $v2
               lappend VL $v1
            } else {
               if {[lindex $VM $v1] >= 0} then {break}
            }
         }
      }
   }
   foreach v1 $VL {lset VM $v1 {}}
   foreach e1 $EL {lset EM $e1 {}}
   return 0
}
%     \end{tcl}
%   \end{proc}
%   
%   The vertex and edge maps keep track of a ``current state'', and the 
%   stack provides a means for unwinding it, but in order to do a search 
%   there must also be some data structure that keeps track of the 
%   branches of the search tree which have not yet been examined. This 
%   is the job of the ``inverse vertex map'' |IVM|. Like the |VM| it is 
%   a list that is indexed by vertex number, but here the indices are 
%   numbers of vertices in the \word{for-network} rather than the 
%   \word{in-network}. The list elements are either the string |*| or 
%   lists of numbers of vertices in the \word{in-network}. The last of 
%   these numbers is gives an inverse mapping to that of the |VM|, 
%   whereas the other numbers are mappings that still remain to be 
%   considered. The |*| should be interpreted as ``any vertex''; it is 
%   often replaced by a list of vertices of the correct type once the 
%   search gets to the vertex.
%   
%   \changes{alpha}{2006/08/22}{Changed some \texttt{for} loops to 
%     \texttt{foreach} with counter. New Tcl idiom? (LH)}
%   
%   \begin{tcl}
proc network::searchsub {NW1 NW2 {all ""}} {
   set VM [list]
   set n -1; foreach v [lindex $NW1 0] {incr n
      lappend Hastype([lindex $v 0]) $n
      lappend VM {}
   }
   set EM [list]
   foreach e [lindex $NW1 1] {lappend EM {}}
   set IVM [list]
   set n -1; foreach v [lindex $NW2 0] {incr n
      lappend Hastype2([lindex $v 0]) $n
      lappend IVM *
   }
   foreach type [array names Hastype2] {
      if {
         ![info exists Hastype($type)] || 
         [llength $Hastype($type)] < [llength $Hastype2($type)]
      } then {return}
   }
%   \end{tcl}
%   The above check verifies that the \word{in-network} contains at 
%   least as many vertices of each type as the \word{for-network}. If 
%   that is not the case then obviously the \word{for-network} cannot 
%   be found.
%   \begin{tcl}
   set Stack [list]
   set res [list]
   set v2_curr -2
   while {$v2_curr != -1} {
%   \end{tcl}
%   This main loop has two parts. In the first part, attempts are made 
%   to extend the inverse vertex map to cover vertices previously not 
%   covered. That |v2_curr| is |-2| is used as a signal to find a new 
%   vertex in the \word{for-network} to search from. Nonnegative values 
%   of |v2_curr| means that another search tree branch at that 
%   \word{for-network} vertex should be explored.
%   \begin{tcl}
      if {$v2_curr<0} then {
         set v2_curr [lsearch -exact $IVM *]
         if {$v2_curr>=0} then {
            lset IVM $v2_curr $Hastype([lindex $NW2 0 $v2_curr 0])
         }
      }
      if {$v2_curr>=0} then {
         while {[llength [lindex $IVM $v2_curr]]} {
            set v1 [lindex $IVM $v2_curr end]
            if {[searchsub_expandable? $v1 $v2_curr]} then {
               foreach u1 [lrange [lindex $Stack end-1] 1 end] {
                  set u2 [lindex $VM $u1]
                  if {$u2>=0} then {lsetappend1 IVM $u2 end+1 $u1}
               }
               set v2_curr -2
               break
            }
            lset IVM $v2_curr [lreplace [lindex $IVM $v2_curr] end end]
         }
         if {$v2_curr >= 0} then {
            lset IVM $v2_curr *
            set v2_curr -1
         }
      } else {
         set L [list]
         foreach t $IVM {lappend L [lindex $t end]}
         set L [list $L [lindex $NW2 2 0] [lindex $NW2 2 1]]
         for {set n 0} {$n < [llength $EM]} {incr n} {
            set l [lindex $EM $n]
            if {[string length $l]} then {
               set k [lindex $NW2 1 $l 0]
               if {$k<0} then {lset L 1 [expr {-$k-1}] $n}
               set k [lindex $NW2 1 $l 1]
               if {$k<0} then {lset L 2 [expr {-$k-1}] $n}
            }
         }
         lappend res $L
         if {![string length $all]} then {return $res}
      }
%   \end{tcl}
%   In the second part, the inverse vertex map is restricted back until 
%   a new branch of the search tree is encountered. That |v2_curr| is 
%   |-1| is used as a signal to back up the search tree. 
%   \begin{tcl}
      while {$v2_curr == -1 && [llength $Stack]} {
         foreach e [lindex $Stack end] {lset EM $e {}}
         set v2_curr [lindex $VM [lindex $Stack end-1 0]]
         foreach v1 [lindex $Stack end-1] {
            set v2 [lindex $VM $v1]
            lset VM $v1 {}
            if {$v2>=0} then {
               lset IVM $v2 [lreplace [lindex $IVM $v2] end end]
            }
         }
         set Stack [lreplace $Stack end-1 end]
         if {![llength [lindex $IVM $v2_curr]]} then {
            lset IVM $v2_curr *
            set v2_curr -1
         }
      }
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Listing ambiguities}
% 
% The \describestring[proc][network]{ambiguities}|ambiguities| procedure 
% computes all ambiguities that can be formed from a pair of networks. 
% The syntax is
% \begin{quote}
%   |network::ambiguities| \word{network $1$} \word{network $2$}
% \end{quote}
% and the return value is a list of ambiguities, each of which is a 
% list with the structure
% \begin{quote}
%   \word{network} \word{site $1$} \word{site $2$}
% \end{quote}
% where the two sites are lists
% \begin{quote}
%   \word{vertex-list $i$} \word{output-list $i$} \word{input-list $i$}
% \end{quote}
% such that the command
% \begin{quote}
%   |network::induced| \word{network} \word{vertex-list $i$} 
%   \word{output-list $i$} \word{input-list $i$}
% \end{quote}
% returns a network isomorphic to \word{network $i$}.
% 
% \begin{proc}{ambiguities,caplegs}
%   The implementation is based on a modification of the network data 
%   structure, where the legs are terminated by special end vertices 
%   and the normal vertex types are replaced by numbers to provide for 
%   easy identification of the end vertices (which get number |0|). 
%   Thus the first order of business is to rebuild the input networks 
%   |NW1| and |NW2| to this end. This is handled by the helper 
%   procedure |ambiguities,caplegs| which has the call syntax
%   \begin{quote}
%     |network::ambiguities,caplegs| \word{network-var}
%   \end{quote}
%   and in addition modifies the variables |Numtype|, |Stdtype|, and 
%   |nextnumtype| in the local context of its caller. The first two 
%   of these are arrays which keep track of the mappings between 
%   standard vertex types and numeric vertex types. The last is an 
%   integer variable that holds the number of the lowest unallocated 
%   numeric vertex type.
%   \begin{tcl}
proc network::ambiguities,caplegs {NWvar} {
   upvar 1 $NWvar NW Numtype Numtype Stdtype Stdtype\
     nextnumtype nextnumtype
   set V [lindex $NW 0]
   for {set n 0} {$n < [llength $V]} {incr n} {
      if {![info exists Numtype([lindex $V $n 0])]} then {
         set Numtype([lindex $V $n 0]) $nextnumtype
         set Stdtype($nextnumtype) [lindex $V $n 0]
         incr nextnumtype
      }
      lset V $n 0 $Numtype([lindex $V $n 0])
   }
   foreach e [lindex $NW 2 0] {
      lset NW 1 $e 0 [llength $V]
      lappend V [list 0 [list $e] {}]
   }
   foreach e [lindex $NW 2 1] {
      lset NW 1 $e 1 [llength $V]
      lappend V [list 0 [list $e] {}]
   }
   lset NW 0 $V
}
%   \end{tcl}
% \end{proc}
%   
% Internally, ambiguities are constructed as similarly capped 
% networks, to avoid dangling edges. Vertices may have empty incidence 
% positions, which are then set to |-1|. The current ambiguity being 
% constructed is stored in the two variables |V| (vertices) and |E| 
% (edges). In order to keep track of how vertices and edges in the 
% component networks correspond to elements of |V| and |E| there are 
% four lists |VL1|, |VL2|, |EL1|, and |EL2| indexed by vertex or edge 
% respectively number in the respective component networks, whose 
% elements are |-1| or the number of the corresponding ambiguity network.
% 
% 
% \begin{proc}{ambiguities,normalise}
%   The |ambiguities,normalise| procedure is a helper for |ambiguities| 
%   which convert the capped network format of an ambiguity to standard 
%   network format. The call syntax is
%   \begin{quote}
%     |network::ambiguities,normalise| \word{V} \word{E} \word{VL1} 
%     \word{VL2} \word{EL1} \word{EL2} \word{legs $1$} \word{legs $2$}
%   \end{quote}
%   where the two vertex mapping lists are restricted to non-cap 
%   vertices and the two \word{legs $i$} arguments are the legs parts of 
%   the corresponding networks. The procedure also accesses the array 
%   |Stdtype| in the local context of its caller to convert numeric 
%   vertex types to standard vertex types.
%   
%   The return value is a list \word{network} \word{site} \word{site} as 
%   described in the beginning of this subsection.
%   
%   Since all edges will remain after this operation, the procedure 
%   starts with processing the vertices. Old vertex numbers are mapped 
%   to new by the list |VL|. Cap vertex entries are set to |-1|.
%   \begin{tcl}
proc network::ambiguities,normalise {V E VL1 VL2 EL1 EL2 legs1 legs2} {
   upvar 1 Stdtype Stdtype
   set V_res [list]
   set VL [list]
   foreach v $V {
      if {[lindex $v 0 0] > 0} then {
         lset v 0 $Stdtype([lindex $v 0 0])
         lappend VL [llength $V_res]
         lappend V_res $v
         if {[lsearch -integer [lindex $v 1] -1] >= 0} then {
            error "This shouldn't happen."
         }
      } else {
         lappend VL -1
      }
   }
   set E_res [list]
   set Out_res [list]
   set In_res [list]
   foreach e $E {
      set v [lindex $VL [lindex $e 0]]
      if {$v >= 0} then {
         lset e 0 $v
      } else {
         lappend Out_res [llength $E_res]
         lset e 0 [expr {-[llength $Out_res]}]
      }
      set v [lindex $VL [lindex $e 1]]
      if {$v >= 0} then {
         lset e 1 $v
      } else {
         lappend In_res [llength $E_res]
         lset e 1 [expr {-[llength $In_res]}]
      }
      lappend E_res $e
   }
   set NW [list $V_res $E_res [list $Out_res $In_res] {}]
   set L [list]
   foreach v $VL1 {lappend L [lindex $VL $v]}
   set site1 [list $L]
   foreach part $legs1 {
      set L [list]
      foreach l $part {
         lappend L [lindex $EL1 $l]
      }
      lappend site1 $L
   }
   set L [list]
   foreach v $VL2 {lappend L [lindex $VL $v]}
   set site2 [list $L]
   foreach part $legs2 {
      set L [list]
      foreach l $part {
         lappend L [lindex $EL2 $l]
      }
      lappend site2 $L
   }
   return [list $NW $site1 $site2]
}
%   \end{tcl}
% \end{proc}
% 
% 
% Because the ambiguiity network grows, it becomes necessary to prevent 
% it from groing cycles. To that end, the procedure also keeps maintains 
% the partial order relation on the set of vertices that is induced by 
% the edges: \(u \leqslant v\) if \(u \leftarrow v\). This relation 
% is encoded via the list of up-sets (or principal filters, if you 
% prefer that terminology); there is a list |UpsetL| which is indexed 
% by vertex number and element $u$ is the list of those vertices $v$ 
% which satisfy \(u \leqslant v\), sorted in ascending integer order. 
% The |-sorted| option of |lsearch| is used when searching for a 
% particular element in this list.
%   
% \begin{proc}{ambiguities,extend_order}
%   The |ambiguities,extend_order| procedure is a helper for 
%   |ambiguities| that extends the current partial order of vertices 
%   to the transitive closure of its union with the pair $(u,v)$, i.e., 
%   \(u \leqslant v\). The call syntax is
%   \begin{quote}
%     |network::ambiguities,extend_order| \word{u} \word{v}
%   \end{quote}
%   but there is no particular return value; it works by modifying 
%   the list |UpsetL| in the local context of its caller.
%   \begin{tcl}
proc network::ambiguities,extend_order {u v} {
   upvar 1 UpsetL U
   for {set n 0} {$n < [llength $U]} {incr n} {
      if {[lsearch -sorted -integer [lindex $U $n] $u] >= 0} then {
         lset U $n [lsort -unique -integer [
            concat [lindex $U $n] [lindex $U $v]
         ]]
      }
   }
}
%   \end{tcl}
% \end{proc}
% 
% Like the component networks, the ambiguities have numeric vertex 
% types, but with an extra twist. The vertex types are actually pairs, 
% where the first element is a numeric vertex type and the second 
% element is a flag integer. It is nonzero |&1| if the vertex is not 
% matched with a regular network $1$ vertex and nonzero |&2| if the 
% vertex is not matched with a regular network $2$ vertex. This is 
% used to determine whether a type |0| vertex can be mapped to this 
% vertex.
% 
% \begin{proc}{ambiguities,monovertex}
%   The |ambiguities,monovertex| procedure is a helper for |ambiguities| 
%   that adds a vertex which only comes from one network to the 
%   ambiguity. It also adds any edges incident to this vertex which 
%   have both endpoints known.
%   
%   The syntax is
%   \begin{quote}
%     |network::ambiguities,monovertex| \word{component} \word{v}
%   \end{quote}
%   where \word{v} is the number of the vertex to add and 
%   \word{component} is |1| or |2| depending on whether this vertex 
%   comes from |NW1| or |NW2|. The procedure may modify the variables 
%   |V|, |E|, |VL1|, |VL2|, |EL1|, |EL2|, and |UpsetL| in the local 
%   context of its caller, and in addition it accesses |NW1| or 
%   |NW2|. The return value is |1| if the vertex and edges could be 
%   added, and |0| otherwise (when the ambiguity has grown a cycle).
%   
%   \begin{tcl}
proc network::ambiguities,monovertex {nwnum vx} {
   upvar 1 V V E E NW$nwnum NW VL$nwnum VL EL$nwnum EL UpsetL UpsetL
   set v [llength $V]
   set U [list]
   set type [lindex $NW 0 $vx 0]
   lappend U [list $type [expr {$type>0 ? 3-$nwnum : 3}]]
   set L [list]
   foreach ex [lindex $NW 0 $vx 1] {lappend L -1}
   lappend U $L {}
   lappend V $U
   lappend UpsetL [list $v]
   lset VL $vx $v
%   \end{tcl}
%   Now the vertex exists, but it is completely isolated. It remains 
%   to examine its edges. Edges are copied into the ambiguity if 
%   both their endpoints are present in the ambiguity.
%   
%   It should be observed that none of the edges inserted by the loop 
%   below can exist in the other network, since the vertex $v$ only 
%   exists in one network. There is a slight chance that $v$ will later 
%   become identified with a cap from the other network, but that can 
%   only happen because of joining of legs, and caps adjacent to 
%   $v_x$ should not yet have been assigned when this procedure is 
%   used.
%   \begin{tcl}
   set n -1
   foreach ex [lindex $NW 0 $vx 1] {
      incr n
      set vxa [lindex $NW 1 $ex 0]
      set va [lindex $VL $vxa]
      set vxb [lindex $NW 1 $ex 1]
      set vb [lindex $VL $vxb]
      if {$va < 0 || $vb < 0} then {continue}
      set e [llength $E]
      lset EL $ex $e
      lappend E [list $va $vb {}]
      lset V $va 1 [lsearch -integer [lindex $NW 0 $vxa 1] $ex] $e
      lset V $vb 1 [lsearch -integer [lindex $NW 0 $vxb 1] $ex] $e
      if {[lsearch -sorted -integer [lindex $UpsetL $vb] $va] >=0}\
      then {return 0}
      ambiguities,extend_order $va $vb
   }
   return 1
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ambiguities,matchfrom}
%   The |ambiguities,matchfrom| procedure is a helper for |ambiguities| 
%   that seeks to identify one vertex in network $1$ with a vertex in 
%   network $2$ as a new vertex in the ambiguity, and then extends 
%   the ambiguity with the vertices and edges connected to the given 
%   that exist in both component networks. The syntax is
%   \begin{quote}
%     |network::ambiguities,matchfrom| \word{v1} \word{v2}
%   \end{quote}
%   and the procedure furthermore accesses the variables |V|, |E|, 
%   |NW1|, |NW2|, |VL1|, |VL2|, |EL1|, |EL2|, and |UpsetL| in the 
%   local context of its caller.
%   
%   The return value is |1| if the two networks matched each other 
%   and |0| if they did not. In the latter case, nothing is guaranteed 
%   about the values of the variables listed above.
%   
%   It is checked whether the vertex types are compatible, but not 
%   that the two given vertices are previously not assigned. 
%   
%   The implementation makes use of a vertex queue |VQ| and two edge 
%   queues |EQ| and |EQ2|. After a vertex has been added to the 
%   ambiguity, the edges incident to it are added to one of the two 
%   edge queues: |EQ| for edges that exist in both networks and |EQ2| 
%   for edges that only exist in one of them. Elements in |EQ| are 
%   processed may result in another vertex being added to the 
%   ambiguity, and thus also inserted into |VQ| for further 
%   processing. This goes on until |VQ| and |EQ| both are empty. Then 
%   the |EQ2| edges are processed as in the second half of 
%   |ambiguities,monovertex|. It should be observed that these are 
%   all flat lists, to simplify using |foreach|, so the queue elements 
%   are not themselves lists, but sublists of the queue.
%   
%   The |VQ| elements have the structure
%   \begin{quote}
%     \word{v} \word{v1} \word{v2}
%   \end{quote}
%   where \word{v} is the number of a vertex in the ambiguity to 
%   which vertex \word{v1} from network $1$ and vertex \word{v2} from 
%   network $2$ are mapped. The task that has been enqueued here is to 
%   look at the $v$ incidences that are |-1| and enqueue them 
%   appropriately.
%   
%   \begin{tcl}
proc network::ambiguities,matchfrom {v1 v2} {
   upvar 1 NW1 NW1 NW2 NW2 V V E E VL1 VL1 VL2 VL2 EL1 EL1 EL2 EL2\
     UpsetL UpsetL
   set v [llength $V]
   if {[lindex $NW1 0 $v1 0] > 0} then {
      set type [lindex $NW1 0 $v1 0]
      if {[lindex $NW2 0 $v2 0] == $type} then {
         set type [list $type 0]
      } elseif {[lindex $NW2 0 $v2 0] > 0} then {
         return 0
      } else {
         set type [list $type 2]
      }
      set deg [llength [lindex $NW1 0 $v1 1]]
   } else {
      set type [lindex $NW2 0 $v2 0]
      if {$type == 0} then {
         error "This shouldn't happen!"
      }
      set type [list $type 1]
      set deg [llength [lindex $NW2 0 $v2 1]]
   }
   lappend V [list $type [string repeat "-1 " $deg] {}]
   lset VL1 $v1 $v
   lset VL2 $v2 $v
   lappend UpsetL [list $v]
%   \end{tcl}
%   The |EQ| elements have the structure
%   \begin{quote}
%     \word{e1} \word{e2}
%   \end{quote}
%   The task enqueued here is to create the edge (if it does not 
%   exist---it could have been enqueued from two side), create any 
%   endpoint that does not already exist, and attach the end at both 
%   sides. It must also enqueue vertices it created.
%   \begin{tcl}
   set VQ [list $v $v1 $v2]
   set EQ2 [list]
   while {[llength $VQ]} {
      set EQ [list]
      foreach {v v1 v2} $VQ {
         switch -- [lindex $V $v 0 1] 0 {
            foreach e [lindex $V $v 1] e1 [lindex $NW1 0 $v1 1]\
              e2 [lindex $NW2 0 $v2 1] {
               if {$e == -1} then {lappend EQ $e1 $e2}
            }
         } 1 {
            foreach e [lindex $V $v 1] e2 [lindex $NW2 0 $v2 1] {
               if {$e == -1} then {lappend EQ2 2 $e2}
            }
         } 2 {
            foreach e [lindex $V $v 1] e1 [lindex $NW1 0 $v1 1] {
               if {$e == -1} then {lappend EQ2 1 $e1}
            }
         }
      }
%   \end{tcl}
%   An edge may not have been created for one network but not for the 
%   other.
%   \begin{tcl}
      set VQ [list]
      foreach {e1 e2} $EQ {
         if {[lindex $EL1 $e1] != [lindex $EL2 $e2]} then {
            return 0
         } elseif {[lindex $EL2 $e2] != -1} then {
            continue
         }
         set e [llength $E]
%   \end{tcl}
%   A vertex may only have been created for one network but not for the 
%   other if it is a cap in the other. The vertex type in the 
%   ambiguity must then be checked to see if this is allowed.
%   \begin{tcl}
         foreach i {0 1} X {a b} {
            set v1 [lindex $NW1 1 $e1 $i]
            set v2 [lindex $NW2 1 $e2 $i]
            set v [set v$X [lindex $VL1 $v1]]
            if {$v >= 0} then {
               set i$X [lsearch -integer [lindex $NW1 0 $v1 1] $e1]
               if {[lindex $VL2 $v2] == $v} then {continue}
               if {[lindex $VL2 $v2] >= 0} then {return 0}
               if {[lindex $NW2 0 $v2 0] != 0 ||\
                 ([lindex $V $v 0 1]&2) == 0} then {return 0}
               lset VL2 $v2 $v
            } elseif {[lindex $VL2 $v2] >= 0} then {
               set v [set v$X [lindex $VL2 $v2]]
               set i$X [lsearch -integer [lindex $NW2 0 $v2 1] $e2]
               if {[lindex $NW1 0 $v1 0] != 0 ||\
                 ([lindex $V $v 0 1]&1) == 0} then {return 0}
               lset VL1 $v1 $v
            } else {
%   \end{tcl}
%   This is the case where a vertex is created. There are plenty of 
%   subcases depending on the vertex type.
%   \begin{tcl}
               set v [set v$X [llength $V]]
               lset VL1 $v1 $v
               lset VL2 $v2 $v
               set type [lindex $NW1 0 $v1 0]
               if {$type > 0} then {
                  if {[lindex $NW2 0 $v2 0] == $type} then {
                     set type [list $type 0]
                  } elseif {[lindex $NW2 0 $v2 0] > 0} then {
                     return 0
                  } else {
                     set type [list $type 2]
                  }
                  set deg [llength [lindex $NW1 0 $v1 1]]
                  set i$X [lsearch -integer [lindex $NW1 0 $v1 1] $e1]
               } else {
                  set type [lindex $NW2 0 $v2 0]
                  if {$type > 0} then {
                     set type [list $type 1]
                     set deg [llength [lindex $NW2 0 $v2 1]]
                     set i$X [lsearch -integer [lindex $NW2 0 $v2 1] $e2]
                  } else {
                     set type [list 0 3]
                     set deg 1
                     set i$X 0
                  }
               }
               lappend V [list $type [string repeat "-1 " $deg] {}]
               lappend UpsetL [list $v]
               lappend VQ $v $v1 $v2
            }
         }
%   \end{tcl}
%   What remains to do for this edge is merely to create it and attach 
%   it to the endpoints.
%   \begin{tcl}
         lappend E [list $va $vb {}]
         lset EL1 $e1 $e
         lset EL2 $e2 $e
         lset V $va 1 $ia $e
         lset V $vb 1 $ib $e
         if {[lsearch -integer -sorted [lindex $UpsetL $vb] $va]>=0}\
         then {return 0}
         ambiguities,extend_order $va $vb
      }
   }
%   \end{tcl}
%   The |EQ2| elements have the structure
%   \begin{quote}
%     \word{network number} \word{ex}
%   \end{quote}
%   The task enqueued here is to check if both ends of the said edge 
%   exists in the ambiguity and if so insert also the edge.
%   \begin{tcl}
   foreach {nwnum ex} $EQ2 {
      if {$nwnum == 1} then {
         if {[lindex $EL1 $ex] != -1} then {continue}
         set v1a [lindex $NW1 1 $ex 0]
         set va [lindex $VL1 $v1a]
         set v1b [lindex $NW1 1 $ex 1]
         set vb [lindex $VL1 $v1b]
         if {$va < 0 || $vb < 0} then {continue}
         set e [llength $E]
         lset EL1 $ex $e
         lset V $va 1 [lsearch -integer [lindex $NW1 0 $v1a 1] $ex] $e
         lset V $vb 1 [lsearch -integer [lindex $NW1 0 $v1b 1] $ex] $e
      } else {
         if {[lindex $EL2 $ex] != -1} then {continue}
         set v2a [lindex $NW2 1 $ex 0]
         set va [lindex $VL2 $v2a]
         set v2b [lindex $NW2 1 $ex 1]
         set vb [lindex $VL2 $v2b]
         if {$va < 0 || $vb < 0} then {continue}
         set e [llength $E]
         lset EL2 $ex $e
         lset V $va 1 [lsearch -integer [lindex $NW2 0 $v2a 1] $ex] $e
         lset V $vb 1 [lsearch -integer [lindex $NW2 0 $v2b 1] $ex] $e
      }
      lappend E [list $va $vb {}]
      if {[lsearch -sorted -integer [lindex $UpsetL $vb] $va] >=0}\
      then {return 0}
      ambiguities,extend_order $va $vb
   }
   return 1
   
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ambiguities,joinlegs}
%   The |ambiguities,joinlegs| procedure is a helper for |ambiguities| 
%   that seeks to identify one leg in network $1$ with a leg of the 
%   other kind in network $2$ as an edge in the ambiguity that connects 
%   two existing vertices. The syntax is
%   \begin{quote}
%     |network::ambiguities,joinlegs| \word{e1} \word{e2} \word{dir}
%   \end{quote}
%   where \word{e1} is the edge number in network $1$, \word{e2} is the 
%   edge number in network $2$, and \word{dir} is |1| if the network $1$ 
%   edge is the input end of the edge.
%   
%   The procedure accesses the variables |V|, |E|, |NW1|, |NW2|, |VL1|, 
%   |VL2|, |EL1|, |EL2|, and |UpsetL| in the local context of its caller.
%   The return value is |1| if the two networks could be joined and |0| 
%   if they did not. In the latter case, nothing is guaranteed about 
%   the values of the variables listed above.
%   
%   \begin{tcl}
proc network::ambiguities,joinlegs {e1 e2 dir} {
   upvar 1 NW1 NW1 NW2 NW2 V V E E VL1 VL1 VL2 VL2 EL1 EL1 EL2 EL2\
     UpsetL UpsetL
   if {[lindex $EL1 $e1] != -1} then {return 0}
   if {[lindex $EL2 $e2] != -1} then {return 0}
   if {$dir} then {
      set v1 [lindex $NW1 1 $e1 0]
      set va [lindex $VL1 $v1]
      if {$va<0 || [lindex $V $va 0 1] != 2} then {return 0}
      set ia [lsearch -integer [lindex $NW1 0 $v1 1] $e1]
      set v2 [lindex $NW2 1 $e2 1]
      set vb [lindex $VL2 $v2]
      if {$vb<0 || [lindex $V $vb 0 1] != 1} then {return 0}
      set ib [lsearch -integer [lindex $NW2 0 $v2 1] $e2]
   } else {
      set v2 [lindex $NW2 1 $e2 0]
      set va [lindex $VL2 $v2]
      if {$va<0 || [lindex $V $va 0 1] != 1} then {return 0}
      set ia [lsearch -integer [lindex $NW2 0 $v2 1] $e2]
      set v1 [lindex $NW1 1 $e1 1]
      set vb [lindex $VL1 $v1]
      if {$vb<0 || [lindex $V $vb 0 1] != 2} then {return 0}
      set ib [lsearch -integer [lindex $NW1 0 $v1 1] $e1]
   }
   if {[lsearch -integer -sorted [lindex $UpsetL $vb] $va]>=0}\
   then {return 0}
   ambiguities,extend_order $va $vb
   set e [llength $E]
   lappend E [list $va $vb {}]
   lset EL1 $e1 $e
   lset EL2 $e2 $e
   lset V $va 1 $ia $e
   lset V $vb 1 $ib $e
   return 1
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ambiguities,monoleg}
%   The |ambiguities,monoleg| procedure is a helper for |ambiguities| 
%   that adds a leg and its cap vertex from one network to the ambiguity. 
%   The syntax is
%   \begin{quote}
%     |network::ambiguities,monoleg| \word{component} \word{e}
%   \end{quote}
%   where \word{component} is the network number and \word{e} is the 
%   edge number of the leg in that network. It is assumed that this edge 
%   has not been mapped. There is no particular return value.
%   
%   The procedure may modify the variables |V|, |E|, |VL1|, |VL2|, 
%   |EL1|, and |EL2| in the local context of its caller, and 
%   in addition it accesses |NW1| or |NW2|. It does not update 
%   |UpsetL|, since one end of the edge is at a leaf.
%   
%   \begin{tcl}
proc network::ambiguities,monoleg {nwnum ex} {
   upvar 1 V V E E NW$nwnum NW VL$nwnum VL EL$nwnum EL UpsetL UpsetL
   set e [llength $E]
   set vxa [lindex $NW 1 $ex 0]
   set va [lindex $VL $vxa]
   if {$va == -1} then {
      set va [llength $V]
      lappend V [list {0 3} -1 {}]
      lset VL $vxa $va
      set ia 0
   } else {
      set ia [lsearch -integer [lindex $NW 0 $vxa 1] $ex]
   }
   set vxb [lindex $NW 1 $ex 1]
   set vb [lindex $VL $vxb]
   if {$vb == -1} then {
      set vb [llength $V]
      lappend V [list {0 3} -1 {}]
      lset VL $vxb $vb
      set ib 0
   } else {
      set ib [lsearch -integer [lindex $NW 0 $vxb 1] $ex]
   }
   lappend E [list $va $vb {}]
   lset EL $ex $e
   lset V $va 1 $ia $e
   lset V $vb 1 $ib $e
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ambiguities}
%   What happens in |ambiguities| is mainly that a search tree is 
%   traversed. The current position in this tree is defined by the 
%   current state of the ambiguity, which is stored in the variables 
%   |V|, |E|, |VL1|, |VL2|, |EL1|, |EL2|, and |UpsetL|. Besides this 
%   position, the search only needs to keep track of which branches 
%   remain to be visited. When one branch is being examined, the root 
%   position of that branch and the subsequent branches are pushed onto 
%   a stack, so that the search can continue when the current branch has 
%   been completed.
%   
%   The |branch| formats are:
%   \begin{description}
%   \item[\texttt{vertex} \word{v1} \word{v2-list}]
%     Identify \word{v1} in network $1$ with the vertices in the 
%     \word{v2-list} (one for each branch), and also a branch where 
%     the \word{v1} is not identified with another vertex.
%   \item[\texttt{outleg} \word{l1} \word{e2-list}]
%     Identify the output leg with index \word{l1} in network $1$ with 
%     the edges in the \word{e2-list} (one for each branch), and also 
%     a branch where the leg is not identified with another edge.
%   \item[\texttt{inleg} \word{l1} \word{e2-list}]
%     Identify the input leg with index \word{l1} in network $1$ with 
%     the edges in the \word{e2-list} (one for each branch), and also 
%     a branch where the leg is not identified with another edge.
%   \item[\texttt{pick\_out} \word{$l_1$}]
%     Find an unprocessed output leg in network $1$ with index 
%     \(\geqslant l_1\) and generate an |outleg| entry for that.
%   \item[\texttt{pick\_in} \word{$l_1$}]
%     Find an unprocessed input leg in network $1$ with index 
%     \(\geqslant l_1\) and generate an |inleg| entry for that.
%   \end{description}
%   
%   
%   \begin{tcl}
proc network::ambiguities {NW1 NW2} {
   set n1 [llength [lindex $NW1 0]]
   set n2 [llength [lindex $NW2 0]]
   set nextnumtype 1
   ambiguities,caplegs NW1
   ambiguities,caplegs NW2
   while {$nextnumtype > 1} {
      incr nextnumtype -1
      set Hastype($nextnumtype) [list]
   }
   set n 0
   foreach v [lindex $NW2 0] {
      lappend Hastype([lindex $v 0]) $n
      incr n
   }
   set V [list]
   set E [list]
   set VL1 [list]; foreach v [lindex $NW1 0] {lappend VL1 -1}
   set VL2 [list]; foreach v [lindex $NW2 0] {lappend VL2 -1}
   set EL1 [list]; foreach e [lindex $NW1 1] {lappend EL1 -1}
   set EL2 [list]; foreach e [lindex $NW2 1] {lappend EL2 -1}
   set UpsetL [list]
   set res [list]
   set branch [list vertex 0 $Hastype([lindex $NW1 0 0 0])]
   set Stack [list [list $branch $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]]
   while {[llength $Stack]} {
      foreach {branch V E VL1 VL2 EL1 EL2 UpsetL} [lindex $Stack end]\
        break
      set Stack [lrange $Stack [set Stack 0] end-1]
      if {[lindex $branch 0] eq "vertex"} then {
         set v1 [lindex $branch 1]
         if {[llength [lindex $branch 2]]} then {
            lappend Stack [list [
               list vertex $v1 [lrange [lindex $branch 2] 1 end]
            ] $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]
            set v2 [lindex $branch 2 0]
            if {[lindex $VL2 $v2] != -1} then {continue}
            if {![ambiguities,matchfrom $v1 $v2]}\
            then {continue}
         } else {
            if {![ambiguities,monovertex 1 $v1]}\
            then {continue}
         }
         while {$v1<$n1 && [lindex $VL1 $v1]>=0} {incr v1}
         if {$v1<$n1} then {
            set L [list]
            foreach v2 $Hastype([lindex $NW1 0 $v1 0]) {
               if {[lindex $VL2 $v2] == -1} then {lappend L $v2}
            }
            set branch [list vertex $v1 $L]
            lappend Stack [list $branch $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]
            continue
         }
         set has_overlap 0
         for {set v2 0} {$v2<$n2} {incr v2} {
            if {[lindex $VL2 $v2] != -1} then {
               set has_overlap 1
               continue
            }
            if {![ambiguities,monovertex 2 $v2]} then {
               set v2 -1
               break
            }
         }
         if {$v2==-1 || !$has_overlap} then {continue}
         set branch [list pick_out 0]
      }
      if {[lindex $branch 0] eq "pick_out"} then {
         set l1 [lindex $branch 1]
         set branch [list "pick_in" 0]
         for {} {$l1 < [llength [lindex $NW1 2 0]]} {incr l1} {
            if {[lindex $EL1 [lindex $NW1 2 0 $l1]] != -1}\
            then {continue}
            set L [list]
            foreach e2 [lindex $NW2 2 1] {
               if {[lindex $EL2 $e2] == -1} then {lappend L $e2}
            }
            set branch [list outleg $l1 $L]
            break
         }
      }
      if {[lindex $branch 0] eq "outleg"} then {
         set l1 [lindex $branch 1]
         if {[llength [lindex $branch 2]]} then {
            lappend Stack [list [
               list outleg $l1 [lrange [lindex $branch 2] 1 end]
            ] $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]
            set e2 [lindex $branch 2 0]
            if {![
               ambiguities,joinlegs [lindex $NW1 2 0 $l1] $e2 0
            ]} then {continue}
         } else {
            ambiguities,monoleg 1 [lindex $NW1 2 0 $l1]
         }
         set branch [list pick_out [expr {$l1+1}]]
         lappend Stack [list $branch $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]
         continue
      }
      if {[lindex $branch 0] eq "pick_in"} then {
         set l1 [lindex $branch 1]
         set branch [list complete]
         for {} {$l1 < [llength [lindex $NW1 2 1]]} {incr l1} {
            if {[lindex $EL1 [lindex $NW1 2 1 $l1]] != -1}\
            then {continue}
            set L [list]
            foreach e2 [lindex $NW2 2 0] {
               if {[lindex $EL2 $e2] == -1} then {lappend L $e2}
            }
            set branch [list inleg $l1 $L]
            break
         }
      }
      if {[lindex $branch 0] eq "inleg"} then {
         set l1 [lindex $branch 1]
         if {[llength [lindex $branch 2]]} then {
            lappend Stack [list [
               list inleg $l1 [lrange [lindex $branch 2] 1 end]
            ] $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]
            set e2 [lindex $branch 2 0]
            if {![
               ambiguities,joinlegs [lindex $NW1 2 1 $l1] $e2 1
            ]} then {continue}
         } else {
            ambiguities,monoleg 1 [lindex $NW1 2 1 $l1]
         }
         set branch [list pick_in [expr {$l1+1}]]
         lappend Stack [list $branch $V $E $VL1 $VL2 $EL1 $EL2 $UpsetL]
         continue
      }  
      foreach e2 [concat [lindex $NW2 2 0] [lindex $NW2 2 1]] {
         if {[lindex $EL2 $e2] == -1} then {
            ambiguities,monoleg 2 $e2
         }
      }
      lappend res [ambiguities,normalise $V $E [lreplace $VL1 $n1 end]\
        [lreplace $VL2 $n2 end] $EL1 $EL2 [lrange [lindex $NW1 2] 0 1]\
        [lrange [lindex $NW2 2] 0 1]]
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% 
% 
% \section{Vertex types}
% \label{Sec:VertexTypes}
% 
% The vertex \word{decoration}s are generally seen as implying things 
% about the edges it is incident to---information that is needed by many 
% of the procedures below. The usual way of doing this is to provide an 
% array, which is indexed by \word{decoration}, containing the 
% information. The entries in that array are lists with the structure
% \begin{quote}
%   \word{I/O-list} \word{graphical information}
%   \word{other}\regstar
% \end{quote}
% where the \word{graphical information} is described in 
% Section~\ref{Sec:Grafik} below and \word{other} is reserved for 
% future additions. The \word{I/O-list} specifies which positions in the 
% \word{incidences} list of this kind of vertex are inputs and which are 
% outputs. It has the same length as an \word{incidences} list, and the 
% elements are either |1| (if it is an input) or |0| (if it is an 
% output).
% 
% The \word{graphical information} also contains similar lists of 
% incidences from which this input\slash output state could be derived, 
% but it is cleaner to keep the two separated.
% 
% 
% \begin{proc}{construct}
%   The |construct| procedure constructs a network from a table of 
%   vertex types and a list of components. The syntax is
%   \begin{quote}
%     |network::construct| \word{type-array} \word{component}\regplus
%   \end{quote}
%   where \word{type-array} is the name of an array in the local context 
%   of the caller that is indexed by vertex decorations and contain 
%   descriptions as shown above. The return value is a network, 
%   constructed from the \word{component}s arguments.
%   
%   The network is constructed from input to output, from first leg to 
%   last. If a \word{component} is one of the vertex decorations 
%   defined in the type array then a vertex with that type is inserted 
%   into the network at the rightmost position in the current level, 
%   using up its number of inputs and contributing its number of outputs. 
%   Besides that, the following characters are recognised as special 
%   directives
%   \begin{description}
%     \item[\texttt{.} (period)]
%       The next input passes through the current level without being 
%       attached to anything in it.
%     \item[carriage return]
%       Completes the current level and starts a new one. Any remaining 
%       inputs are transferred to the next level.
%     \item[line feed]
%       Same as carriage return.
%     \item[\texttt{x}]
%       The \emph{second next} input is made the next output of the 
%       current level. The effect of this is that the next and second 
%       next inputs are crossed, but what was the next input remains 
%       available as the next input in the current level.
%   \end{description}
%   
%   \begin{tcl}
proc network::construct {typearrname args} {
   upvar 1 $typearrname Type
   set V [list]
   set E [list]
   set NWin [list]
   set in [list]
   set out [list]
   set i 0
   foreach t $args {
      if {[info exists Type($t)]} then {
%   \end{tcl}
%   Need to attach a new vertex. Begin with the edges: construct the 
%   incidence list in |L|.
%   \begin{tcl}
         set vnum [llength $V]
         set L [list]
         foreach d [lindex $Type($t) 0] {
            if {$d} then {
%   \end{tcl}
%   This is an input edge. If there were no more input edges then make 
%   a new leg. Then attach it to the vertex.
%   \begin{tcl}
               if {$i >= [llength $in]} then {
                  lappend NWin [llength $E]
                  lappend in [llength $E]
                  lappend E [list {} [expr {-[llength $NWin]}] {}]
               }
               lappend L [lindex $in $i]
               lset E [lindex $in $i] 0 $vnum
               incr i
            } else {
%   \end{tcl}
%   This is an output edge. Make a new edge, append it to the out list, 
%   and attach it to the vertex. (Although this is in the opposite 
%   order.)
%   \begin{tcl}
               lappend L [llength $E]
               lappend out [llength $E]
               lappend E [list {} $vnum {}]
            }
         }
%   \end{tcl}
%   Complete the new vertex.
%   \begin{tcl}
         lappend V [list $t $L {}]
      } elseif {$t eq "."} then {
%   \end{tcl}
%   Take the next input (create one if necessary) and move it to the 
%   next level.
%   \begin{tcl}
         if {$i >= [llength $in]} then {
            lappend NWin [llength $E]
            lappend in [llength $E]
            lappend E [list {} [expr {-[llength $NWin]}] {}]
         }
         lappend out [lindex $in $i]
         incr i
      } elseif {$t eq "x" || $t eq "X"} then {
%   \end{tcl}
%   Take the second next input (create one if necessary), swap it with 
%   the current, and move that second next input to the next level.
%   \begin{tcl}
         while {$i+1 >= [llength $in]} {
            lappend NWin [llength $E]
            lappend in [llength $E]
            lappend E [list {} [expr {-[llength $NWin]}] {}]
         }
         set n [lindex $in $i]
         incr i
         lappend out [lindex $in $i]
         lset in $i $n
      } elseif {$t eq "\r" || $t eq "\n"} then {
%   \end{tcl}
%   Move all remaining inputs to |out|, and begin the next level by 
%   making that the new |in|.
%   \begin{tcl}
         while {$i < [llength $in]} {
            lappend out [lindex $in $i]
            incr i
         }
         set in $out
         set i 0
         set out [list]
      } else {
         error "Unknown vertex type '$t'."
      }
   }
%   \end{tcl}
%   Complete the network.
%   \begin{tcl}
   while {$i < [llength $in]} {
      lappend out [lindex $in $i]
      incr i
   }
   set i -1
   foreach n $out {
      lset E $n 0 $i
      incr i -1
   }
   return [list $V $E [list $out $NWin] {}]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{initialise_rotation}
%   The |initialise_rotation| procedure utilises an assumption that was 
%   implicit in |construct|---namely that inputs are listed 
%   left-to-right and that outputs are too---to construct an array of 
%   cyclic edge rotations for each vertex type. The syntax is
%   \begin{quote}
%     |network::initialise_rotation| \word{rotation-array-name}
%       \word{type-array-name}
%   \end{quote}
%   where both arguments are names of arrays in the calling context. 
%   \changes{alpha}{2005/11/05}{Added procedure. (LH)}
% \end{proc}
% 
% 
% \section{Graphical network data structure}
% \label{Sec:Grafik}
% 
% Graphical extensions to the network data structure describe how the 
% network should be drawn on a Tk |canvas| and other places.
% 
% \subsection{Canvas graphics}
% 
% The \emph{appearence} of a vertex is determined by its decoration, 
% using information in a vertex-type array. The \emph{position} can for 
% longer storage be kept in the \word{info} dictionary of the vertex, 
% but during graphically heavy parts of the program it may also be kept 
% in the \word{other}s to be more readily accessible. The coordinate 
% system used internally is the Tk |canvas| coordinate system, which 
% means the default unit is screen pixels and $y$ coordinates increase 
% going downwards. Canvas coordinates with units are not supported, due 
% to the arithmetic difficulties this would produce.
% 
% In more detail, a vertex graphically consists of one or several canvas 
% items. The appearence of a vertex is specified through a list
% \begin{quote}
%   \begin{regblock}[\regplus]\word{item-type} 
%   \word{coordinates-command} \word{options}\end{regblock}
% \end{quote}
% where \word{item-type} is a canvas item type that will be used for 
% this vertex, \word{options} is a list of item options to apply to that 
% item, and \word{coordinates-command} is a command prefix that, when 
% given the position of the vertex, returns the list of coordinates 
% needed to define it as a canvas item. More precisely the syntax is
% \begin{quote}
%   \meta{coordinates-command} \word{x} \word{y}
% \end{quote}
% where the \meta{coordinates-command} of course may be more than one 
% word. This command is furthermore evaluated in the |network::shape| 
% namespace, which makes it possible to omit namespace qualifiers for 
% commands in that namespace.
% \begin{tcl}
namespace eval network::shape {}
% \end{tcl}
% 
% \begin{proc}[network::shape]{offsets}
%   The |offsets| procedure has the syntax
%   \begin{quote}
%     |network::shape::offsets| \word{offset-pair}\regstar\ ^^A
%     \word{x} \word{y}
%   \end{quote}
%   It returns a list of twice as many numbers as there are 
%   offset-pairs, where each pair of numbers is a sum of $(x,y)$ and 
%   an offset-pair.
%   \begin{tcl}
proc network::shape::square {args} {
   set x [lindex $args end-1]
   set y [lindex $args end]
   set res {}
   foreach pair [lrange $args 0 end-2] {
      lappend res [expr {$x + [lindex $pair 0]}]\
        [expr {$y + [lindex $pair 1]}]
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}[network::shape]{square}
%   The |square| procedure has the syntax
%   \begin{quote}
%     |network::shape::square| \word{half-side} \word{x} \word{y}
%   \end{quote}
%   It returns a list of four numbers, giving the coordinates of two 
%   diagonally opposed corners of a square with center at $(x,y)$ and 
%   whose side is twice the \word{half-side}.
%   \begin{tcl}
proc network::shape::square {r x y} {
   list [expr {$x - $r}] [expr {$y - $r}] [expr {$x + $r}]\
     [expr {$y + $r}]
}
%</pkg>
%   \end{tcl}
% \end{proc}
% 
% There is however more to the \word{graphical information} about a 
% vertex type than just the appearence of the vertex as such. The full 
% structure is
% \begin{quote}
%   \word{vertex-appearence} \word{incidence-offsets}
% \end{quote}
% where the \word{incidence-offsets} is a list of pairs that specify 
% the offsets from the vertex position to the point where an edge is 
% attached to it. That attachment point will typically be an endpoint 
% of the |line| object that represents the edge. 
% 
% \begin{arrayvar}[]{Hopf_types}
%   As an example, the following array defines six vertex types |m|, 
%   |unit|, |Delta|, |epsilon|, |S|, and |id| that correspond to the 
%   multiplication, unit, coproduct, counit, antipode, and identity 
%   endomorphism respectively of a Hopf algebra. All but the antipode 
%   vertices are circles, with radius 8.
%   
%   \begin{tcl}
%<*Hopf>
array set Hopf_types {
   m { {0 1 1} {
      {oval {square 8} {}} 
      {{0 8} {-5.657 -5.657} {5.657 -5.657}}
   }}
   unit { {0} {
      {oval {square 8} {}} 
      {{0 8}}
   }}
   Delta { {0 0 1} {
      {oval {square 8} {}} 
      {{-5.657 5.657} {5.657 5.657} {0 -8}}
   }}
   epsilon { {1} {
      {oval {square 8} {}} 
      {{0 -8}}
   }}
   S { {0 1} {
      {rectangle {square 8} {}} 
      {{0 8} {0 -8}}
   }}
   id { {0 1} {
      {oval {square 8} {}} 
      {{0 8} {0 -8}}
   }}
%   \end{tcl}
%   In 2007-02-05, I added a |twist| type to experiment with algebras 
%   where this is nontrivial. This has arity and coarity both equal 
%   to $2$.
%   \begin{tcl}
   twist { {0 0 1 1} {
      {oval {square 8} {}  line {square 5.657} {} \
        line {offsets {5.657 -5.657} {-5.657 5.657}} {}} 
      {{-5.657 5.657} {5.657 5.657} {-5.657 -5.657} {5.657 -5.657}}
   }}
}
%</Hopf>
%   \end{tcl}
% \end{arrayvar}
% 
% \begin{arrayvar}[]{Hom_types}
%   The next example is a set of vertex types hastily drawn up on 
%   2006-10-14 to match the operations in a Hom-algebra. |m|, |id|, 
%   and |unit| are as above. |S| here is going to be the homomorphism 
%   giving that structure its name, and |Sinv| is going to be the 
%   inverse of |S|.
%   \begin{tcl}
%<*HomAlg>
array set HomAlg_types {
   m { {0 1 1} {
      {oval {square 8} {}} 
      {{0 8} {-5.657 -5.657} {5.657 -5.657}}
   }}
   unit { {0} {
      {oval {square 8} {}} 
      {{0 8}}
   }}
   S { {0 1} {
      {rectangle {square 8} {}} 
      {{0 8} {0 -8}}
   }}
   Sinv { {0 1} {
      {rectangle {square 8} {} oval {square 7} {}} 
      {{0 8} {0 -8}}
   }}
   id { {0 1} {
      {oval {square 8} {}} 
      {{0 8} {0 -8}}
   }}
}
%</HomAlg>
%   \end{tcl}
% \end{arrayvar}
% 
% \begin{arrayvar}[]{Frobenius_types}
%   As another example, the following array defines seven vertex types 
%   |m|, |unit|, |Delta|, |epsilon|, |id|, |pair|, and |copair| that 
%   correspond to operations in a Frobenius algebra. The first five 
%   are the same as in a Hopf algebra, and do suffice for defining a 
%   Frobenius algebra, but other axiom systems make use of one of the 
%   latter instead. |copair| is a copairing---a map from the scalars 
%   to $\mathcal{A} \otimes \mathcal{A}$---whereas |pair| dually is a 
%   bilinear form. All the vertices are circles, with radius 8.
%   \changes{alpha}{2005/10/28}{Added Frobenius vertex types. (LH)}
%   \begin{tcl}
%<*Frobenius>
array set Frobenius_types {
   m { {0 1 1} {
      {oval {square 8} {}} 
      {{0 8} {-5.657 -5.657} {5.657 -5.657}}
   }}
   unit { {0} {
      {oval {square 8} {}} 
      {{0 8}}
   }}
   Delta { {0 0 1} {
      {oval {square 8} {}} 
      {{-5.657 5.657} {5.657 5.657} {0 -8}}
   }}
   epsilon { {1} {
      {oval {square 8} {}} 
      {{0 -8}}
   }}
   id { {0 1} {
      {oval {square 8} {}} 
      {{0 8} {0 -8}}
   }}
   pair { {1 1} {
      {oval {square 8} {}} 
      {{-5.657 -5.657} {5.657 -5.657}}
   }}
   copair { {0 0} {
      {oval {square 8} {}} 
      {{-5.657 5.657} {5.657 5.657}}
   }}
}
%</Frobenius>
%   \end{tcl}
% \end{arrayvar}
% 
% Edges are generally drawn as |-smooth true| line items (typically with 
% four defining points, i.e., two segments, but that is not assumed much 
% by the routines that actually draw things). Edges augmented with 
% graphical representations have the structure
% \begin{quote}
%   \word{out-vertex} \word{in-vertex} \word{info} \word{coordinates} 
%   \word{item} \word{auxiliary data}\regopt
% \end{quote}
% where \word{coordinates} is the list of coordinates for the line item 
% representing this edge and \word{item} is either empty or the item 
% number of that line item. The \word{auxiliary data} is, if it is 
% present, a list of data (typically coordinates and the like) that is 
% used to facilitate some calculations that will be performed 
% repeatedly. Procedures making use of this information should be able 
% to recreate it if it is missing. The first element of the 
% \word{auxiliary data} should be a name identifying the data, so that 
% different contents here are not confused with each other.
% 
% \word{legs} lists augmented with graphical representations have the 
% structure
% \begin{quote}
%   \word{output-legs} \word{input-legs} \word{output-x} \word{input-x}
%   \word{output-y} \word{input-y} \word{output-items} \word{input-items}
% \end{quote}
% where \word{output-x} and \word{input-x} are lists of the same lengths 
% as \word{output-legs} and \word{input-legs} respectively, but 
% \word{output-y} and \word{input-y} are single numbers. The idea is 
% that all output and input legs respectively should be ``cut off'' at 
% the same $y$ coordinate, whereas they of course must have different $x$ 
% coordinates. The \word{output-items} and \word{input-items} are either 
% empty or lists of the item numbers of the |text| items representing 
% the legs.
% 
% 
% Vertices augmented with graphical representations similarly have the 
% structure
% \begin{quote}
%   \word{decoration} \word{incidence} \word{info} \word{coordinates} 
%   \word{items}
% \end{quote}
% where \word{coordinates} is the list $(x,y)$ for this vertex 
% (\emph{not} the actual canvas item coordinates) and \word{items} is 
% the list of the numbers of the canvas items that represent this vertex. 
% The coordinates can also be stored in the \word{info} dictionary of 
% the vertex---with the $x$ coordinate in the 
% \describestring[entry]{x}|x| entry and the $y$ coordinate in the 
% \describestring[entry]{y}|y| entry---but that is (for efficiency reasons) 
% mostly ignored by the graphical network procedures.
% 
% Besides the vertex \word{info} dictionaries, some graphical information 
% is also kept in the network \word{info} dictionary. The
% \describestring[entry]{bbox}|bbox| entry specifies a bounding box for 
% the network. It is a list
% \begin{quote}
%   \word{left} \word{top} \word{right} \word{bottom}
% \end{quote}
% giving the position of the sides of the bounding box. Related to this 
% is the \describestring[entry]{bboxmargin}|bboxmargin| entry, which 
% specifies the width of the margin to leave between the vertices and 
% the bounding box, measured from the centres of the vertices. 
% 
% Finally, if a network is drawn in a canvas then its fifth element 
% will be set to the name of that canvas---a piece of information that 
% is needed before one can make sense of the item numbers stored with 
% the vertices and edges. Thus the structure of a drawn network is
% \begin{quote}
%   \word{vertices} \word{edges} \word{legs} \word{info}
%   \word{canvas} \word{other}\regstar
% \end{quote}
% 
% \begin{tcl}
%<*pkg&graphics>
package require Tk
% \end{tcl}
% 
% \begin{proc}{drawit}
%   The |drawit| procedure draws a network on a canvas, by creating new 
%   items for all vertices and edges according to coordinates stored in 
%   the network and vertex type specifications. The syntax is
%   \begin{quote}
%     |network::drawit| \word{network-var} \word{type-arr} \word{canvas}
%   \end{quote}
%   where \word{canvas} is the canvas to work with, and \word{network-var} 
%   and \word{type-arr} are names of variables in the local context of 
%   the caller. There is no particular return value, but the 
%   \word{network-var} will be modified to hold the numbers of the items 
%   that were created and the name of the \word{canvas} on which they 
%   live.
%   
%   \begin{tcl}
proc network::drawit {NWvar TAvar canvas} {
   upvar 1 $NWvar NW $TAvar TA
   if {[llength $NW] >= 5} then {
      lset NW 4 $canvas
   } else {
      lappend NW $canvas
   }
   set n 0
   foreach v [lindex $NW 0] {
      set L [list]
      foreach {type coordfunc options}\
        [lindex $TA([lindex $v 0]) 1 0] {
         set call [list $canvas create $type]
         lappend call [namespace eval shape $coordfunc [lindex $v 3]]
         lappend L [eval $call $options]
      }
      lset NW 0 $n 4 $L
      incr n
   }
   set L [list]
   set n 0
   foreach x [lindex $NW 2 2] {
      lappend L [
        $canvas create text $x [lindex $NW 2 4] -text $n -anchor n\
          -justify center
      ]
      incr n
   }
   lset NW 2 6 $L
   set L [list]
   set n 0
   foreach x [lindex $NW 2 3] {
      lappend L [
        $canvas create text $x [lindex $NW 2 5] -text $n -anchor s\
          -justify center
      ]
      incr n
   }
   lset NW 2 7 $L
   set n 0
   foreach e [lindex $NW 1] {
      lset NW 1 $n 4 [$canvas create line [lindex $e 3] -smooth 1]
      incr n
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{redrawit}
%   The |redrawit| procedure redraws a network that has previously been 
%   drawn on a canvas, by updating the coordinates of items stored in 
%   the network and vertex type specifications to match the edge,  
%   vertex, and leg coordinates stored there.
%   The syntax is similar to that of |drawit|, viz.
%   \begin{quote}
%     |network::redrawit| \word{network-var} \word{type-arr}
%   \end{quote}
%   but in this case the \word{network-var} is not modified.
%   
%   \begin{tcl}
proc network::redrawit {NWvar TAvar} {
   upvar 1 $NWvar NW $TAvar TA
   set canvas [lindex $NW 4]
   foreach v [lindex $NW 0] {
      foreach item [lindex $v 4] {type coordfunc options}\
        [lindex $TA([lindex $v 0]) 1 0] {
         $canvas coords $item\
           [namespace eval shape $coordfunc [lindex $v 3]]
      }
   }
   foreach l [lindex $NW 2 6] x [lindex $NW 2 2] {
      $canvas coords $l $x [lindex $NW 2 4]
   }
   foreach l [lindex $NW 2 7] x [lindex $NW 2 3] {
      $canvas coords $l $x [lindex $NW 2 5]
   }
   foreach e [lindex $NW 1] {
      $canvas coords [lindex $e 4] [lindex $e 3]
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{undrawit}
%   The |undrawit| procedure removes a network from a canvas, by 
%   deleting all the items for vertices and edges. The syntax is
%   \begin{quote}
%     |network::drawit| \word{network-var}
%   \end{quote}
%   where \word{network-var} is the name of the variable containing the 
%   network. This will be modified in that all the deleted canvas item 
%   names are removed.
%   \begin{tcl}
proc network::undrawit {NWvar} {
   upvar 1 $NWvar NW
   set canvas [lindex $NW 4]
   set n 0
   foreach v [lindex $NW 0] {
      foreach item [lindex $v 4] {$canvas delete $item}
      lset NW 0 $n 4 {}
      incr n
   }
   foreach l [lindex $NW 2 6] {$canvas delete $l}
   foreach l [lindex $NW 2 7] {$canvas delete $l}
   lset NW 2 6 {}
   lset NW 2 7 {}
   set n 0
   foreach e [lindex $NW 1] {
      $canvas delete [lindex $e 4]
      lset NW 1 $n 4 {}
      incr n
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{shownumbers}
%   The |shownumbers| procedure creates labels (|text| items) at all 
%   vertices and edges that show the numbers of these things. The syntax 
%   is
%   \begin{quote}
%     |network::shownumbers| \word{network-var}
%   \end{quote}
%   where \word{network-var} is the name in the local context of the 
%   caller of a variable in which is stored a network which has been 
%   drawn on some canvas. This creates some new items in this canvas, 
%   all of which will have the tag |number|.
%   \begin{tcl}
proc network::shownumbers {NWvar} {
   upvar 1 $NWvar NW
   for {set n 0} {$n < [llength [lindex $NW 0]]} {incr n} {
      [lindex $NW 4] create text [lindex $NW 0 $n 3 0]\
        [lindex $NW 0 $n 3 1] -tags number -justify center -text $n\
        -font {-size 10}
   }
   for {set n 0} {$n < [llength [lindex $NW 1]]} {incr n} {
      set x [expr {([lindex $NW 1 $n 3 2]+[lindex $NW 1 $n 3 4])/2}]
      set y [expr {([lindex $NW 1 $n 3 3]+[lindex $NW 1 $n 3 5])/2}]
      set text [[lindex $NW 4] create text $x $y -tags number\
        -justify center -text $n -font {-size 10}]
      [lindex $NW 4] create rectangle [[lindex $NW 4] bbox $text]\
        -fill white -outline blue -tags number
      [lindex $NW 4] raise $text
   }
}
%</pkg&graphics>
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Generic graphics}
% 
% The following procedures are mostly concerned with generating 
% coordinates for vertices and edges.
% 
% \begin{proc}{clearaux}
%   The |clearaux| procedure clears the auxiliary data stored in the 
%   edges of a network. The syntax is
%   \begin{quote}
%     |network::clearaux| \word{network-var}
%   \end{quote}
%   This can be useful if the network was first sproinged into some 
%   shape and has then undergone some transformation which did not 
%   update that data.
%   \begin{tcl}
%<*pkg>
proc network::clearaux {NWvar} {
   upvar 1 $NWvar NW
   for {set n 0} {$n < [llength [lindex $NW 1]]} {incr n} {
      if {[llength [lindex $NW 1 $n]] >= 6} then {
         lset NW 1 $n 5 {}
      }
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{gconstruct}
%   The |gconstruct| procedure is an extension of the |construct| 
%   procedure that additionally assigns coordinates to the vertices of 
%   the network it constructs. The syntax is
%   \begin{quote}
%     |network::gconstruct| \word{x-sep} \word{y-sep} 
%     \word{type-array} \word{component}\regplus
%   \end{quote}
%   where \word{type-array} and \word{component}\regplus\ are as for 
%   |construct|, whereas \word{x-sep} and \word{y-sep} are two 
%   numbers specifying the horizontal and vertical respectively 
%   advancement per \word{component} column and row. 
%   
%   The return value is a network with coordinates assigned to all 
%   vertices and leg-ends, but not to the edges.
%   
%   \begin{tcl}
proc network::gconstruct {xsep ysep typearr args} {
   set NW [uplevel 1\
     [list [namespace which -command construct] $typearr] $args]
   set y $ysep
   set x $xsep
   set n 0
   foreach a $args {
      switch -- $a "." - "x" - "X" {
         set x [expr {$x + $xsep}]
      } "\r" - "\n" {
         set x $xsep
         set y [expr {$y + $ysep}]
      } default {
         lset NW 0 $n [linsert [lindex $NW 0 $n] 3 [list $x $y] {}]
         set x [expr {$x + $xsep}]
         incr n
      }
   }
   set y [expr {$y + $ysep}]
   set legL [lindex $NW 2]
   set L [list];  set x 0
   foreach l [lindex $legL 0] {lappend L [set x [expr {$x + $xsep}]]}
   lappend legL $L
   set L [list];  set x 0
   foreach l [lindex $legL 1] {lappend L [set x [expr {$x + $xsep}]]}
   lappend legL $L $y 0 {} {}
   lset NW 2 $legL
   return $NW
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \begin{proc}{update_bbox}
%   The |update_bbox| procedure recomputes the |bbox| of a network. The 
%   syntax is simply
%   \begin{quote}
%     |network::update_bbox| \word{network-var}
%   \end{quote}
%   where \word{network-var} is (the name in the local context of the 
%   caller of a variable containing) a network which has 
%   \word{coordinates} elements in all its vertices. 
%   The return value is the computed bounding box, but that is also 
%   stored in the specified network variable.
%   
%   If no |bboxmargin| is specified in the network, it defaults to $20$.
%   \begin{tcl}
proc network::update_bbox {NWvar} {
   upvar 1 $NWvar NW
   set left [lindex $NW 0 0 3 0] ; set right $left
   set top [lindex $NW 0 0 3 1]  ; set bottom $top
   foreach v [lrange [lindex $NW 0] 1 end] {
      foreach {x y} [lindex $v 3] {break}
      if {$x < $left}   then {set left   $x}
      if {$y < $top}    then {set top    $y}
      if {$x > $right}  then {set right  $x}
      if {$y > $bottom} then {set bottom $y}
   }
   array set A [lindex $NW 3]
   set margin 20
   if {[info exists A(bboxmargin)]} then {set margin A(bboxmargin)}
   set bbox [list [expr {$left - $margin}] [expr {$top - $margin}]\
     [expr {$right + $margin}] [expr {$bottom + $margin}]]
   set A(bbox) $bbox
   lset NW 3 [array get A]
   return $bbox
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{trivial_grid}
%   The |trivial_grid| procedure assigns unique positions in a grid to 
%   the vertices and legs of a network, in such a way that the vertex on 
%   the input side of an edge is always higher up than the vertex on the 
%   output side of that edge. The syntax is
%   \begin{quote}
%     |network::trivial_grid| \word{network-var} \word{type-arr} 
%     \word{distance}\regopt\
%     \word{x-offset}\regopt\ \word{y-offset}\regopt
%   \end{quote}
%   where \word{distance} is the side of a square in the grid; it 
%   defaults to $40$. \word{network-var} and \word{type-arr} are both 
%   names of variables in the local context of the caller. 
%   \word{x-offset} and \word{y-offset} are amounts by which to offset 
%   the coordinates from the default position.
%   
%   As a side-effect, this procedure ensures that all vertex 
%   descriptions in the network has at least five elements.
%   
%   The basic method is to ask |levels_list| for a list of vertices by 
%   level and then use that list to assign the positions. Then a |bbox| 
%   is computed and the leg-ends are evenly spaced on its top and 
%   bottom sides.
%   \begin{tcl}
proc network::trivial_grid {NWvar TAvar {distance 40} {xofs 0} {yofs 0}} {
   upvar 1 $NWvar NW $TAvar TA
   set levels [levels_list $NW]
   set y [expr {round(([llength $levels]-0.5)*$distance + $yofs)}]
   foreach L $levels {
      set x [expr {$distance/2 + $xofs}]
      foreach i $L {
         set v [lindex $NW 0 $i]
         while {[llength $v]<5} {lappend v {}}
         lset v 3 [list $x $y]
         lset NW 0 $i $v
         set x [expr {$x + $distance}]
      }
      set y [expr {$y - $distance}]
   }
   foreach {left top right bottom} [update_bbox NW] {break}
   set oL [list]
   for {set n 0.5} {$n < [llength [lindex $NW 2 0]]}\
     {set n [expr {$n+1}]} {
      lappend oL [expr {$left +\
        ($right-$left)*$n/[llength [lindex $NW 2 0]]}]
   }
   set iL [list]
   for {set n 0.5} {$n < [llength [lindex $NW 2 1]]}\
     {set n [expr {$n+1}]} {
      lappend iL [expr {$left +\
        ($right-$left)*$n/[llength [lindex $NW 2 1]]}]
   }
   set L [lrange [lindex $NW 2] 0 1]
   lappend L $oL $iL $bottom $top [lindex $NW 2 6] [lindex $NW 2 7]
   lset NW 2 $L
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{avglex_grid}
%   The |avglex_grid| procedure assigns unique positions in a grid to 
%   the vertices and legs of a network, based on their positions in the 
%   list returned by |avglex_levels|. The syntax is
%   \begin{quote}
%     |network::avglex_grid| \word{network-var} 
%     \word{distance}\regopt\
%     \word{x-offset}\regopt\ \word{y-offset}\regopt
%   \end{quote}
%   where \word{distance} is the side of a square in the grid; it 
%   defaults to $40$. \word{network-var} is the name of the variable in 
%   the local context of the caller which contains the network to 
%   operate on. \word{x-offset} and \word{y-offset} are amounts by 
%   which to offset the coordinates from the default position.
%   
%   As a side-effect, this procedure ensures that all vertex 
%   descriptions in the network has at least five elements. It also 
%   ensures that the legs list has exactly eight elements.
%   
%   \begin{tcl}
proc network::avglex_grid {NWvar {distance 40} {xofs 0} {yofs 0}} {
   upvar 1 $NWvar NW
   set levels [avglex_levels $NW]
   set y [expr {round(([llength $levels]-0.5)*$distance + $yofs)}]
   set max_x $xofs
   foreach L $levels {
      set x [expr {$distance/2 + $xofs}]
      foreach i $L {
         if {$i >= 0} then {
            set v [lindex $NW 0 $i]
            while {[llength $v]<5} {lappend v {}}
            lset v 3 [list $x $y]
            lset NW 0 $i $v
            if {$x > $max_x} then {set max_x $x}
         }
         set x [expr {$x + $distance}]
      }
      set y [expr {$y - $distance}]
   }
   set left $xofs
   set right [expr {$max_x + $distance/2}]
   set top $yofs
   set bottom [expr {[llength $levels]*$distance + $yofs}]
   set oL [list]
   for {set n 0.5} {$n < [llength [lindex $NW 2 0]]}\
     {set n [expr {$n+1}]} {
      lappend oL [expr {$left +\
        ($right-$left)*$n/[llength [lindex $NW 2 0]]}]
   }
   set iL [list]
   for {set n 0.5} {$n < [llength [lindex $NW 2 1]]}\
     {set n [expr {$n+1}]} {
      lappend iL [expr {$left +\
        ($right-$left)*$n/[llength [lindex $NW 2 1]]}]
   }
   set L [lrange [lindex $NW 2] 0 1]
   lappend L $oL $iL $bottom $top [lindex $NW 2 6] [lindex $NW 2 7]
   lset NW 2 $L
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{simple_edges}
%   The |simple_edges| procedure computes coordinates for the edges of a 
%   network (``simple'' refers to the simplicity of the method used to 
%   compute these coordinates). The syntax is
%   \begin{quote}
%     |network::simple_edges| \word{network-var} \word{type-arr} 
%   \end{quote}
%   where \word{network-var} and \word{type-arr} are names of variables 
%   in the local context of the caller. There is no particular return 
%   value, but the \word{network-var} will be modified.
%   
%   Each edge curve is defined by four points. The two endpoints are 
%   precisely the points where the edge is attached to a vertex, or in 
%   the case of the input\slash output end of a leg, the cut-off point 
%   of that leg. The $y$-coordinates of the two 
%   non-end-points are precisely $1/3$ and $2/3$ between thoose 
%   coordinates of the endpoints. The $x$-coordinates are chosen so 
%   that the endpoint tangent lines go through the corresponding vertex, 
%   or in the case of legs, is vertical.
%   \begin{tcl}
proc network::simple_edges {NWvar TAvar} {
   upvar 1 $NWvar NW $TAvar TA
   set n 0
   foreach e [lindex $NW 1] {
      set i [lindex $e 1]
      if {$i>=0} then {
         set j [lsearch -exact -integer [lindex $NW 0 $i 1] $n]
         set d1 [lindex $TA([lindex $NW 0 $i 0]) 1 1 $j]
         set x0 [expr {[lindex $NW 0 $i 3 0] + [lindex $d1 0]}]
         set y0 [expr {[lindex $NW 0 $i 3 1] + [lindex $d1 1]}]
      } else {
         set d1 {0 1}
         set x0 [lindex $NW 2 3 [expr {-$i-1}]]
         set y0 [lindex $NW 2 5]
      }
      set i [lindex $e 0]
      if {$i>=0} then {
         set j [lsearch -exact -integer [lindex $NW 0 $i 1] $n]
         set d2 [lindex $TA([lindex $NW 0 $i 0]) 1 1 $j]
         set x3 [expr {[lindex $NW 0 $i 3 0] + [lindex $d2 0]}]
         set y3 [expr {[lindex $NW 0 $i 3 1] + [lindex $d2 1]}]
      } else {
         set d2 {0 -1}
         set x3 [lindex $NW 2 2 [expr {-$i-1}]]
         set y3 [lindex $NW 2 4]
      }
      set y1 [expr {0.6667*$y0 + 0.3333*$y3}]
      set y2 [expr {0.3333*$y0 + 0.6667*$y3}]
      set x1 [expr {$x0 + ($y1-$y0)*[lindex $d1 0]/[lindex $d1 1]}]
      set x2 [expr {$x3 + ($y2-$y3)*[lindex $d2 0]/[lindex $d2 1]}]
      while {[llength $e]<5} {lappend e {}}
      lset e 3 [list $x0 $y0 $x1 $y1 $x2 $y2 $x3 $y3]
      lset NW 1 $n $e
      incr n
   }
}
%</pkg>
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{PDF graphics}
% 
% For showing networks to other mathematicians, it is useful to render 
% them as PDF graphics. Since this is not entirely trivial, I call upon 
% my \textsf{pdf} package to do the grunt work.
% \begin{tcl}
%<*pkg&pdf>
package require pdf
namespace eval network::topdf {}
% \end{tcl}
% \setnamespace{network::topdf}
% This does not automagically make PDF generation easy, but at least it 
% makes it comparable to canvas drawing.
% 
% 
% \begin{proc}{write_XObject}
%   There are many ways in which one can embed the graphical 
%   representation of a network in a PDF file, but the one that seems 
%   best is to embed it as a ``Form XObject''. Amongst other things, 
%   this allows one to draw the network and determine its bounding box 
%   first, and only later decide where (and at what scale) it should be 
%   placed on a page. It is also straightforward to later amend so that 
%   the raw network data gets included with its graphical representation.
%   
%   The |write_XObject| writes such an XObject representing a 
%   network to a PDF file that is open for writing. The syntax of this 
%   procedure is
%   \begin{quote}
%     |network::topdf::write_XObject| \word{file} \word{label} 
%     \word{network} \word{type-arr} 
%     \begin{regblock}[\regstar]\word{option} \word{value}\end{regblock}
%   \end{quote}
%   and the return value is the XObject's bounding box (a rectangle). 
%   \word{file} is the PDF file identifier; the current position in 
%   this file must not be in the middle of a stream. \word{label} is 
%   the label to assign to the XObject stream; there should not be any 
%   labels beginning with `\meta{label}\texttt{/}' elsewhere in the 
%   document, as some such labels will be used internally for the 
%   XObject. \word{network} is the network to write and \word{type-arr} 
%   is the name of an array in the local context of the caller 
%   describing the vertex types used. The \word{network} must have 
%   coordinates assigned to all vertices, edges, and leg-ends.
%   
%   The \word{option} \word{value} pairs are used to configure the code 
%   generation. \word{option}s that begin with a `\texttt{/}' are 
%   interpreted as keys to insert into the stream dictionary, in which 
%   case the \word{value} must be a PDF object. Ordinary \word{option}s 
%   begin with a `\texttt{-}'; these are currently
%   \begin{longtable}{l p{0.7\linewidth}}
%     |-checkedges|& A boolean. If true, it is checked that edges 
%       have coordinates before trying to draw them, and if they do 
%       not then |elastic_edges| are called for the network to ensure 
%       that they do.\\
%     |-fontobj|& The |/Font| object to use for leg-end labels. 
%       Defaults to Helvetica.\\
%     |-fontsize|& The fontsize for leg-end labels. Defaults to |10| 
%       (user space units).\\
%     |-fontmeasure|& A command prefix to use to measure strings 
%       in the specified |/Font| at size $1$. The syntax is
%       \begin{quote}
%         \meta{value} \word{text}
%       \end{quote}
%       The return value is a rectangle for the ``\TeX\ box'' of the 
%       \word{text}, expressed in the coordinate system whose origin is 
%       at the reference point of the box. This defaults to the 
%       |measure_Helvetica_digits| procedure below.\\
%     |-labelsep|& Vertical separation between a leg-end and its label. 
%       Defaults to |1|.\\
%     |-margin|& The amount of ``padding'' to add to the bounding box. 
%       Defaults to |1|. May have to be increased if the line widths 
%       are going to be large.
%   \end{longtable}
%   
%   Since the network data structures follow the Tk standard of a 
%   $y$-axis pointing downwards rather than the mathematical standard 
%   used in PDF, all $y$ coordinates are negated.
%   
%   \begin{tcl}
proc network::topdf::write_XObject {F label NW TA_name args} {
   upvar 1 $TA_name TA
   array set Opt {
      -fontobj {<</Type/Font /Subtype/Type1 /BaseFont/Helvetica\
        /Encoding/MacRomanEncoding>>}
      -fontsize 10
      -fontmeasure measure_Helvetica_digits
      -labelsep 1
      -margin 1
      -checkedges 1
   }
   array set Opt $args
   eval [list pdf::begin_contents "" $F $label\
%
     /Type /XObject  /Subtype /Form  /FormType 1\
%
     /BBox [pdf::obj_ref $F $label/BBox]\
     /Resources [pdf::obj_ref $F $label/Resources]]\
%
     [array get Opt /*]
   set bbox [list infinity infinity "" ""]
   pdf::name_resource font $F Font $Opt(-fontobj)
%   \end{tcl}
%   First the edges are drawn. Currently line width, colour, etc.\@ are 
%   not set (could be useful to let these be decided by the external 
%   context), but the linecaps are butt.
%   \changes{alpha}{2006/10/15}{Added mechanism to check that edges 
%      have graphics, and if not generate one. (LH)}
%   \begin{tcl}
   if {$Opt(-checkedges)} then {
      set ok 1
      foreach edge [lindex $NW 1] {
         set ok [expr {$ok && [llength $edge]>=4}]
      }
      if {!$ok} then {network::elastic_edges NW TA}
   }
   pdf::printf $F {0 J}
   foreach edge [lindex $NW 1] {write_edge $F $edge bbox}
%   \end{tcl}
%   Then the vertices are drawn.
%   \begin{tcl}
   foreach vertex [lindex $NW 0] {
      write_vertex $F $vertex $TA([lindex $vertex 0]) bbox
   }
%   \end{tcl}
%   And finally the leg-end labels.
%   \begin{tcl}
   pdf::printf $F {%o %r Tf} $font $Opt(-fontsize)
   set n 0
   set y0 [expr {-[lindex $NW 2 4]}]
   foreach x0 [lindex $NW 2 2] {
      set tbox [eval $Opt(-fontmeasure) [list $n]]
      set x [expr {$x0 - ([lindex $tbox 2]-[lindex $tbox 0]) *\
        0.5*$Opt(-fontsize)}]
      set y [expr {$y0 - [lindex $tbox 3]*$Opt(-fontsize)\
        - $Opt(-labelsep)}]
      pdf::printf $F {BT %r2 Td %s Tj ET} $x $y $n
      foreach i {0 1 2 3} xy [list $x $y $x $y] s {1 1 -1 -1} {
         set xy [expr {$xy + [lindex $tbox $i]*$Opt(-fontsize)}]
         if {$s * ([lindex $bbox $i]-$xy) > 0}\
         then {lset bbox $i $xy}
      }
      incr n
   }
   set n 0
   set y0 [expr {-[lindex $NW 2 5]}]
   foreach x0 [lindex $NW 2 3] {
      set tbox [eval $Opt(-fontmeasure) [list $n]]
      set x [expr {$x0 - ([lindex $tbox 2]-[lindex $tbox 0]) *\
        0.5*$Opt(-fontsize)}]
      set y [expr {$y0 - [lindex $tbox 1]*$Opt(-fontsize)\
        + $Opt(-labelsep)}]
      pdf::printf $F {BT %r2 Td %s Tj ET} $x $y $n
      foreach i {0 1 2 3} xy [list $x $y $x $y] s {1 1 -1 -1} {
         set xy [expr {$xy + [lindex $tbox $i]*$Opt(-fontsize)}]
         if {$s * ([lindex $bbox $i]-$xy) > 0}\
         then {lset bbox $i $xy}
      }
      incr n
   }
%   \end{tcl}
%   Then all that remains are some finishing touches.
%   \begin{tcl}
   pdf::end_contents Res $F
   pdf::put_obj $F $label/Resources [pdf::resource_dict_obj Res]
   if {[lindex $bbox 0] eq "infinity"} then {
      set bbox {0 0 0 0}
   } else {
      set bbox [pdf::inset_rect $bbox [expr {-$Opt(-margin)}] bp]
   }
   pdf::put_obj $F $label/BBox [pdf::rect_obj $bbox]
   return $bbox
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{write_edge}
%   This procedure is a helper for |write_XObject| that writes the 
%   content material needed to define and stroke an edge. As a 
%   side-effect, it also updates the bounding box. The syntax is
%   \begin{quote}
%     |network::topdf::write_edge| \word{file} \word{edge} 
%     \word{bbox-var}
%   \end{quote}
%   
%   In the network, the coordinates for the edges are specified as 
%   TrueType-style splines, which means a conversion to cubic Bezier 
%   curve coordinates is called for. In the Tk core, this would in 
%   response to a |$canvas postscript| command be carried out by the 
%   \textit{Tk\-Make\-Bezier\-Postscript} function, so the safest 
%   approach is simply to copy its algorithm. One modification is 
%   however that the $y$ axis mirroring, which in Tk is done using 
%   \textit{Tk\_Canvas\-PsY}, is built into the conversion formulae 
%   below; the odd |c| variables are the negative of their 
%   \textit{control} element counterparts from 
%   \textit{Tk\-Make\-Bezier\-Postscript}.
%   \begin{tcl}
proc network::topdf::write_edge {F edge bboxvar} {
   upvar 1 $bboxvar bbox
   set cL [lindex $edge 3]
%   \end{tcl}
%   Tk comment: \emph{If the curve is a closed one then generate a 
%   special spline that spans the last points and the first ones.  
%   Otherwise just put the first point into the path.}
%   \begin{tcl}
   if {[lindex $cL 0] == [lindex $cL end-1] &&\
       [lindex $cL 1] == [lindex $cL end]} then {
      set closed 1
      set c0 [expr { 0.5  *[lindex $cL end-3] + 0.5  *[lindex $cL 0]}]
      set c1 [expr {-0.5  *[lindex $cL end-2] - 0.5  *[lindex $cL 1]}]
      set c2 [expr { 0.167*[lindex $cL end-3] + 0.833*[lindex $cL 0]}]
      set c3 [expr {-0.167*[lindex $cL end-2] - 0.833*[lindex $cL 1]}]
      set c4 [expr { 0.833*[lindex $cL 0]     + 0.167*[lindex $cL 2]}]
      set c5 [expr {-0.833*[lindex $cL 1]     - 0.167*[lindex $cL 3]}]
      set c6 [expr { 0.5  *[lindex $cL 0]     + 0.5  *[lindex $cL 2]}]
      set c7 [expr {-0.5  *[lindex $cL 1]     - 0.5  *[lindex $cL 3]}]
      pdf::printf $F {%r2 m %r6 c} $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7
      foreach {x y} [list $c0 $c1 $c2 $c3 $c4 $c5 $c6 $c7] {
         if {[lindex $bbox 0] > $x} then {lset bbox 0 $x}
         if {[lindex $bbox 1] > $y} then {lset bbox 1 $y}
         if {[lindex $bbox 2] < $x} then {lset bbox 2 $x}
         if {[lindex $bbox 3] < $y} then {lset bbox 3 $y}
      }
   } else {
      set closed 0
      set c6 [lindex $cL 0]
      set c7 [expr {-[lindex $cL 1]}]
      pdf::printf $F {%r2 m} $c6 $c7
      foreach {x y} [list $c6 $c7] {
         if {[lindex $bbox 0] > $x} then {lset bbox 0 $x}
         if {[lindex $bbox 1] > $y} then {lset bbox 1 $y}
         if {[lindex $bbox 2] < $x} then {lset bbox 2 $x}
         if {[lindex $bbox 3] < $y} then {lset bbox 3 $y}
      }
   }
%   \end{tcl}
%   Tk comment: \emph{Cycle through all the remaining points in the 
%   curve, generating a curve section for each vertex in the linear 
%   path.} |$p0| through |$p3| below are $\mathit{pointPtr}[0]$ 
%   through $\mathit{pointPtr}[3]$.
%   \begin{tcl}
   foreach {p0 p1} [lrange $cL 2 3] break
   foreach {p2 p3} [lrange $cL 4 end-2] {
      set c2 [expr { 0.333*$c6 + 0.667*$p0}]
      set c3 [expr { 0.333*$c7 - 0.667*$p1}]
      set c6 [expr { 0.5  *$p0 + 0.5  *$p2}]
      set c7 [expr {-0.5  *$p1 - 0.5  *$p3}]
      set c4 [expr { 0.333*$c6 + 0.667*$p0}]
      set c5 [expr { 0.333*$c7 - 0.667*$p1}]
      pdf::printf $F {%r6 c} $c2 $c3 $c4 $c5 $c6 $c7
      foreach {x y} [list $c2 $c3 $c4 $c5 $c6 $c7] {
         if {[lindex $bbox 0] > $x} then {lset bbox 0 $x}
         if {[lindex $bbox 1] > $y} then {lset bbox 1 $y}
         if {[lindex $bbox 2] < $x} then {lset bbox 2 $x}
         if {[lindex $bbox 3] < $y} then {lset bbox 3 $y}
      }
      set p0 $p2; set p1 $p3
   }
%   \end{tcl}
%   Tk comment: \emph{Set up the last two control points. This is done
%   differently for the last spline of an open curve than for other 
%   cases.}
%   \begin{tcl}
   foreach {p2 p3} [lrange $cL end-1 end] break
   set c2 [expr { 0.333*$c6 + 0.667*$p0}]
   set c3 [expr { 0.333*$c7 - 0.667*$p1}]
   if {$closed} then {
      set c6 [expr { 0.5  *$p0 + 0.5  *$p2}]
      set c7 [expr {-0.5  *$p1 - 0.5  *$p3}]
   } else {
      set c6 $p2
      set c7 [expr {-$p3}]
   }
   set c4 [expr { 0.333*$c6 + 0.667*$p0}]
   set c5 [expr { 0.333*$c7 - 0.667*$p1}]
   pdf::printf $F {%r6 c} $c2 $c3 $c4 $c5 $c6 $c7
   foreach {x y} [list $c2 $c3 $c4 $c5 $c6 $c7] {
      if {[lindex $bbox 0] > $x} then {lset bbox 0 $x}
      if {[lindex $bbox 1] > $y} then {lset bbox 1 $y}
      if {[lindex $bbox 2] < $x} then {lset bbox 2 $x}
      if {[lindex $bbox 3] < $y} then {lset bbox 3 $y}
   }
   pdf::printf $F [expr {$closed ? "s" : "S"}]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{write_vertex}
%   This procedure is a helper for |write_XObject| that writes the 
%   content material needed to define and draw a vertex. As a 
%   side-effect, it also updates the bounding box. The syntax is
%   \begin{quote}
%     |network::topdf::write_vertex| \word{file} \word{vertex} 
%     \word{type-info} \word{bbox-var}
%   \end{quote}
%   where \word{type-info} is the entry in the vertex type array that 
%   pertains to this vertex and \word{bbox-var} is the name (in the 
%   local context of the caller) of the bounding box variable.
%   
%   Since vertices can be composite and make use of any number of 
%   canvas item types, rendering vertices as PDF should better be an 
%   extensible operation. Therefore most of the work is delegated to 
%   procedures
%   \begin{quote}
%     |network::topdf::|\meta{item type} \word{file} \word{bbox-var} 
%     \word{coordinates} \word{options} 
%   \end{quote}
%   where \word{item type} is the canvas item type name. \word{file} is 
%   the PDF file to write operators to and \word{bbox-var} is the name 
%   of a variable in the local context of the caller that contains a 
%   bounding box rectangle to update for all the points in the graphics 
%   generated. \word{coordinates} is the list of canvas coordinates for 
%   the item and \word{options} is the options for it.
%   
%   \begin{tcl}
proc network::topdf::write_vertex {F vertex typeinfo bboxvar} {
   upvar 1 $bboxvar bbox
   foreach {item ccmd opts} [lindex $typeinfo 1 0] {
      [namespace current]::$item $F bbox [
         namespace eval [namespace parent]::shape $ccmd\
           [lindex $vertex 3]
      ] $opts
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{rectangle}
%   This procedure renders a rectangular vertex as PDF. It currently 
%   doesn't support any options.
%   \begin{tcl}
proc network::topdf::rectangle {F bboxvar cL opts} {
   if {[llength $opts]} then {
      error "Sorry, rectangle conversions currently doesn't support\
        options."
   }
   set rbox [list]
   foreach {x y} $cL {lappend rbox $x [expr {-$y}]}
   set rbox [pdf::standard_rect $rbox]
   pdf::printf $F {%R re S} [pdf::wh_rect $rbox]
   upvar 1 $bboxvar bbox
   foreach i {0 1 2 3} s {1 1 -1 -1} {
      if {$s*([lindex $bbox $i] - [lindex $rbox $i]) > 0}\
      then {lset bbox $i [lindex $rbox $i]}
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{oval}
%   This procedure renders an oval vertex as PDF. It currently 
%   doesn't support any options.
%   \begin{tcl}
proc network::topdf::oval {F bboxvar cL opts} {
   if {[llength $opts]} then {
      error "Sorry, rectangle conversions currently doesn't support\
        options."
   }
   set rbox [list]
   foreach {x y} $cL {lappend rbox $x [expr {-$y}]}
   set rbox [pdf::standard_rect $rbox]
%   \end{tcl}
%   The tricky part is to approximate the elliptical arcs by cubic 
%   Bezi\'er arcs. The following corresponds to the MetaFont 
%   four-segment approximation of a circle.
%   \begin{tcl}
   foreach {x0 y0 x4 y4} $rbox break
   set x1 [expr {0.77614235*$x0 + 0.22385765*$x4}]
   set x2 [expr {0.5*($x0+$x4)}]
   set x3 [expr {0.22385765*$x0 + 0.77614235*$x4}]
   set y1 [expr {0.77614235*$y0 + 0.22385765*$y4}]
   set y2 [expr {0.5*($y0+$y4)}]
   set y3 [expr {0.22385765*$y0 + 0.77614235*$y4}]
   pdf::printf $F {%r2 m} $x2 $y0
   pdf::printf $F {%r6 c}   $x3 $y0 $x4 $y1 $x4 $y2
   pdf::printf $F {%r6 c}   $x4 $y3 $x3 $y4 $x2 $y4
   pdf::printf $F {%r6 c}   $x1 $y4 $x0 $y3 $x0 $y2
   pdf::printf $F {%r6 c s} $x0 $y1 $x1 $y0 $x2 $y0
% \medskip
   upvar 1 $bboxvar bbox
   foreach i {0 1 2 3} s {1 1 -1 -1} {
      if {$s*([lindex $bbox $i] - [lindex $rbox $i]) > 0}\
      then {lset bbox $i [lindex $rbox $i]}
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{measure_Helvetica_digits}
%   This procedure is a helper of |write_XObject| that can measure 
%   strings consisting of digits. Its syntax is
%   \begin{quote}
%     |network::measure_Helvetica_digits| \word{text}
%   \end{quote}
%   and it returns a rectangle corresponding to the (\TeX) box of these 
%   digits at fontsize $1$.
%   
%   The implementation is quite a cheat, that algorithmises the digit 
%   metrics: every digit is $556$ charspace units wide, all digits but 
%   |1|, |2|, |4|, and |7| have depth $19$ (the other digits have depth 
%   $0$), and all digits but |5| and |7| have height $703$ (the other 
%   two have height $688$).
%   \begin{tcl}
proc network::topdf::measure_Helvetica_digits {text} {
   set res [list 0]
   if {[regexp {[035689]} $text]}\
   then {lappend res -0.019} else {lappend res 0}
   lappend res [expr {0.556 * [string length $text]}]
   if {[regexp {[0-4689]} $text]}\
   then {lappend res 0.703} else {lappend res 0.688}
   return $res
}
%</pkg&pdf>
%   \end{tcl}
% \end{proc}
% 
% \subsubsection{A simple test}
% 
% \begin{tcl}
%<*test&pdf>
set F [pdf::rewrite_pdf network-test.pdf]
%
set NW [network::gconstruct 40 40 Hopf_types\
  . Delta \r m S \r Delta Delta \r . m]
network::simple_edges NW Hopf_types
set bbox [network::topdf::write_XObject $F "NW0" $NW Hopf_types]
%
pdf::begin_contents "" $F "Page contents"
set dx [expr {
   0.5*[lindex $pdf::paper_rect(A4) 0] + 
   0.5*[lindex $pdf::paper_rect(A4) 2] -
   0.5*([lindex $bbox 0] + [lindex $bbox 2])
}]
set dy [expr {
   0.5*[lindex $pdf::paper_rect(A4) 1] + 
   0.5*[lindex $pdf::paper_rect(A4) 3] -
   0.5*([lindex $bbox 1] + [lindex $bbox 3])
}]
pdf::printf $F {q 1 0 0 1 %r2 cm} $dx $dy
pdf::printf $F {%r w} 0.5
pdf::name_resource NW_name $F XObject [pdf::obj_ref $F "NW0"]
pdf::printf $F {%o Do Q} $NW_name
pdf::end_contents Rez $F
%
pdf::begin_pages $F "Pages\#"\
  /MediaBox [pdf::rect_obj $pdf::paper_rect(A4)]
pdf::shipout $F "Page"\
  /Contents [pdf::obj_ref $F "Page contents"]\
  /Resources [pdf::resource_dict_obj Rez]
pdf::put_obj $F "The catalog" [pdf::dict_obj\
  /Type /Catalog /Pages [pdf::obj_ref $F [pdf::end_pages $F]]]
pdf::close_pdf $F "The catalog"
%</test&pdf>
% \end{tcl}
% 
% \subsubsection{Dumping vertex types}
% 
% \begin{tcl}
%<*test&pdf>
set type_array_name Hopf_types
set F [pdf::rewrite_pdf vertex-dump.pdf]
pdf::begin_pages $F "Pages\#"
%
foreach vtype [array names $type_array_name] {
   set NW [network::gconstruct 40 40 $type_array_name $vtype]
   network::elastic_edges NW $type_array_name
   set bbox [network::topdf::write_XObject\
     $F "NW/$vtype" $NW $type_array_name]
%
   pdf::begin_contents "" $F "Page contents/$vtype"
   pdf::printf $F {%r w} 0.5
   pdf::name_resource NW_name $F XObject [pdf::obj_ref $F "NW/$vtype"]
   pdf::printf $F {%o Do} $NW_name
   array unset Rez
   pdf::end_contents Rez $F
%
   set pagerect [pdf::make_rect -left [lindex $bbox 0]\
     -bottom [lindex $bbox 1] -width 210 mm -height 297 mm]
   set pagerect [pdf::offset_rect $pagerect -1 -1 cm]
   pdf::shipout $F "Page/$vtype"\
    /Contents [pdf::obj_ref $F "Page contents/$vtype"]\
    /Resources [pdf::resource_dict_obj Rez]\
    /ArtBox [pdf::rect_obj $bbox]\
    /MediaBox [pdf::rect_obj $pagerect]
}
pdf::put_obj $F "The catalog" [pdf::dict_obj\
  /Type /Catalog /Pages [pdf::obj_ref $F [pdf::end_pages $F]]]
pdf::close_pdf $F "The catalog"
%</test&pdf>
% \end{tcl}
% \setnamespace{network}
% 
% 
% 
% \section{Spring networks}
% \label{Sec:Springs}
% 
% The problem of automatically finding a nice way to draw a graph in 
% the plane has generated a substantial body of literature, and it turns 
% out that in most cases the problem of finding the \emph{best} (with 
% respect to some reasonable criteria) way to draw a graph is NP-hard. 
% There are however plenty of useful heuristic methods around.
% 
% One of the most popular heuristics, originally due to Eades, is to 
% consider the graph as a physical system, where the edges are replaced by 
% springs and the vertex positions are chosen so that the system is in 
% equilibrium. Finding an equilibrium configuration is in general easy, 
% since a simulation (with some kind of ``friction'') of the system 
% will in general quickly approach and come to rest at some equilibrium. 
% As is often the case in graph theory, such physical models demonstrate 
% an unreasonable usefulness.
% 
% 
% \subsection{Elastic edges}
% 
% In the network situation, where edges are curves rather than straight 
% lines, it probably makes more sense to think of them as strings made 
% from some elastic material than to think of them as actual strings. 
% The physical law governing their behaviours would be the same in both 
% cases, but it is easier to justify the calculations below in a truly 
% continuous model.
% 
% The relevant physical law for elasticify in this case is \emph{Hooke's 
% law}
% \begin{equation} \label{Eq:Hooke}
%   \sigma = E \varepsilon 
%   \qquad\text{where}\qquad 
%   \varepsilon = \frac { \mathit{\Delta l} }{ l }
%   \text{,}
% \end{equation}
% which relates the tension $\sigma$ to the relative elongation 
% $\varepsilon$ of the string, via the \emph{elasticity coefficient} $E$ 
% of the material. However in this particular problem it is more 
% convenient to relate $\varepsilon$ to the amount of energy that is 
% stored in the string (or equivalently: the amount of energy it took 
% to deform the string), as reasoning about energy is often much simpler 
% than reasoning about forces. In this case the relevant formula is
% \begin{equation}
%   W = k \varepsilon^2
% \end{equation}
% as follows from \eqref{Eq:Hooke} by integration over $\mathit{\Delta l}$. 
% (The constant \(k = \frac{1}{2} EAl\), where $A$ is the cross-section 
% area of the string and the factor $\frac{1}{2}$ comes from the 
% integration.)
% 
% Since it is given that each edge will have the shape of a parametric 
% curve $\mathbf{r}(t)$ for \(t \in [t_1,t_2]\), it is close at hand to 
% adopt the parameter $t$ as being proportional to the natural length of 
% the string. In this case, $\varepsilon$ need not be constant along the 
% string, but varies with parametric speed so that \(\bigl( 1 +\nobreak 
% \varepsilon(t) \bigr) v_0 = v(t)\), where \(v(t) = \bigl\vert \mathbf{v}(t) 
% \bigr\vert\), \(\mathbf{v}(t) = \mathbf{r}'(t)\), and $v_0$ is the 
% parametric speed for the string at its natural length. Consequently
% \begin{equation} \label{Eq:ElastiskEnergi}
%   W = k \int_{t_1}^{t_2} \varepsilon(t)^2 \,\mathit{dt} =
%   \frac{k}{v_0^2} \int_{t_1}^{t_2} \bigl( v(t) - v_0 \bigr)^2 \,\mathit{dt}
% \end{equation}
% is the relevant quantity to consider.
% 
% As a first step, one may consider what shape the edges should assume 
% if endpoints and endpoint tangents are given. The answer is that they 
% should assume a shape with minimal energy, i.e., a shape for which 
% the integral
% \begin{equation} \label{Eq:Kant-energi}
%   \int_{t_1}^{t_2} \bigl( v(t) - v_0 \bigr)^2 \,\mathit{dt}
% \end{equation}
% is minimal. Since the edge curve $\mathbf{r}(t)$ is a |-smooth 1| 
% canvas curve defined by four points $\mathbf{z}_0$, $\mathbf{z}_1$, 
% $\mathbf{z}_2$, and $\mathbf{z}_3$, it is most easily expressed in 
% terms of Bern\v{s}te\u{\i}n polynomials. For any \(n \in \mathbb{N}\) 
% and $a_0,\dotsc,a_n$ define
% \begin{equation}
%   B_n(a_0,\dotsc,a_n; t) =
%   \sum_{k=0}^n \binom{n}{k} (1-t)^{n-k} t^k a_k \text{.}
% \end{equation}
% Then by definition of |-smooth 1| curves,
% \begin{equation*}
%   \mathbf{r}(t) = \begin{cases}
%     B_2( \mathbf{z}_0, \mathbf{z}_1, \tfrac{1}{2}\mathbf{z}_1 + 
%       \tfrac{1}{2}\mathbf{z}_2; t) &
%       \text{if \(0 \leqslant t \leqslant 1\),}\\
%     B_2( \tfrac{1}{2}\mathbf{z}_1 + \tfrac{1}{2}\mathbf{z}_2, 
%       \mathbf{z}_2, \mathbf{z}_3; t-1) &
%       \text{if \(1 \leqslant t \leqslant 2\).}
%   \end{cases}
% \end{equation*}
% In general,
% \begin{equation} \label{Eq:Bernstein-diff}
%    \frac{d}{\mathit{dt}} B_n(a_0,\dotsc,a_n; t) =
%    B_{n-1}(a_1-a_0,\dotsc,a_n-a_{n-1}; t)
% \end{equation}
% and consequently
% \begin{equation*}
%   \mathbf{v}(t) = \begin{cases}
%     2B_1( \mathbf{z}_1 - \mathbf{z}_0 , 
%       \tfrac{1}{2}\mathbf{z}_2 - \tfrac{1}{2}\mathbf{z}_1; t) &
%       \text{if \(0 \leqslant t \leqslant 1\),}\\
%     2B_1( \tfrac{1}{2}\mathbf{z}_2 - \tfrac{1}{2}\mathbf{z}_1, 
%       \mathbf{z}_3 - \mathbf{z}_2; t-1) &
%       \text{if \(1 \leqslant t \leqslant 2\).}
%   \end{cases}
% \end{equation*}
% Since
% \begin{multline*}
%   \bigl\vert B_1(\mathbf{a}_0,\mathbf{a}_1;t) \bigr\vert^2 =
%   \bigl< B_1(\mathbf{a}_0,\mathbf{a}_1;t), 
%     B_1(\mathbf{a}_0,\mathbf{a}_1;t) \bigr> = \\ =
%   \bigl< (1-t) \mathbf{a}_0, (1-t) \mathbf{a}_0 \bigr> + 
%     \bigl< (1-t) \mathbf{a}_0, t \mathbf{a}_1 \bigr> + 
%     \bigl< t \mathbf{a}_1, (1-t) \mathbf{a}_0 \bigr> + 
%     \bigl< t \mathbf{a}_1, t \mathbf{a}_1 \bigr> = \\ =
%   B_2\bigl( \lvert\mathbf{a}_0\rvert^2, 
%     \langle \mathbf{a}_0, \mathbf{a}_1\rangle, 
%     \lvert\mathbf{a}_1\rvert^2; t \bigr)
% \end{multline*}
% it follows that
% \begin{equation*}
%   v(t)^2 = \begin{cases}
%     4 B_2\Bigl( \lvert \mathbf{z}_1 - \mathbf{z}_0 \rvert^2, 
%       \tfrac{1}{2} \langle \mathbf{z}_1 - \mathbf{z}_0, 
%         \mathbf{z}_2 - \mathbf{z}_1 \rangle,
%       \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2; 
%       t \Bigr)
%       & \text{if \(0 \leqslant t \leqslant 1\),}\\
%     4 B_2\Bigl( 
%       \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2, 
%       \tfrac{1}{2} \langle \mathbf{z}_2 - \mathbf{z}_1,
%         \mathbf{z}_3 - \mathbf{z}_2 \rangle,
%       \lvert \mathbf{z}_3 - \mathbf{z}_2 \rvert^2; 
%       t-1 \Bigr) &
%       \text{if \(1 \leqslant t \leqslant 2\).}
%   \end{cases}
% \end{equation*}
% 
% From applying \eqref{Eq:Bernstein-diff} backwards one gets
% \begin{equation*}
%   \int B_n(a_0,\dotsc,a_n; t) \, \mathit{dt} =
%   \tfrac{1}{n+1} B_{n+1}( 0, a_0, a_0+a_1, \dotsc, a_0 + a_1 + 
%     \dotsb + a_n; t) + C
% \end{equation*}
% and thus in particular
% \begin{equation*}
%   \int_0^1 B_n(a_0,\dotsc,a_n; t) \, \mathit{dt} =
%   \frac{1}{n+1} \sum_{k=0}^n a_k
%   \text{,}
% \end{equation*}
% whence
% \begin{align*}
%   \int_0^2 v(t)^2 \, \mathit{dt} ={}&
%   \int_0^1 v(t)^2 \, \mathit{dt} + \int_0^1 v(t+1)^2 \, \mathit{dt} 
%     = \\ ={}&
%   \frac{4}{3} \bigl( 
%     \lvert \mathbf{z}_1 - \mathbf{z}_0 \rvert^2 + 
%     \tfrac{1}{2} \langle \mathbf{z}_1 - \mathbf{z}_0, 
%         \mathbf{z}_2 - \mathbf{z}_1 \rangle +
%     \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2
%   \bigr) \\ &\quad {}+
%   \frac{4}{3} \bigl( 
%     \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2 +
%     \tfrac{1}{2} \langle \mathbf{z}_2 - \mathbf{z}_1,
%         \mathbf{z}_3 - \mathbf{z}_2 \rangle + 
%     \lvert \mathbf{z}_3 - \mathbf{z}_2 \rvert^2
%   \bigr) = \\ ={}&
%   \frac{4}{3} \bigl( 
%     \lvert \mathbf{z}_1 - \mathbf{z}_0 \rvert^2 + 
%     \lvert \mathbf{z}_3 - \mathbf{z}_2 \rvert^2 + 
%     \tfrac{1}{2} \langle \mathbf{z}_2 - \mathbf{z}_1,
%         \mathbf{z}_3 - \mathbf{z}_0 \rangle
%   \bigr)
%   \text{.}
% \end{align*}
% Writing \(\mathbf{c} = \mathbf{z}_3 - \mathbf{z}_0\), \(r\mathbf{a} = 
% \mathbf{z}_1 - \mathbf{z}_2\), and \(s\mathbf{b} = \mathbf{z}_2 - 
% \mathbf{z}_3\) (because the vectors $\mathbf{a}$, $\mathbf{b}$, and 
% $\mathbf{c}$ are fixed by the endpoint conditions but the scalar 
% factors $r$ and $s$ are not), the difference \(\mathbf{z}_2 - 
% \mathbf{z}_1 = \mathbf{c} + s\mathbf{b} - r\mathbf{a}\) and the above 
% becomes
% \begin{equation} \label{Eq:rs-kant-energi}
%   3\int_0^2 v(t)^2 \, \mathit{dt} =
%   4r^2 \mathbf{a}^2 + 4s^2\mathbf{b}^2 + 2 \mathbf{c}^2 +
%   2s \langle\mathbf{b},\mathbf{c}\rangle 
%   - 2r \langle\mathbf{a},\mathbf{c}\rangle
%   \text{.}
% \end{equation}
% 
% Thus far, things are pretty easy, but that is just one term of 
% \eqref{Eq:Kant-energi}. There is also a trivial term \(\int_0^2 v_0^2
% \,\mathit{dt} = 2 v_0^2\) and a term
% \begin{equation*}
%   \int_0^2 -2 v_0 v(t) \,\mathit{dt} =
%   -2 v_0 \int_0^2 \sqrt{ \bigl< \mathbf{v}(t), \mathbf{v}(t) \bigr> }
%     \,\, \mathit{dt}
% \end{equation*}
% which is rather difficult due to the square root. Certainly not 
% impossible---$v(t)^2$ is just a second degree polynomial in $t$, so 
% the primitive function of $v(t)$ can be expressed in terms of 
% elementary functions---but complicated enough to be rather awkward 
% to program. Therefore I prefer to let \(v_0=0\) (certainly in complete 
% disregard of how \eqref{Eq:Kant-energi} was derived, but since this 
% is just a heuristic anyway, I can do whatever I bloody want as long as 
% I am satisfied with the results!), which corresponds to giving the edges 
% zero natural length. This is not a problem in practice, since 
% there will (besides the attraction from the edges) also be repulsive 
% forces between the vertices.
% 
% Continuing with the problem of minimising the edge energy, one finds 
% that \eqref{Eq:rs-kant-energi} has its minimum for
% \begin{equation} \label{Eq:Elastiska-rs}
%   r = \frac{\langle\mathbf{c},\mathbf{a}\rangle}{4 \mathbf{a}^2}
%   \quad\text{and}\quad
%   s = \frac{\langle -\mathbf{c},\mathbf{b}\rangle}{4 \mathbf{b}^2}
%   \text{.}
% \end{equation}
% The following procedure computes corresponding coordinates for the 
% edges.
% 
% 
% \begin{proc}{elastic_edges}
%   The |elastic_edges| procedure computes coordinates for the edges of 
%   a network such that the energy needed to strech it to that form is 
%   minimal. The syntax is
%   \begin{quote}
%     |network::elastic_edges| \word{network-var} \word{type-arr} 
%     \word{min-coeff}\regopt
%   \end{quote}
%   where \word{network-var} and \word{type-arr} are names of variables 
%   in the local context of the caller. The \word{min-coeff}, which 
%   defaults to |0.6|, is a lower bound for the $r$ and $s$ 
%   coefficients which overrides the normal formula 
%   \eqref{Eq:Elastiska-rs}. There is no particular return 
%   value, but the \word{network-var} will be modified.
%   
%   Each edge curve is defined by four points. The two endpoints are 
%   precisely the points where the edge is attached to a vertex, or in 
%   the case of the input\slash output end of a leg, the cut-off point 
%   of that leg. The endpoint tangent lines go through the corresponding 
%   vertex, or in the case of legs, is vertical. This leaves only two 
%   degrees of freedom, for which the values are normally computed 
%   according to \eqref{Eq:Elastiska-rs}, but if either of these fall 
%   below the \word{min-coeff} then that number is used instead for 
%   that coefficient. The reason such a lower bound is useful is that 
%   the $r$ and $s$ computed by the above formulae may well be zero or 
%   negative, and in that case the edge curves would not begin in the 
%   intended direction.
%   \begin{tcl}
%<*pkg>
proc network::elastic_edges {NWvar TAvar {minrs 0.6}} {
   upvar 1 $NWvar NW $TAvar TA
   set n 0
   foreach e [lindex $NW 1] {
      set i [lindex $e 1]
      if {$i>=0} then {
         set j [lsearch -exact -integer [lindex $NW 0 $i 1] $n]
         foreach {a1 a2} [lindex $TA([lindex $NW 0 $i 0]) 1 1 $j]\
           {break}
         set x0 [expr {[lindex $NW 0 $i 3 0] + $a1}]
         set y0 [expr {[lindex $NW 0 $i 3 1] + $a2}]
      } else {
         set a1 0; set a2 1
         set x0 [lindex $NW 2 3 [expr {-$i-1}]]
         set y0 [lindex $NW 2 5]
      }
      set i [lindex $e 0]
      if {$i>=0} then {
         set j [lsearch -exact -integer [lindex $NW 0 $i 1] $n]
         foreach {b1 b2} [lindex $TA([lindex $NW 0 $i 0]) 1 1 $j]\
           {break}
         set x3 [expr {[lindex $NW 0 $i 3 0] + $b1}]
         set y3 [expr {[lindex $NW 0 $i 3 1] + $b2}]
      } else {
         set b1 0; set b2 -1
         set x3 [lindex $NW 2 2 [expr {-$i-1}]]
         set y3 [lindex $NW 2 4]
      }
      set r [expr {(($x3 - $x0) * $a1 + ($y3 - $y0) * $a2) / 
        4 / ($a1*$a1 + $a2*$a2) }]
      if {$r < $minrs} then {set r $minrs}
      set s [expr {-(($x3 - $x0) * $b1 + ($y3 - $y0) * $b2) / 
        4 / ($b1*$b1 + $b2*$b2) }]
      if {$s < $minrs} then {set s $minrs}
      set x1 [expr {$x0 + $r*$a1}]
      set y1 [expr {$y0 + $r*$a2}]
      set x2 [expr {$x3 + $s*$b1}]
      set y2 [expr {$y3 + $s*$b2}]
      while {[llength $e]<5} {lappend e {}}
      lset e 3 [list $x0 $y0 $x1 $y1 $x2 $y2 $x3 $y3]
      lset NW 1 $n $e
      incr n
   }
}
%   \end{tcl}
% \end{proc}
% 
% As a preparation for the problem with the shape of edges with positive 
% natural length, one may consider the integral
% $$
%   \int_0^1 \sqrt{ (\alpha t - \beta)^2 + 1 } \,\,\mathit{dt}
%   \qquad \text{where \(\alpha > 0\),}
% $$
% which (up to a constant factor) is what \( \int_0^1 v(t)\,dt \) boils 
% down to (for a suitable choice of constants $\alpha$ and $\beta$). 
% One finds that
% \begin{align*}
%   \int_0^1 \sqrt{ (\alpha t - \beta)^2 + 1 } \,\,\mathit{dt} ={}& 
%   \left\{ \begin{aligned}
%     \alpha t - \beta ={}& \sinh u \\
%     u ={}& \operatorname{arsinh}( \alpha t - \beta ) \\
%     t ={}& \alpha^{-1} \sinh u + \beta/\alpha \\
%     \frac{\mathit{dt}}{\mathit{du}} ={}& \alpha^{-1} \cosh u
%   \end{aligned} \right\} = \\ ={}&
%   \int_{-\operatorname{arsinh}\beta}^{\operatorname{arsinh}(\alpha-\beta)}
%     \alpha^{-1}\cosh^2 u \, \mathit{du} = \\ ={}&
%   \int_{-\operatorname{arsinh}\beta}^{\operatorname{arsinh}(\alpha-\beta)}
%     \tfrac{1}{2\alpha}\cosh(2u) + \tfrac{1}{2\alpha} \, \mathit{du} 
%     = \\ ={}&
%   \biggl[ \frac{1}{4\alpha} \sinh(2u) + \frac{u}{2\alpha} \biggr]
%     _{u = \operatorname{arsinh}\beta}
%     ^{u = \operatorname{arsinh}(\alpha-\beta)}
%     = \\ ={}&
%   \biggl[ \frac{1}{2\alpha} \sinh u \cosh u + \frac{u}{2\alpha} \biggr]
%     _{u = \operatorname{arsinh}\beta}
%     ^{u = \operatorname{arsinh}(\alpha-\beta)}
%     = \\ ={}&
%   \frac{1}{2\alpha} \Bigl(
%     (\alpha-\beta) \sqrt{ (\alpha-\beta)^2 + 1 } + 
%     \operatorname{arsinh}(\alpha-\beta)
%     \\ & \quad{} - 
%     \beta\sqrt{\beta^2 + 1} -
%     \operatorname{arsinh}\beta
%   \Bigr)
%     = \\ ={}&
%   \frac{1}{2\alpha} \biggl(
%     (\alpha-\beta) \sqrt{ (\alpha-\beta)^2 + 1 } 
%     - \beta\sqrt{\beta^2 + 1}
%     \\ & \quad{}
%     + \operatorname{arsinh} \left( 
%       (\alpha-\beta) \sqrt{\beta^2 + 1} 
%       - \beta \sqrt{ (\alpha-\beta)^2 + 1 } 
%     \right)
%   \biggr)
% \end{align*}
% 
% ---
% 
% Since it in this case is not possible to give a closed form formula 
% for the curve with minimal energy, it would be most convenient to seek 
% such solutions iteratively, as part of the same process which finds 
% equilibrium positions for the vertices.
% 
% 
% \subsection{Moving vertices}
% 
% In the model used here, there are three kinds of forces acting on the 
% vertices. The first kind is the elastic attraction edges exert on 
% adjacent vertices. The second kind is a kind of ``electrostatic 
% repulsion'' (force proportional to the inverse square of the distance) 
% between pairs of vertices, regardless of whether they are adjacent or 
% not. The net effect of these two forces is that vertices should tend to 
% move apart, unless they are adjacent.
% 
% The third force is also a kind of electrostatic repulsion, but this is 
% between a vertex and one of the two ``boundary lines'' to which the 
% legs are attached. The fact that this line is infinite in both 
% directions makes it different from the vertex--vertex force in two 
% ways: it only acts in the $y$ direction and it is proportional to the 
% inverse of the distance.
% 
% The model also allows the boundary lines to move, since a fixed height 
% may well result in the network coming out unnaturally squashed or 
% elongated. Here there are two forces acting: electrostatic repulsion 
% vertex--boundary and a normal spring force between the midpoints of 
% the boundaries. The first force was described above. (One might expect 
% that there should also be an electrostatic repulsion between the 
% boundaries, but it sort of makes sense to assume that this should be 
% constant, and then it can anyway be modelled as a slightly different 
% natural length for the spring.) The midpoints that the spring force 
% should be with respect to are the midpoints of the segments of the 
% boundaries that are between the first and last legs on either side. 
% This introduces an $x$ direction component that tries to center the 
% network inputs and outputs with respect to each other.
% 
% Then there is of course the matter of how to model friction. The model 
% used here is simply the Aristothelian approach that \emph{velocity} 
% rather than acceleration is proportional to force, i.e.,
% \begin{equation*}
%   \mathbf{F} = m \mathbf{v} \text{,}
% \end{equation*}
% although there will (at least initially) not be any explicit masses in 
% the model, so it is rather \(\mathbf{v} = \mathbf{F}\). 
% Electrostatic forces are given by
% \begin{align}
%   \mathbf{F}_{vv} ={}& -c_1\lvert\mathbf{r}\rvert^{-3} \mathbf{r} \\
%   \mathbf{F}_{vb} ={}& (0,-c_2/\mathit{\Delta y})
% \end{align}
% where $\mathbf{r}$ is a vector from one vertex to another, 
% $\mathit{\Delta y}$ is the $y$ distance from a vertex to a boundary, 
% and $c$ is a constant giving the strength of the force.
% 
% Edge forces are a bit trickier. Basically the force is \(-\nabla W\), 
% where
% \begin{equation}
%   W =
%   4q^2 \mathbf{a}^2 + 4s^2\mathbf{b}^2 + 2 \mathbf{c}^2 +
%   2s \langle\mathbf{b},\mathbf{c}\rangle 
%   - 2q \langle\mathbf{a},\mathbf{c}\rangle
% \end{equation}
% and the auxiliary quantities $\mathbf{c}$, $q$, and $s$ are given by
% \begin{align*}
%   \mathbf{c} ={}& \mathbf{r} - \mathbf{a} + \mathbf{b} 
%   \text{,}\\
%   q ={}& \max\biggl\{ 
%     \frac{\langle\mathbf{c},\mathbf{a}\rangle}{4 \mathbf{a}^2},
%     q_0 \biggr\} 
%   \text{,}\\
%   s ={}& \max\biggl\{ 
%     \frac{\langle -\mathbf{c},\mathbf{b}\rangle}{4 \mathbf{b}^2},
%     q_0 \biggr\}
%   \text{.}
% \end{align*}
% It follows that
% \begin{align*}
%   \nabla W ={}&
%   8q \mathbf{a}^2 \nabla q + 
%   8s \mathbf{b}^2 \nabla s + 
%   4 \mathbf{c} +
%   2 \langle\mathbf{b},\mathbf{c}\rangle \nabla s + 2s \mathbf{b}
%   - 2 \langle\mathbf{a},\mathbf{c}\rangle \nabla q - 2q \mathbf{a} 
%     \\ ={}&
%   4 \mathbf{c}
%   + 2 \bigl( 4\mathbf{a}^2 q - \langle\mathbf{a},\mathbf{c}\rangle 
%     \bigr) \nabla q 
%   - 2q \mathbf{a}
%   + 2 \bigl( 4 \mathbf{b}^2 s + \langle\mathbf{b},\mathbf{c}\rangle
%     \bigr) \nabla s
%   + 2s \mathbf{b}
% \end{align*}
% where
% \begin{align*}
%   \nabla q ={}& \begin{cases}
%     \mathbf{0}& \text{if \(q = q_0\),}\\
%     \frac{1}{4 \mathbf{a}^2} \mathbf{a}& \text{otherwise,}
%   \end{cases}
%   &
%   \nabla s ={}& \begin{cases}
%     \mathbf{0}& \text{if \(s = q_0\),}\\
%     -\frac{1}{4 \mathbf{b}^2} \mathbf{b}& \text{otherwise,}
%   \end{cases}
% \end{align*}
% with the net result that the $\nabla q$ and $\nabla s$ terms are 
% always zero. Hence it simplifies to
% \begin{equation} \label{Eq:Kantkraft}
%   \nabla W =  4 \mathbf{r} - (2q+4) \mathbf{a} + (2s+4) \mathbf{b}
%   \text{.}
% \end{equation}
% 
% 
% 
% \begin{proc}{sproing1}
%   The |sproing1| procedure takes a network where vertices and leg-ends 
%   have been assigned coordinates (edge coordinates are ignored) and 
%   computes forces acting on these things in accordance with the 
%   above. It then update the network so that every reference point is 
%   moved in proportion to the force acting on it. The return value is 
%   Euclidian distance in phase space between the old and the new 
%   position of the network; this can be used as a measure of how large 
%   the total movement of the network components was.
%   
%   The syntax is
%   \begin{quote}
%     |network::sproing1| \word{network-var} \word{type-array}
%     \meta{options}
%   \end{quote}
%   where the \meta{options} is a dictionary whose contents serve as 
%   configurations of the calculations, and the \word{network-var} and 
%   \word{type-array} are names in the local context of the caller of 
%   variables containing the network to update and the array defining 
%   the vertex types respectively.
%   
%   The three main option entries are |l0|, |l1|, and |dt|. The |l0| 
%   value is a ``typical vertex radius''. The |l1| value is a desired 
%   natural distance (measured vertex centre to vertex centre) between 
%   two adjacent vertices, i.e., the distance at which the 
%   electrostatic repulsion and edge attraction should be equal. The |dt| 
%   value may be thought of as a time step length; it is the factor by 
%   which the forces are multiplied to produce an actual movement.
%   The default values of |l0|, |l1|, and |dt| are $8$, $30$, and $0.1$ 
%   respectively.
%   
%   There are additional options which can be set, but if they are not 
%   then default values are computed from |l0| and |l1|. From 
%   \eqref{Eq:Kantkraft} it follows that the edge attraction between 
%   two vertices at distance $l_1$ (assuming $\mathbf{r}$, 
%   $\mathbf{a}$, and $\mathbf{b}$ all parallel) is \(4l_1 - 2(2q+4)l_0 = 
%   3l_1 - 6l_0\), whence the strength $c_1$ of vertex--vertex repulsion 
%   should be \(l_1^2(3l_1 -\nobreak 6l_0)\). Edge attraction between 
%   vertex and leg-end is instead $2l_1 - 2l_0$ (since 
%   \(\lvert\mathbf{c}\rvert = l_1-l_0\), not $l_1-2l_0$) and thus the 
%   strength $c_2$ of the vertex--boundary electrostatic repulsion 
%   should be $2l_1(l_1 -\nobreak l_0)$.
%   \begin{tcl}
proc network::sproing1 {NWvar TAvar args} {
   upvar 1 $NWvar NW $TAvar TA
   array set CFG {q0 0.6 l1 30 l0 8 dt 0.1}
   array set CFG $args
   if {![info exists CFG(c1)]} then {
      set CFG(c1) [expr {$CFG(l1)*$CFG(l1)*(3*$CFG(l1)-6*$CFG(l0))}]
   }
   if {![info exists CFG(c2)]} then {
      set CFG(c2) [expr {$CFG(l1)*2*($CFG(l1)-$CFG(l0))}]
   }
%   \end{tcl}
%   The |Fx| and |Fy| arrays are used for storing $x$- and 
%   $y$-components respectively of the forces acting on various items. 
%   The entries corresponding to vertices have integer indices. The 
%   entries for the input and output boundry line midpoints have index 
%   |in| and |out| respectively. The first step is to initialise this 
%   array to all zero. It also does a sanity check of the boundary line 
%   positions and if this is not already the case moves them to positions 
%   that are outside those used for the vertices.
%   \begin{tcl}
   set Fx(in)  0.0;  set Fy(in)  0.0
   set Fx(out) 0.0;  set Fy(out) 0.0
   set ymin infinity; set ymax #
   for {set i 0} {$i < [llength [lindex $NW 0]]} {incr i} {
      set Fx($i) 0.0;  set Fy($i) 0.0
      if {[lindex $NW 0 $i 3 1]>$ymax} then {set ymax [lindex $NW 0 $i 3 1]}
      if {[lindex $NW 0 $i 3 1]<$ymin} then {set ymin [lindex $NW 0 $i 3 1]}
   }
   if {[lindex $NW 2 4] - 2*$CFG(l0) < $ymax} then {
      lset NW 2 4 [expr {$ymax + 2*$CFG(l0)}]
   }
   if {[lindex $NW 2 5] + 2*$CFG(l0) > $ymin} then {
      lset NW 2 5 [expr {$ymin - 2*$CFG(l0)}]
   }
%   \end{tcl}
%   The second step is to compute the edge forces.
%   \begin{tcl}
   set n 0
   foreach e [lindex $NW 1] {
      set k [lindex $e 0]
      if {$k >= 0} then {
         set v [lindex $NW 0 $k]
         foreach {rx ry} [lindex $v 3] break
         set i [lsearch -exact -integer [lindex $v 1] $n]
         foreach {bx by} [lindex $TA([lindex $v 0]) 1 1 $i] {break}
      } else {
         set rx [lindex $NW 2 2 [expr {-$k-1}]]
         set ry [lindex $NW 2 4]
         set bx 0.0
         set by -1.0
         set k out
      }
      set l [lindex $e 1]
      if {$l >= 0} then {
         set v [lindex $NW 0 $l]
         set rx [expr {$rx - [lindex $v 3 0]}]
         set ry [expr {$ry - [lindex $v 3 1]}]
         set i [lsearch -exact -integer [lindex $v 1] $n]
         foreach {ax ay} [lindex $TA([lindex $v 0]) 1 1 $i] {break}
      } else {
         set rx [expr {$rx - [lindex $NW 2 3 [expr {-$l-1}]]}]
         set ry [expr {$ry - [lindex $NW 2 5]}]
         set ax 0.0
         set ay 1.0
         set l in
      }
      set q [expr {
        ($ax * ($rx - $ax + $bx) + $ay * ($ry - $ay + $by))
        /
        (4 * ($ax*$ax + $ay*$ay))
      }]
      if {$q<$CFG(q0)} then {set q $CFG(q0)}
      set s [expr {
        -($bx * ($rx - $ax + $bx) + $by * ($ry - $ay + $by))
        /
        (4 * ($bx*$bx + $by*$by))
      }]
      if {$s<$CFG(q0)} then {set s $CFG(q0)}
      set DFx [expr {4*$rx - (2*$q+4)*$ax + (2*$s+4)*$bx}]
      set DFy [expr {4*$ry - (2*$q+4)*$ay + (2*$s+4)*$by}]
      set Fx($l) [expr {$Fx($l) + $DFx}]
      set Fy($l) [expr {$Fy($l) + $DFy}]
      set Fx($k) [expr {$Fx($k) - $DFx}]
      set Fy($k) [expr {$Fy($k) - $DFy}]
% \smallskip
      incr n
   }
%   \end{tcl}
%   The third step is to compute electrostatic forces. This should 
%   probably have safety checks against dividing by zero.
%   \begin{tcl}
   for {set k 0} {$k<[llength [lindex $NW 0]]} {incr k} {
      for {set l 0} {$l<$k} {incr l} {
         set rx [expr {[lindex $NW 0 $l 3 0] - [lindex $NW 0 $k 3 0]}]
         set ry [expr {[lindex $NW 0 $l 3 1] - [lindex $NW 0 $k 3 1]}]
         set r [expr {hypot($rx,$ry)}]
         set r3 [expr {$r*$r*$r}]
         set DFx [expr {$CFG(c1)*$rx/$r3}]
         set DFy [expr {$CFG(c1)*$ry/$r3}]
         set Fx($l) [expr {$Fx($l) + $DFx}]
         set Fy($l) [expr {$Fy($l) + $DFy}]
         set Fx($k) [expr {$Fx($k) - $DFx}]
         set Fy($k) [expr {$Fy($k) - $DFy}]
      }
      set DFy [expr {$CFG(c2) /\
        ([lindex $NW 2 4] - [lindex $NW 0 $k 3 1])}]
      set Fy(out) [expr {$Fy(out) + $DFy}]
      set Fy($k) [expr {$Fy($k) - $DFy}]
      set DFy [expr {$CFG(c2) /\
        ([lindex $NW 2 5] - [lindex $NW 0 $k 3 1])}]
      set Fy(in) [expr {$Fy(in) + $DFy}]
      set Fy($k) [expr {$Fy($k) - $DFy}]
   }
%   \end{tcl}
%   The fourth step computes the spring-like force that seeks to keep 
%   the boundary lines together. It adds a unit distance $l_0$ at which 
%   the force is neutral, but also uses $c_2/l_0$ as a spring constant.
%   \begin{tcl}
   set DFy [expr {
     (([lindex $NW 2 4] - [lindex $NW 2 5]) / $CFG(l1) - 1) * 
     $CFG(c2) / $CFG(l1)
   }]
   set DFx [expr {
     ( ([lindex $NW 2 2 0] + [lindex $NW 2 2 end]) - 
       ([lindex $NW 2 3 0] + [lindex $NW 2 3 end]) ) *
     $CFG(c2) / (2*$CFG(l1)*$CFG(l1))
   }]
   # set Fx(in)  [expr {$Fx(in)  + $DFx}]
   # set Fy(in)  [expr {$Fy(in)  + $DFy}]
   # set Fx(out) [expr {$Fx(out) - $DFx}]
   # set Fy(out) [expr {$Fy(out) - $DFy}]
%   \end{tcl}
%   It might be better to scrap that force altogether and replace it 
%   with a force binding different components of the network together.
%   
%   In the fifth and final step, the coordinates are updated.
%   \begin{tcl}
   set sqres 0.0
   for {set k 0} {$k < [llength [lindex $NW 0]]} {incr k} {
      set Dx [expr {$Fx($k) * $CFG(dt)}]
      set Dy [expr {$Fy($k) * $CFG(dt)}]
      lset NW 0 $k 3 0 [expr {[lindex $NW 0 $k 3 0] + $Dx}]
      lset NW 0 $k 3 1 [expr {[lindex $NW 0 $k 3 1] + $Dy}]
      set sqres [expr {$sqres + $Dx*$Dx + $Dy*$Dy}]
   }
   foreach k {out in} l {2 3} {
      set Dx [expr {$Fx($k) * $CFG(dt)}]
      set Dy [expr {$Fy($k) * $CFG(dt)}]
      set L [list]
      foreach x [lindex $NW 2 $l] {lappend L [expr {$x + $Dx}]}
      lset NW 2 $l $L
      incr l 2
      lset NW 2 $l [expr {[lindex $NW 2 $l] + $Dy}]
      set sqres [expr {$sqres + $Dx*$Dx + $Dy*$Dy}]
   }
   return [expr {sqrt($sqres)}]
}
%   \end{tcl}
% \end{proc}
% 
% Experiments with the above procedure show that the vertex coordinates 
% it produces aren't very pleasing to the eye---in particular there are 
% plenty of contorted edges, which appear not to be penalised at all as 
% much as they should be. Some analysis of the situation indicate that 
% the problem is with the long edges: these exert far too much force 
% and thus deform the rest of the network in an undesirable way. As the 
% above stands, the energy stored in the edges is proportional to the 
% sum of the squares of their lengths, and this implies that the gain 
% from shortening a long edge far outweighs the cost of contorting 
% (which in this respect mostly costs because it lengthens) a short 
% edge.
% 
% The conclusion is thus that there must be an explicit (and probably 
% rather high) cost for contorting edges. The next section tries to 
% address this.
% 
% 
% 
% \subsection{Elastic stiffness}
% 
% Besides the tendency to contract, most elastic objects one encounters 
% in the real world also has a certain resistance towards bending. This 
% can be explained by the fact that the outer edge is longer than the 
% inner edge and the force there thus is stronger; the net effect is a 
% moment that seeks to bend things back.
% 
% To model such an elastic rod, one may replace the earlier parametric 
% curve $\mathbf{r}(t)$ where \(t \in [t_1,t_2]\) by a parametric surface 
% $\mathbf{r}(t,x)$, where \(t \in [t_1,t_2]\) and \(x \in [-d,d]\); $d$ 
% being (half) the thickness of the rod. If it is assumed that all 
% elasticity is in the $t$ direction then it is reasonable to restrict 
% $\mathbf{r}$ to be of the form
% \begin{equation}
%   \mathbf{r}(t,x) = \mathbf{r}(t) + x \mathbf{n}(t)
%   \quad\text{where}\quad
%   \text{\(\mathbf{n}(t)^2 = 1\) and 
%   \(\bigl< \mathbf{r}'(t), \mathbf{n}(t) \bigr> = 0\).}
% \end{equation}
% Letting \(\mathbf{v}(t,x) = \frac{\partial \mathbf{r}}{\partial 
% t}(t,x)\) and \(\mathbf{v}(t) = \mathbf{v}(t,0) = \mathbf{r}'(t)\), 
% one has that
% \begin{equation} \label{Eq:Stavutdragning}
%   \bigl\vert \mathbf{v}(t,x) \bigr\vert^2 = 
%   \bigl\vert \mathbf{r}'(t) + x \mathbf{n}'(t) \bigr\vert^2 = 
%   \mathbf{v}(t)^2 + 
%     2x \bigl< \mathbf{v}(t), \mathbf{n}'(t) \bigr> + 
%     x^2 \mathbf{n}'(t)^2
%   \text{.}
% \end{equation}
% 
% In order to get anywhere with this, it is useful to introduce the 
% \emph{curvature} $\kappa(t)$, defined by
% \begin{equation}
%   \kappa(t) = 
%   \frac{ \bigl< \mathbf{v}'(t), \mathbf{n}(t) \bigr> }{
%     \mathbf{v}(t)^2
%   } \text{;}
% \end{equation}
% this is equivalent to the (perhaps more common) definition with 
% $\bigl\vert \mathbf{v}(t) \times\nobreak \mathbf{v}'(t) \bigr\vert$ 
% since $\mathbf{n}(t)$ is perpendicular to $\mathbf{v}(t)$ and all 
% vectors are in the same plane. Differentiating 
% \(\bigl< \mathbf{v}(t), \mathbf{n}(t) \bigr> = 0\) yields 
% \(\bigl< \mathbf{v}(t), \mathbf{n}'(t) \bigr> =
% -\bigl< \mathbf{v}'(t), \mathbf{n}(t) \bigr> = 
% -\mathbf{v}(t)^2 \kappa(t)\). Differentiating \(\mathbf{n}(t)^2 = 
% 1\) yields \(2\bigl< \mathbf{n}(t), \mathbf{n}'(t) \bigr> = 0\), 
% and hence $\mathbf{n}'(t)$ is parallel to $\mathbf{v}(t)$. 
% Furthermore
% $$
%   \mathbf{v}(t)^2 \mathbf{n}'(t)^2 =
%   \bigl< \mathbf{v}(t), \mathbf{n}'(t) \bigr>^2 =
%   \bigl< \mathbf{v}'(t), \mathbf{n}(t) \bigr>^2 =
%   \bigl( \mathbf{v}(t)^2 \kappa(t) \bigr)^2
%   \text{,}
% $$
% from which follows \(\mathbf{n}'(t)^2 = \mathbf{v}(t)^2 
% \kappa(t)^2\). \eqref{Eq:Stavutdragning} simplifies to
% \begin{multline*}
%   \mathbf{v}(t,x)^2 =
%   \mathbf{v}(t)^2 + 
%     2x \bigl< \mathbf{v}(t), \mathbf{n}'(t) \bigr> + 
%     x^2 \mathbf{n}'(t)^2 = \\ =
%   \mathbf{v}(t)^2 - 2x \mathbf{v}(t)^2 \kappa(t) +
%     x^2 \mathbf{v}(t)^2 \kappa(t)^2 = 
%   \mathbf{v}(t)^2 \bigl( 1 - x \kappa(t) \bigr)^2
%   \text{.}
% \end{multline*}
% 
% The situation that \(d \bigl\vert\kappa(t)\bigr\vert \geqslant 1\) 
% is rather unphysical, since it corresponds to that $\mathbf{r}(t)$ 
% has radius of curvature less than $d$, and thus implies that the rod 
% is so bent that several distinct pieces of it occupy the same 
% physical volume. It therefore seems safe to ignore the possibility 
% that \(1 - x \kappa(t) \leqslant 0\), and thus \emph{define} the 
% relative elongation as
% \begin{equation}
%   \varepsilon(t,x) = 
%   \frac{ \bigl\vert \mathbf{v}(t) \bigr\vert }{ v_0 }
%   \bigl( 1 - x \kappa(t) \bigr) - 1
%   \text{,}
% \end{equation}
% since in a situation where this is the wrong sign, it is far from the 
% only thing that goes wrong in the argument. As before, the argument 
% will mostly be in terms of the energy it takes to deform the rod, which 
% in this case is
% \begin{align*}
%   W ={}& 
%   \int_{t_1}^{t_2} \int_{-d}^d k \varepsilon(t,x)^2 \, 
%     \mathit{dx}\, \mathit{dt} = \\ ={}&
%   k \int_{t_1}^{t_2} \int_{-d}^d  
%     \frac{ \mathbf{v}(t)^2 }{ v_0^2 } \bigl( 1 - 2x \kappa(t) + 
%       x^2 \kappa(t)^2 \bigr)
%     - 2\frac{ \bigl\vert \mathbf{v}(t) \bigr\vert }{ v_0 } 
%       \bigl( 1 - x \kappa(t) \bigr)
%     + 1
%     \, \mathit{dx}\, \mathit{dt} = \\ ={}&
%   k \int_{t_1}^{t_2} 
%     2d \biggl( 
%       \frac{ \bigl\vert \mathbf{v}(t) \bigr\vert }{v_0} - 1
%     \biggr)^2 + 
%     \frac{2d^3}{3} \mathbf{v}(t)^2 \kappa(t)^2
%     \, \mathit{dt}
%   \text{,}
% \end{align*}
% where the first term is essentially the same as in 
% \eqref{Eq:ElastiskEnergi}, the $x$ terms have disappeared (due to 
% that $x$ is odd and the integration interval symmetric), and the $x^2$ 
% terms have made up the last term, which apparently accounts for the 
% stiffness of the rod.
% 
% Taking this term in isolation, basic problem is to determine 
% \(\int_0^1 \mathbf{v}(t)^2 \kappa(t)^2 \,\mathit{dt}\) when 
% $\mathbf{v}(t)$ is of the form $B_1(\mathbf{v}_0,\mathbf{v}_1;t)$. 
% Since
% \begin{equation*}
%   \mathbf{v}(t)^2 \kappa(t)^2 = 
%   \mathbf{v}(t)^2 \frac{ 
%     \bigl\vert \mathbf{v}'(t) \times \mathbf{v}(t) \bigr\vert^2
%   }{ \bigl\vert \mathbf{v}(t) \bigr\vert^6 } =
%   \frac{ 
%     \Bigl\vert (\mathbf{v}_1 - \mathbf{v}_0) \times 
%       \bigl( \mathbf{v}_0 + t (\mathbf{v}_1 - \mathbf{v}_0) \bigr)
%     \Bigr\vert^2
%   }{ \bigl( \mathbf{v}(t)^2 \bigr)^2 } = 
%   \frac{ \lvert \mathbf{v}_1 \times \mathbf{v}_0 \rvert^2 }{ 
%     \bigl( \mathbf{v}(t)^2 \bigr)^2
%   }
% \end{equation*}
% this mostly reduces to the problem of integrating $\bigl( 
% \mathbf{v}(t)^2 \bigr)^{-2}$: a perfectly standard rational integral 
% where the denominator does not have any real zeros. Clearly
% \begin{equation*}
%   \mathbf{v}(t)^2 = 
%   \bigl( \mathbf{v}_0 + t (\mathbf{v}_1 - \mathbf{v}_0) \bigr)^2 =
%   (\mathbf{v}_1 - \mathbf{v}_0)^2 t^2 + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle t +
%     \mathbf{v}_0^2
% \end{equation*}
% and therefore a suitable \emph{ansatz} is, by Hermite's method,
% \begin{multline*}
%   \int \frac{ \lvert \mathbf{v}_1 \times \mathbf{v}_0 \rvert^2
%     }{ \bigl( (\mathbf{v}_1 - \mathbf{v}_0)^2 t^2 + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle t +
%     \mathbf{v}_0^2 \bigr)^2 } \, \mathit{dt} = \\ =
%   \frac{ a t + b }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 t^2 + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle t +
%     \mathbf{v}_0^2 } + \\ +
%   \int \frac{c}{ (\mathbf{v}_1 - \mathbf{v}_0)^2 t^2 + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle t +
%     \mathbf{v}_0^2 } \, \mathit{dt}
%   \text{.}
% \end{multline*}
% Differentiating leads to the equation
% \begin{multline*}
%   \lvert \mathbf{v}_1 \times \mathbf{v}_0 \rvert^2 = (a+c) \bigl( (\mathbf{v}_1 - \mathbf{v}_0)^2 t^2 + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle t +
%     \mathbf{v}_0^2 \bigr)  \\ -
%   (at+b) \bigl( 2 (\mathbf{v}_1 - \mathbf{v}_0)^2 t + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle \bigr)
% \end{multline*}
% in which the coefficients of $t^2$, $t$, and $1$ can be separated to 
% yield
% \begin{align*}
%   0 ={}& (\mathbf{v}_1 - \mathbf{v}_0)^2 (a+c) -
%        2 (\mathbf{v}_1 - \mathbf{v}_0)^2 a \\
%   0 ={}& 2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle 
%        (a+c) - 2 (\mathbf{v}_1 - \mathbf{v}_0)^2 b - 
%        2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle a
%        \\
%   \lvert \mathbf{v}_1 \times \mathbf{v}_0 \rvert^2 ={}& 
%     \mathbf{v}_0^2 (a+c) - 
%      2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle b
%     \text{.}
% \end{align*}
% The first of these is satisfied whenever \(a=c\). Identifying these 
% reduces the latter equations to
% \begin{align*}
%   0 ={}& 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle a
%     - 2 (\mathbf{v}_1 - \mathbf{v}_0)^2 b \\
%   \lvert \mathbf{v}_1 \times \mathbf{v}_0 \rvert^2 ={}& 
%      2 \mathbf{v}_0^2 a - 
%        2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle b
%     \text{,}
% \end{align*}
% in which it is natural to let \(b = 
% a \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle \bigl/ 
% (\mathbf{v}_1 - \mathbf{v}_0)^2\). With that, and writing $\theta$ for 
% the angle from $\mathbf{v}_0$ to $\mathbf{v}_1$,
% \begin{align*}
%   a ={}&
%   \lvert \mathbf{v}_1 \times \mathbf{v}_0 \rvert^2
%   \left( 2 \mathbf{v}_0^2 - \frac{ 
%     \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle^2
%   }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 } \right)^{-1}
%     = \\ ={}&
%   \frac{
%     \tfrac{1}{2} \bigl( 
%       \lvert\mathbf{v}_1\rvert \lvert\mathbf{v}_0\rvert \sin\theta
%     \bigr)^2
%     (\mathbf{v}_1 - \mathbf{v}_0)^2
%   }{
%     \mathbf{v}_0^2 \bigl( \mathbf{v}_0^2 - 
%       2 \langle\mathbf{v}_0,\mathbf{v}_1\rangle + \mathbf{v}_1^2 \bigr)
%     - \bigl( \langle\mathbf{v}_0,\mathbf{v}_1\rangle - 
%       \mathbf{v}_0^2 \bigr)^2
%   }
%     = \\ ={}&
%   \frac{
%     \tfrac{1}{2}(\mathbf{v}_1 - \mathbf{v}_0)^2 \mathbf{v}_0^2 
%     \mathbf{v}_1^2 (1-\cos^2\theta)
%   }{
%     \mathbf{v}_0^2 \mathbf{v}_1^2 - 
%     \langle\mathbf{v}_0,\mathbf{v}_1\rangle^2
%   } = 
%   \tfrac{1}{2}(\mathbf{v}_1 - \mathbf{v}_0)^2
%     \text{,}\\
%   b ={}& \tfrac{1}{2} \bigl( \langle\mathbf{v}_0,\mathbf{v}_1\rangle -
%     \mathbf{v}_0^2 
%   \bigr) \text{.}
% \end{align*}
% Hence
% \begin{multline*}
%   \left[
%     \frac{ a t + b }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 t^2 + 
%     2 \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle t +
%     \mathbf{v}_0^2 }
%   \right]_{t=0}^{t=1} 
%   = \\ =
%   \frac{ 
%     \tfrac{1}{2}(\mathbf{v}_1 - \mathbf{v}_0)^2 + 
%     \tfrac{1}{2} \langle\mathbf{v}_0,\mathbf{v}_1\rangle -
%     \tfrac{1}{2} \mathbf{v}_0^2 
%   }{ \mathbf{v}_1^2 } -
%   \frac{
%     \tfrac{1}{2} \langle\mathbf{v}_0,\mathbf{v}_1\rangle -
%     \tfrac{1}{2} \mathbf{v}_0^2 
%   }{ \mathbf{v}_0^2 }
%   = \\ =
%   \frac{ \mathbf{v}_1^2 - \langle\mathbf{v}_0,\mathbf{v}_1\rangle }
%     {2 \mathbf{v}_1^2} +
%   \frac{ \mathbf{v}_0^2 - \langle\mathbf{v}_0,\mathbf{v}_1\rangle }
%     {2 \mathbf{v}_0^2}
%   =
%   1 - \langle\mathbf{v}_0,\mathbf{v}_1\rangle \bigl(
%     (2 \mathbf{v}_1^2)^{-1} + (2 \mathbf{v}_0^2)^{-1}
%   \bigr)
%   \text{.}
% \end{multline*}
% 
% The remaining term is of $\arctan$-type, whence it is useful to rewrite 
% it as a square plus the minimal value. $\mathbf{v}(t)^2$ is minimal 
% when its derivative is zero, i.e., for
% \begin{equation*}
%   t = t_{\mathrm{min}} := -\frac{ 
%     \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle 
%   }{ (\mathbf{v}_1 - \mathbf{v}_0)^2}
% \end{equation*}
% and thus the minimal value is
% \begin{equation*}
%   v_{\mathrm{min}}^2 := \mathbf{v}_0^2 - 
%   \frac{ \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle^2
%   }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 } =
%   \frac{
%     \mathbf{v}_0^2 \mathbf{v}_1^2 
%     - \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2
%   }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 }
% \end{equation*}
% which has the alternative interpretation as the square length of the 
% component of $\mathbf{v}_0$ that is perpendicular to $\mathbf{v}_1 - 
% \mathbf{v}_0$. What remains is to find some $\alpha$ such that 
% \(\mathbf{v}(t)^2 = \alpha^2 (t -\nobreak t_{\mathrm{min}})^2 + 
% v_{\mathrm{min}}^2\), but it follows from
% \begin{equation*}
%   \mathbf{v}_0^2 = \mathbf{v}(0)^2 = 
%   \alpha^2 t_{\mathrm{min}}^2 + v_{\mathrm{min}}^2 = 
%   \alpha^2 \biggl( \frac{ 
%     \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle
%   }{ (\mathbf{v}_1 - \mathbf{v}_0)^2} \biggr)^2 + 
%   \mathbf{v}_0^2 - 
%   \frac{ \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle^2
%   }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 }
% \end{equation*}
% that \(\alpha = \lvert \mathbf{v}_1 -\nobreak \mathbf{v}_0 \rvert\). 
% Thus
% \begin{align*}
%   \int_0^1 \frac{c}{\mathbf{v}(t)^2} \,\mathit{dt} ={}&
%   \int_0^1 \frac{ \tfrac{1}{2} \alpha^2 }{ 
%     \alpha^2 (t - t_{\mathrm{min}})^2 + v_{\mathrm{min}}^2
%   } \,\mathrm{dt} = \\ ={}&
%   \frac{\alpha^2}{2 v_{\mathrm{min}}^2} \int_0^1 
%     \Bigl( \bigl( \tfrac{\alpha}{v_{\mathrm{min}}} (t - t_{\mathrm{min}})
%     \bigr)^2 + 1 \Bigr)^{-1} \,\mathit{dt} =
%   \left\{ \begin{aligned}
%     u ={}& \tfrac{\alpha}{v_{\mathrm{min}}} (t - t_{\mathrm{min}}) \\
%     t ={}& t_{\mathrm{min}} + \tfrac{v_{\mathrm{min}}}{\alpha} u
%   \end{aligned} \right\} = \\ ={}&
%   \frac{\alpha^2}{2 v_{\mathrm{min}}^2} 
%     \int_{-t_{\mathrm{min}} \alpha / v_{\mathrm{min}}}
%         ^{(1-t_{\mathrm{min}}) \alpha / v_{\mathrm{min}}}
%       (u^2+1)^{-1} v_{\mathrm{min}}/\alpha \, \mathit{dt} 
%     = \\ ={}&
%   \frac{\alpha}{2 v_{\mathrm{min}}} \Bigl( 
%     \arctan \bigl( (1-t_{\mathrm{min}}) \alpha / v_{\mathrm{min}} 
%       \bigr) +
%     \arctan (t_{\mathrm{min}} \alpha / v_{\mathrm{min}} )
%   \Bigr)
%   \text{.}
% \end{align*}
% There is an addition formula for $\arctan$ which can be used to 
% simplify this further, but it requires some care:
% \begin{equation*}
%   \arctan x + \arctan y = \arctan \frac{x+y}{1-xy} + \begin{cases}
%     0& \text{if \(1-xy>0\),}\\
%     \pi & \text{if \(1-xy<0\) and \(x>0\),}\\
%     -\pi & \text{if \(1-xy<0\) and \(x<0\).}
%   \end{cases}
% \end{equation*}
% Beginning with the denominator, one finds that
% \begin{multline*}
%   1 - (1-t_{\mathrm{min}}) \alpha / v_{\mathrm{min}} \cdot 
%     t_{\mathrm{min}} \alpha / v_{\mathrm{min}} =
%   1 - \biggl( 1 + \frac{ 
%       \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle 
%     }{ (\mathbf{v}_1 - \mathbf{v}_0)^2} \biggr)
%     \frac{ 
%       \mathbf{v}_0^2 - \langle \mathbf{v}_0, \mathbf{v}_1 \rangle 
%     }{ (\mathbf{v}_1 - \mathbf{v}_0)^2}
%     \frac{\alpha^2}{v_{\mathrm{min}}^2}
%     = \\ =
%   1 -
%     \frac{ (\mathbf{v}_1 - \mathbf{v}_0)^2 + 
%       \langle \mathbf{v}_0, \mathbf{v}_1 - \mathbf{v}_0 \rangle 
%     }{ (\mathbf{v}_1 - \mathbf{v}_0)^2} \cdot
%     \frac{ 
%       \mathbf{v}_0^2 - \langle \mathbf{v}_0, \mathbf{v}_1 \rangle 
%     }{ 
%       \frac{
%         \mathbf{v}_0^2 \mathbf{v}_1^2 
%         - \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2
%       }{ (\mathbf{v}_1 - \mathbf{v}_0)^2 }
%     }
%     = \\ =
%   1 -
%     \frac{ \bigl(
%       \mathbf{v}_1^2 - \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%     \bigr) \bigl(
%       \mathbf{v}_0^2 - \langle \mathbf{v}_0, \mathbf{v}_1 \rangle 
%     \bigr) }{ 
%       \mathbf{v}_0^2 \mathbf{v}_1^2 
%       - \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2
%     }
%     = \\ =
%   1 -
%     \frac{ 
%       \mathbf{v}_0^2 \mathbf{v}_1^2
%       - \mathbf{v}_0^2 \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%       - \mathbf{v}_1^2 \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%       + \langle \mathbf{v}_0, \mathbf{v}_1\rangle^2
%     }{ 
%       \mathbf{v}_0^2 \mathbf{v}_1^2  - 
%       \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2
%     }
%     = \\ =
%   \frac{ 
%     \mathbf{v}_0^2 \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%     + \mathbf{v}_1^2 \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%     - 2\langle \mathbf{v}_0, \mathbf{v}_1\rangle^2
%   }{ 
%     \mathbf{v}_0^2 \mathbf{v}_1^2  - 
%     \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2
%   } = 
%   \frac{ 
%     (\mathbf{v}_1 - \mathbf{v}_0)^2 
%     \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%   }{ 
%     \mathbf{v}_0^2 \mathbf{v}_1^2  - 
%     \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2
%   } 
% \end{multline*}
% Indeed, the denominator \emph{will} be negative when the angle 
% between $\mathbf{v}_1$ and $\mathbf{v}_0$ exceeds $\tfrac{\pi}{2}$. 
% On the other hand, this can only happen when $1-t_{\mathrm{min}}$ 
% and $t_{\mathrm{min}}$ have the same sign, and since they are never 
% simultaneously negative, it follows that the correction term is 
% either $0$ or $\pi$, never $-\pi$. Furthermore the numerator in the 
% addition formula is the strictly positive $\alpha/v_{\mathrm{min}}$, 
% and hence it turns out that the addition formula is in this particular 
% case better stated as
% \begin{multline*}
%   \arctan \bigl( (1-t_{\mathrm{min}}) \alpha / v_{\mathrm{min}} 
%       \bigr) +
%     \arctan (t_{\mathrm{min}} \alpha / v_{\mathrm{min}} ) = \\ =
%   \operatorname{arccot} \frac{ 
%     1 - (1-t_{\mathrm{min}}) t_{\mathrm{min}} 
%       \frac{\alpha^2}{v_{\mathrm{min}}^2}
%   }{ \alpha / v_{\mathrm{min}}} =
%   \operatorname{arccot} \frac{ 
%     \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%   }{
%     \sqrt{ \mathbf{v}_0^2 \mathbf{v}_1^2  - 
%     \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2}
%   }
%   \text{,}
% \end{multline*}
% as this avoids the singularity when the sum is $\pi/2$. It does not 
% end there however, since if one introduces the quantities 
% \begin{align*}
%   v_0 ={}& \lvert \mathbf{v}_0 \rvert \text{,} &
%   v_1 ={}& \lvert \mathbf{v}_0 \rvert \text{,} &
%   \theta ={}& 
%     \arccos \frac{ \langle \mathbf{v}_0, \mathbf{v}_1 \rangle }{v_0 v_1}
% \end{align*}
% then
% \begin{equation*}
%   \frac{ 
%     \langle \mathbf{v}_0, \mathbf{v}_1\rangle
%   }{
%     \sqrt{ \mathbf{v}_0^2 \mathbf{v}_1^2  - 
%     \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2}
%   } =
%   \frac{
%     v_0 v_1 \cos\theta
%   }{
%     \sqrt{ v_0^2 v_1^2 - (v_0v_1\cos\theta)^2 }
%   } = 
%   \frac{\cos\theta}{\sin\theta} = \operatorname{cot}\theta
% \end{equation*}
% and furthermore
% \begin{equation*}
%   \frac{\alpha}{2 v_{\mathrm{min}}} =
%   \frac{
%      \mathbf{v}_0^2 -2\langle \mathbf{v}_0, \mathbf{v}_1 \rangle + 
%      \mathbf{v}_1^2 
%   }{
%     2 \sqrt{ \mathbf{v}_0^2 \mathbf{v}_1^2  - 
%     \langle \mathbf{v}_0, \mathbf{v}_1 \rangle^2} 
%   } = 
%   \frac{
%     v_0^2 + v_1^2 - 2v_0v_1 \cos\theta
%   }{
%     2 \sqrt{ v_0^2 v_1^2 - (v_0v_1\cos\theta)^2 }
%   } =
%   \frac{ \frac{v_0}{v_1} + \frac{v_1}{v_0} - 2\cos\theta }{ 
%     2\sin\theta}
%   \text{.}
% \end{equation*}
% Letting \(V = v_0/v_1 + v_1/v_0\), the complete formula for 
% ``stiff energy'' becomes
% \begin{align}
%   W_{\mathrm{stiff}} ={}&
%   \frac{2kd^3}{3} \biggl(
%     1 - v_0 v_1 \cos\theta \tfrac{1}{2}(v_0^{-2} + v_1^{-2})  +
%     \frac{ V - 2\cos\theta }{ 2\sin\theta } \theta
%   \biggr) = \notag \\ ={}&
%   \frac{kd^3}{3} \biggl(
%     2 - V \cos\theta + 
%     ( V - 2\cos\theta ) \frac{ \theta }{ \sin\theta } 
%   \biggr)
%   \text{!}
% \end{align}
% 
% In the \(\theta \rightarrow 0\) limit, \(\theta/\sin\theta 
% \rightarrow 1\) and the entire formula becomes 
% \(W_{\mathrm{stiff}} = kd^3/3 \cdot (2 +\nobreak V) 
% (1 -\nobreak \cos\theta)\); approximately a quadratic function in 
% $\theta$. In the \(\theta \rightarrow \pi\) limit however, 
% \(\theta/\sin\theta \rightarrow \infty\) and the same holds for 
% $W_{\mathrm{stiff}}$. 
% 
% \begin{tcl}
%</pkg>
% \end{tcl}
% 
% In the interest of further examining the behaviour of this function, 
% here is a little gadget that lets one deform a quadratic curve 
% segment and displays the corresponding elastic and stiff energies.
% 
% The first step is to create the necessary widgets.
% \begin{tcl}
%<*graphics&fnctest>
canvas .c -width 150 -height 150 -relief solid -borderwidth 1
pack .c -fill both -expand yes
% \end{tcl}
% This adds two message lines above the canvas.
% \begin{tcl}
label .msgE -justify center -text "Elastic energy:"
pack .msgE -before .c -fill x
label .msgS -justify center -text "Stiff energy:"
pack .msgS -before .c -fill x
% \end{tcl}
% 
% The next step is to draw the curve (a |line| item) and its three 
% control points (|oval| items). These are assigned the tags |curve|, 
% |z0|, |z1|, and |z2| respectively.
% \begin{tcl}
.c create line {10 10 70 30 100 100} -smooth 1 -tags curve
.c create oval {8 8 12 12} -tags z0 -fill red -outline {}
.c create oval {68 38 72 32} -tags z1 -fill red -outline {}
.c create oval {98 98 102 102} -tags z2  -fill red -outline {}
% \end{tcl}
% The control points are the ones that can be directly manipulated; 
% the bindings for the points are responsible for also updating the 
% curve.
% 
% Whenever the curve is updated, the two messages should also be 
% updated. This is handled by the following procedure, which expects the 
% six coordinates of the curve as arguments.
% \begin{tcl}
proc update_energies {x0 y0 x1 y1 x2 y2} {
   set v0 [expr {hypot($x1-$x0,$y1-$y0)}]
   set v1 [expr {hypot($x2-$x1,$y2-$y1)}]
   set ip [expr { ($x2-$x1)*($x1-$x0) + ($y2-$y1)*($y1-$y0) }]
   set We [expr {$v0*$v0 + $ip + $v1*$v1}]
   set costheta [expr {$ip/($v0*$v1)}]
   set theta [expr {acos($costheta)}]
   set V [expr {$v0/$v1 + $v1/$v0}]
   set thetaquot [expr {$theta>0 ? $theta/sin($theta) : 1}]
   set Ws [expr {2 - $V*$costheta + ($V-2*$costheta)*$thetaquot}]
   .msgE configure -text [
      format "Elastic energy: %g" $We
   ]
   .msgS configure -text [
      format "Stiff energy: %g" $Ws
   ]
}
% \end{tcl}
% 
% The middle control point directly changes the corresponding coordinate 
% of the curve.
% \begin{tcl}
proc update_z1 {x1 y1} {
   .c coords z1 [expr {$x1-2}] [expr {$y1-2}] [expr {$x1+2}] [expr {$y1+2}]
   .c coords curve [lreplace [.c coords curve] 2 3 $x1 $y1]
   eval [list update_energies] [.c coords curve]
}
.c bind z1 <B1-Motion> {update_z1 [%W canvasx %x] [%W canvasy %y]}
% \end{tcl}
% 
% The endpoint control points move with the mouse, but they also move 
% |z1| so that the two endpoint tangent directions are preserved.
% \begin{tcl}
proc update_z0 {x y} {
   foreach {x0 y0 x1 y1 x2 y2} [.c coords curve] break
   set v1x [expr {$x2-$x1}];  set v1y [expr {$y2-$y1}]
   set v0x [expr {$x1-$x0}];  set v0y [expr {$y1-$y0}]
   set t [expr {
     ( ($x2-$x)*-$v1y + ($y2-$y)*$v1x ) /
     ( -$v0x*$v1y + $v1x*$v0y )
   }]
   set x1 [expr {$x + $t*$v0x}]
   set y1 [expr {$y + $t*$v0y}]
   .c coords z0 [expr {$x-2}] [expr {$y-2}] [expr {$x+2}] [expr {$y+2}]
   .c coords z1 [expr {$x1-2}] [expr {$y1-2}] [expr {$x1+2}] [expr {$y1+2}]
   .c coords curve $x $y $x1 $y1 $x2 $y2
   update_energies $x $y $x1 $y1 $x2 $y2
}
.c bind z0 <B1-Motion> {update_z0 [%W canvasx %x] [%W canvasy %y]}
proc update_z2 {x y} {
   foreach {x0 y0 x1 y1 x2 y2} [.c coords curve] break
   set v1x [expr {$x2-$x1}];  set v1y [expr {$y2-$y1}]
   set v0x [expr {$x1-$x0}];  set v0y [expr {$y1-$y0}]
   set t [expr {
     ( ($x-$x0)*-$v1y + ($y-$y0)*$v1x ) /
     ( -$v0x*$v1y + $v1x*$v0y )
   }]
   set x1 [expr {$x0 + $t*$v0x}]
   set y1 [expr {$y0 + $t*$v0y}]
   .c coords z2 [expr {$x-2}] [expr {$y-2}] [expr {$x+2}] [expr {$y+2}]
   .c coords z1 [expr {$x1-2}] [expr {$y1-2}] [expr {$x1+2}] [expr {$y1+2}]
   .c coords curve $x0 $y0 $x1 $y1 $x $y
   update_energies $x0 $y0 $x1 $y1 $x $y
}
.c bind z2 <B1-Motion> {update_z2 [%W canvasx %x] [%W canvasy %y]}
%</graphics&fnctest>
% \end{tcl}
% 
% Experiments with this show that the stiffness effect is rather small, 
% but weighting it up is no problem. A larger problem is that the 
% expression for stiff energy appears to have a rather complicated 
% gradient, which means it would be hard to encode in a |sproing| 
% function. It may be that something else entirely is called for.
% 
% \begin{tcl}
%<*pkg>
% \end{tcl}
% 
% 
% \section{Molecular networks}
% \label{Sec:Molecules}
% 
% The molecular approach examined in this section has networks mimicing 
% molecules rather than systems of springs. In most molecules, the 
% relative positions of atoms are given by the orbitals of various 
% binding electrons. Rather than having preferred positions determined 
% by the equilibrium of two distinct forces, there is a single force 
% acting whose potential has a distinct pit in the preferred location. 
% In molecules where the preferred bond angles are conflicting, the 
% angles between atoms are distorted to make it all work, but due to 
% the steepness of the potential pits the distortion is rather small. 
% Hopefully something similar can work here.
% 
% Rather than mimicing the very complex equations that determine the 
% shape of molecules, I will make up an \emph{ad hoc} potential that has 
% the properties I seek. Assuming that the ``bond'' should preferably 
% follow the positive $x$-axis, a rather good candidate turns out to be
% \begin{equation}
%   V(x,y) = \bigl( \ln (x/d) \bigr)^2 + y^2
% \end{equation}
% since this has a unique minimum at $(d,0)$, rapidly increases to 
% infinity as $x \rightarrow 0$ (one must not have two vertices very 
% close to each other), increases as $y$ moves away from $0$, and 
% increases rather slowly as \(x \rightarrow \infty\) although it still 
% tends to infinity. This means long edges will not be penalised as much 
% as bent edges, and too short edges will be penalised rather heavily.
% A problem with this simple function is however that it is only 
% defined for \(x>0\), and there is no natural way of extending it to 
% the \(x<0\) half-plane since it is already ``infinite'' along the 
% entire \(x=0\) axis.
% 
% One way around this problem is to compose the above $V$ by some map 
% from (most of) the plane to half the plane. Since the complex square 
% maps the \(\operatorname{Re} z > 0\) half-plane bijectively to the 
% whole of $\mathbb{C}$ minus the non-positive real axis, the inverse of 
% that seems a suitable map to apply. If \(X = x^2 - y^2\) and \(Y = 2xy\) 
% then
% \begin{align*}
%   x ={}& \sqrt{ \frac{X}{2} + \sqrt{ \frac{X^2}{4} + \frac{Y^2}{4} } }
%     \text{,} &
%   y ={}& Y/2x \text{,}
% \end{align*}
% and thus a suitable energy potential could be
% \begin{equation}
%   W(X,Y) = c_1 \left(
%     \tfrac{1}{2}\ln \left( 
%       \frac{X}{2} + \sqrt{ \frac{X^2}{4} + \frac{Y^2}{4} }
%     \right) - \ln d
%   \right)^2 + c_2 \frac{ Y^2 }{ 2X + 2\sqrt{ X^2  + Y^2 } }
% \end{equation}
% where $c_1$, $c_2$, and $d$ are coefficients that should be subject 
% to further tuning. In particular, one can let \(c_2' = c_2/2\), 
% \(c_1' = c_1/4\), and \(d' = 2d^2\) to simplify the above to
% \begin{equation}
%   W(X,Y) = c_1' \left(
%     \ln \left( X + \sqrt{ X^2 + Y^2 } \right) - \ln d'
%   \right)^2 + c_2' \frac{ Y^2 }{ X + \sqrt{ X^2  + Y^2 } }
%   \text{.}
% \end{equation}
% 
% Forces are as usual given by the gradient of the potential. Thus it 
% is useful to compute
% \begin{align*}
%   \frac{\partial W}{\partial X}(X,Y) ={}&
%   2 c_1' \left(
%     \ln \left( X + \sqrt{ X^2 + Y^2 } \right) - \ln d'
%   \right) \frac{
%     1 + X \big/ \sqrt{ X^2 + Y^2 }
%   }{
%     X + \sqrt{ X^2 + Y^2 }
%   }  \\ &\qquad {} - 
%   c_2'  Y^2 \left( X + \sqrt{ X^2  + Y^2 } \right)^{-2} 
%     \left( 1 + X \big/ \sqrt{ X^2 + Y^2 } \right)
%   \text{,} \\
%   \frac{\partial W}{\partial Y}(X,Y) ={}&
%   2 c_1' \left(
%     \ln \left( X + \sqrt{ X^2 + Y^2 } \right) - \ln d'
%   \right) \frac{
%     Y \big/ \sqrt{ X^2 + Y^2 }
%   }{
%     X + \sqrt{ X^2 + Y^2 }
%   }  \\ &\qquad {} +  
%   c_2' \frac{ 
%     2Y \left( X + \sqrt{ X^2  + Y^2 } \right) - 
%     Y^3 \big/ \sqrt{ X^2 + Y^2 }
%   }{ \left( X + \sqrt{ X^2  + Y^2 } \right)^2 }
%   \text{.}
% \end{align*}
% This is rather straightforward to compute, due to the large number of 
% repeated subexpressions.
% 
% The actual model that will be used is a bit more complicated than 
% this, mainly because of the need to handle edges whose endpoints 
% are not both at the same angle. Rather than being a force acting 
% between vertices, the ``orbital'' force given by the above $W$ will 
% be a force acting between an edge and its endpoint vertices. To that 
% end, each edge will have a ``reference point'' which does not 
% correspond to anything in the graphical representation of the edge, 
% but which will probably often be positioned somewhere near the 
% intersection of the two endpoint tangent lines of the edge curve. 
% This reference point defines two potentials---one for each incident 
% vertex---and exerts force according to these potentials. The positive 
% $X$ axis for these potentials start at the reference point and 
% continue in the negative attachment direction (i.e., towards the 
% position where the vertex should be) of the edge to its endpoint 
% vertex. The $d$ distance is adjusted so that the vertices (in the 
% absense of other forces acting upon them) will be at rest at a given 
% distance $l_1$. This means \(l_1 = 2d\cos\theta\), where $2\theta$ is 
% the minimal angle by which the direction of an edge with the given 
% incidences has to turn.
% 
% 
% 
% \begin{proc}{sproing2}
%   The |sproing2| procedure takes a network where vertices and leg-ends 
%   have been assigned coordinates (edge coordinates are ignored) and 
%   computes forces acting on these things in accordance with the 
%   above. It then update the network so that every reference point is 
%   moved in proportion to the force acting on it. The return value is 
%   Euclidian distance in phase space between the old and the new 
%   position of the network; this can be used as a measure of how large 
%   the total movement of the network components was.
%   
%   The syntax is
%   \begin{quote}
%     |network::sproing2| \word{network-var} \word{type-array}
%     \meta{options}
%   \end{quote}
%   where the \meta{options} is a dictionary whose contents serve as 
%   configurations of the calculations, and the \word{network-var} and 
%   \word{type-array} are names in the local context of the caller of 
%   variables containing the network to update and the array defining 
%   the vertex types respectively.
%   
%   The four main option entries are |c1|, |c2|, |l1|, and |dt|. 
%   The |l1| value is an optimal distance between vertices. The |c1| 
%   and |c2| values are the strengths ($c_1'$ and $c_2'$) of the 
%   force in directions parallel and perpendicular respectively to 
%   its main axis (the $X$-axis). The |dt| value is the factor by which 
%   the force is multiplied before it is used as a movement.
%   
%   The procedure uses the \word{auxiliary data} of the edges to keep 
%   track of the edge force reference points and some other stuff. The 
%   exact specification is found below.
%   \begin{tcl}
proc network::sproing2 {NWvar TAvar args} {
   upvar 1 $NWvar NW $TAvar TA
   array set CFG {l0 32 l1 50 c1 0.25 c2 0.5 c3 1.0 dt 0.1 Lmax 50}
   array set CFG $args
   set CFG(Lmax2) [expr {$CFG(Lmax)*$CFG(Lmax)}]
%   \end{tcl}
%   The |Fx| and |Fy| arrays are used for storing $x$- and 
%   $y$-components respectively of the forces acting on various items. 
%   The indices have the form \meta{type}\meta{number}, where \meta{type} 
%   is |v| (vertex), |e| (edge), |o| (output), or |i| (input) and 
%   \meta{number} is the number index of that item. 
%   The first step is to initialise this array to all zero.
%   \begin{tcl}
   for {set i 0} {$i < [llength [lindex $NW 0]]} {incr i} {
      set Fx(v$i) 0.0;  set Fy(v$i) 0.0
   }
   for {set i 0} {$i < [llength [lindex $NW 1]]} {incr i} {
      set Fx(e$i) 0.0;  set Fy(e$i) 0.0
   }
   for {set i 0} {$i < [llength [lindex $NW 2 0]]} {incr i} {
      set Fx(o$i) 0.0;  set Fy(o$i) 0.0
   }
   for {set i 0} {$i < [llength [lindex $NW 2 1]]} {incr i} {
      set Fx(i$i) 0.0;  set Fy(i$i) 0.0
   }
%   \end{tcl}
%   The second step is to compute the edge forces. This makes use of the 
%   \word{auxiliary data} to (i) keep track of the reference point of 
%   the edge and (ii) cache some position- and option-independent data 
%   that is needed when computing the forces. The structure of the list 
%   is
%   \begin{quote}
%     |orbital| \word{rf-x} \word{rf-y} \word{out-x} \word{out-y} 
%     \word{in-x} \word{in-y} \word{l-factor}
%   \end{quote}
%   \word{rf-x} and \word{rf-y} are the coordinates of the reference 
%   point. \word{out-x} and \word{out-y} are the coordinates of a unit 
%   vector pointing in the direction of the axis for the output vertex. 
%   \word{in-x} and \word{in-y} serve the same purpose for the input 
%   vertex. The \word{l-factor} is the quotient $d/l_1$ for this edge.
%   \begin{tcl}
   set n 0
   foreach e [lindex $NW 1] {
      if {[lindex $e 5 0] ne "orbital"} then {
%   \end{tcl}
%   It is necessary to recompute the auxiliary data. The midpoint 
%   between the vertices is used as approximation of the reference point.
%   \begin{tcl}
         set L [list "orbital" {} {}]
         if {[lindex $e 0] >= 0} then {
            set v [lindex $NW 0 [lindex $e 0]]
            foreach {rx ry} [lindex $v 3] break
            set i [lsearch -exact -integer [lindex $v 1] $n]
            foreach {bx by} [lindex $TA([lindex $v 0]) 1 1 $i] {break}
            set h [expr {hypot($bx,$by)}]
            lappend L [expr {-$bx/$h}] [expr {-$by/$h}]
         } else {
            set rx [lindex $NW 2 2 [expr {-[lindex $e 0]-1}]]
            set ry [lindex $NW 2 4]
            lappend L 0.0 1.0
         }
         if {[lindex $e 1] >= 0} then {
            set v [lindex $NW 0 [lindex $e 1]]
            set rx [expr {$rx + [lindex $v 3 0]}]
            set ry [expr {$ry + [lindex $v 3 1]}]
            set i [lsearch -exact -integer [lindex $v 1] $n]
            foreach {bx by} [lindex $TA([lindex $v 0]) 1 1 $i] {break}
            set h [expr {hypot($bx,$by)}]
            lappend L [expr {-$bx/$h}] [expr {-$by/$h}]
         } else {
            set rx [expr {$rx + [lindex $NW 2 3 [expr {-[lindex $e 1]-1}]]}]
            set ry [expr {$ry + [lindex $NW 2 5]}]
            lappend L 0.0 -1.0
         }
         lset L 1 [expr {$rx/2}]
         lset L 2 [expr {$ry/2}]
         lappend L [expr { sqrt( 0.5/
           (1 - [lindex $L 3]*[lindex $L 5]\
              - [lindex $L 4]*[lindex $L 6]) )
         }]
         while {[llength $e]<6} {
            lappend e {}
         }
         lset e 5 $L
         lset NW 1 $n $e
      }
%   \end{tcl}
%   With the auxiliary data available, the actual forces can be computed. 
%   First for the output vertex, then for the input vertex.
%   \begin{tcl}
      set d [expr {$CFG(l1)*[lindex $e 5 7]}]
      set k [lindex $e 0]
      if {$k >= 0} then {
         foreach {x y} [lindex $NW 0 $k 3] break
         set k "v$k"
      } else {
         set k [expr {-$k-1}]
         set x [lindex $NW 2 2 $k]
         set y [lindex $NW 2 4]
         set k "o$k"
      }
      set X [expr {
        ($x - [lindex $e 5 1])*[lindex $e 5 3] + 
        ($y - [lindex $e 5 2])*[lindex $e 5 4]
      }]
      set Y [expr {
        ($x - [lindex $e 5 1])*-[lindex $e 5 4] + 
        ($y - [lindex $e 5 2])* [lindex $e 5 3]
      }]
%   \end{tcl}
%   The next command is a guard against ending up on the 
%   non-positive $X$-axis in these calculations, where the potential is 
%   undefined. A random $Y$-coordinate in the set \([-1,-\frac{1}{2}] 
%   \cup [\frac{1}{2},1]\) is picked instead of the real one.
%   \begin{tcl}
      if {$X<=0 && abs($Y)<1e-5} then {
         set Y [expr {rand()}]
         if {$Y<0.5} then {set Y [expr {$Y-1}]}
      }
      set h [expr {hypot($X,$Y)}]
      set Xph [expr {$X+$h}]
      set Xph2 [expr {$Xph*$Xph}]
      set f1 [expr {2*$CFG(c1)* log($Xph / (2*$d)) / $Xph}]
      set FX [expr {($f1 - $CFG(c2)*$Y*$Y/$Xph2) * (1+$X/$h)}]
      set FY [expr {$f1*$Y/$h + $CFG(c2)*$Y/$Xph2*(2*$Xph-$Y*$Y/$h)}]
      set DFx [expr {$FX*[lindex $e 5 3] - $FY*[lindex $e 5 4]}]
      set DFy [expr {$FX*[lindex $e 5 4] + $FY*[lindex $e 5 3]}]
      set Fx(e$n) [expr {$Fx(e$n) + $DFx}]
      set Fy(e$n) [expr {$Fy(e$n) + $DFy}]
      set Fx($k) [expr {$Fx($k) - $DFx}]
      set Fy($k) [expr {$Fy($k) - $DFy}]
% \smallskip
      set k [lindex $e 1]
      if {$k >= 0} then {
         foreach {x y} [lindex $NW 0 $k 3] break
         set k "v$k"
      } else {
         set k [expr {-$k-1}]
         set x [lindex $NW 2 3 $k]
         set y [lindex $NW 2 5]
         set k "i$k"
      }
      set X [expr {
        ($x - [lindex $e 5 1])*[lindex $e 5 5] + 
        ($y - [lindex $e 5 2])*[lindex $e 5 6]
      }]
      set Y [expr {
        ($x - [lindex $e 5 1])*-[lindex $e 5 6] + 
        ($y - [lindex $e 5 2])* [lindex $e 5 5]
      }]
      if {$X<=0 && abs($Y)<1e-5} then {
         set Y [expr {rand()}]
         if {$Y<0.5} then {set Y [expr {$Y-1}]}
      }
      set h [expr {hypot($X,$Y)}]
      set Xph [expr {$X+$h}]
      set Xph2 [expr {$Xph*$Xph}]
      set f1 [expr {2*$CFG(c1)* log($Xph / (2*$d)) / $Xph}]
      set FX [expr {($f1 - $CFG(c2)*$Y*$Y/$Xph2) * (1+$X/$h)}]
      set FY [expr {$f1*$Y/$h + $CFG(c2)*$Y/$Xph2*(2*$Xph-$Y*$Y/$h)}]
      set DFx [expr {$FX*[lindex $e 5 5] - $FY*[lindex $e 5 6]}]
      set DFy [expr {$FX*[lindex $e 5 6] + $FY*[lindex $e 5 5]}]
      set Fx(e$n) [expr {$Fx(e$n) + $DFx}]
      set Fy(e$n) [expr {$Fy(e$n) + $DFy}]
      set Fx($k) [expr {$Fx($k) - $DFx}]
      set Fy($k) [expr {$Fy($k) - $DFy}]
% \smallskip
      incr n
   }
%   \end{tcl}
%   The third step is to compute a force that keeps vertices separated 
%   from each other (edge forces can only keep adjacent vertices from 
%   each other). The idea here is to follow an inverse square law at 
%   small distances, but to make the force zero at large distances. The 
%   reason for the former is of course the analogy with electrostatic 
%   force, but also the practical experience that forces should not 
%   increase in strength too fast, because that often produces an ugly 
%   oscillatory movement. The reason for the latter is that vertices 
%   far from each other are visually unrelated and therefore should not 
%   affect each other either.
%   
%   To get the desired effect, a force extent parameter $l_0$ is 
%   introduced. At shorter distances, the force is inverse square. 
%   Between $l_0$ and $1.5l_0$ the force decreases linearly to $0$ (this 
%   gives equal left and right derivatives at \(r=l_0\)), and beyond 
%   that the force is zero.
%   
%   It might however be numerically appropriate to cut off the force if 
%   it is smaller than e.g.\ $10^{-6}$ or greater than $10^6$. In the 
%   low end it might just as well be zero, but in the high end it is 
%   probably a good idea to make it random. (It is theoretically 
%   possible to end up at an equilibrium with two vertices on top of 
%   each other if all forces are deterministic, but not if those 
%   vertices start to move about at random.)
%   
%   \begin{tcl}
   for {set k 0} {$k<[llength [lindex $NW 0]]} {incr k} {
      for {set l 0} {$l<$k} {incr l} {
         set rx [expr {[lindex $NW 0 $l 3 0] - [lindex $NW 0 $k 3 0]}]
         set ry [expr {[lindex $NW 0 $l 3 1] - [lindex $NW 0 $k 3 1]}]
         set r [expr {hypot($rx,$ry)}]
         set rl [expr {$r/$CFG(l0)}]
         set f1 [expr {
            ($rl <= 1) ? (
               $CFG(c3)/($rl*$rl*$r)
            ) : ($rl < 2) ? (
               $CFG(c3)*(2-$rl)*(2-$rl)/$r
            ) : 0
         }]
         set DFx [expr {$rx*$f1}]
         set DFy [expr {$ry*$f1}]
         set Fx(v$l) [expr {$Fx(v$l) + $DFx}]
         set Fy(v$l) [expr {$Fy(v$l) + $DFy}]
         set Fx(v$k) [expr {$Fx(v$k) - $DFx}]
         set Fy(v$k) [expr {$Fy(v$k) - $DFy}]
      }
   }
%   \end{tcl}
%   
%   In the fourth and final step, the coordinates are updated. To 
%   prevent bizarre movements, the |Lmax| option is used as an upper 
%   bound on how far a single item may move.
%   \begin{tcl}
   set sqres 0.0
   for {set k 0} {$k < [llength [lindex $NW 0]]} {incr k} {
      set Dx [expr {$Fx(v$k) * $CFG(dt)}]
      set Dy [expr {$Fy(v$k) * $CFG(dt)}]
      set D2 [expr {$Dx*$Dx + $Dy*$Dy}]
      if {$D2<=$CFG(Lmax2)} then {
         lset NW 0 $k 3 0 [expr {[lindex $NW 0 $k 3 0] + $Dx}]
         lset NW 0 $k 3 1 [expr {[lindex $NW 0 $k 3 1] + $Dy}]
         set sqres [expr {$sqres + $D2}]
      } else {
         set f1 [expr {sqrt($CFG(Lmax2) / $D2)}]
         lset NW 0 $k 3 0 [expr {[lindex $NW 0 $k 3 0] + $Dx*$f1}]
         lset NW 0 $k 3 1 [expr {[lindex $NW 0 $k 3 1] + $Dy*$f1}]
         set sqres [expr {$sqres + $CFG(Lmax2)}]
      }
   }
   for {set k 0} {$k < [llength [lindex $NW 1]]} {incr k} {
      set Dx [expr {$Fx(e$k) * $CFG(dt)}]
      set Dy [expr {$Fy(e$k) * $CFG(dt)}]
      set D2 [expr {$Dx*$Dx + $Dy*$Dy}]
      if {$D2<=$CFG(Lmax2)} then {
         lset NW 1 $k 5 1 [expr {[lindex $NW 1 $k 5 1] + $Dx}]
         lset NW 1 $k 5 2 [expr {[lindex $NW 1 $k 5 2] + $Dy}]
         set sqres [expr {$sqres + $D2}]
      } else {
         set f1 [expr {sqrt($CFG(Lmax2) / $D2)}]
         lset NW 1 $k 5 1 [expr {[lindex $NW 1 $k 5 1] + $Dx*$f1}]
         lset NW 1 $k 5 2 [expr {[lindex $NW 1 $k 5 2] + $Dy*$f1}]
         set sqres [expr {$sqres + $CFG(Lmax2)}]
      }
   }
   set Dy 0
   for {set k 0} {$k < [llength [lindex $NW 2 0]]} {incr k} {
      set Dx [expr {$Fx(o$k) * $CFG(dt)}]
      set Dy [expr {$Dy + $Fy(o$k) * $CFG(dt)}]
      if {$Dx > $CFG(Lmax)} then {
         set Dx $CFG(Lmax)
      } elseif {$Dx < -$CFG(Lmax)} then {
         set Dx [expr {-$CFG(Lmax)}]
      }
      lset NW 2 2 $k [expr {[lindex $NW 2 2 $k] + $Dx}]
      set sqres [expr {$sqres + $Dx*$Dx}]
   }
   if {$Dy > $CFG(Lmax)} then {
      set Dy $CFG(Lmax)
   } elseif {$Dy < -$CFG(Lmax)} then {
      set Dy [expr {-$CFG(Lmax)}]
   }
   lset NW 2 4 [expr {[lindex $NW 2 4] + $Dy}]
   set sqres [expr {$sqres + $Dy*$Dy}]
   set Dy 0
   for {set k 0} {$k < [llength [lindex $NW 2 1]]} {incr k} {
      set Dx [expr {$Fx(i$k) * $CFG(dt)}]
      set Dy [expr {$Dy + $Fy(i$k) * $CFG(dt)}]
      if {$Dx > $CFG(Lmax)} then {
         set Dx $CFG(Lmax)
      } elseif {$Dx < -$CFG(Lmax)} then {
         set Dx [expr {-$CFG(Lmax)}]
      }
      lset NW 2 3 $k [expr {[lindex $NW 2 3 $k] + $Dx}]
      set sqres [expr {$sqres + $Dx*$Dx}]
   }
   if {$Dy > $CFG(Lmax)} then {
      set Dy $CFG(Lmax)
   } elseif {$Dy < -$CFG(Lmax)} then {
      set Dy [expr {-$CFG(Lmax)}]
   }
   lset NW 2 5 [expr {[lindex $NW 2 5] + $Dy}]
   return [expr {sqrt($sqres + $Dy*$Dy)}]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{autosproing}
%   The |autosproing| procedure is an attempt to automate the task of 
%   running |sproing2| many times to produce a nice graphical 
%   arrangement of a network. The syntax is
%   \begin{quote}
%     |network::autosproing| \word{network-var} \word{type-array}
%     \word{redraw-interval} \meta{options}
%   \end{quote}
%   where \word{network-var} and \word{type-array} as usual are names 
%   in the local context of the caller. The \word{redraw-interval} is 
%   the number of milliseconds that must elapse between times that the 
%   network is redrawn; if this is zero then the network will not be 
%   redrawn. The \meta{options} is a dictionary whose contents serve as 
%   configurations of the calculations.
%   
%   \begin{tcl}
proc network::autosproing {NWvar TAvar redraw args} {
   upvar 1 $NWvar NW $TAvar TA
   if {$redraw>0} then {
      variable autosproing [after $redraw\
        [namespace code {::unset autosproing}]]
   }
   set n 0
   set t 0.0
   set t0 0.0
   set s 0.0
   set dt 0.1
   set ads 10.0
   while 1 {
      set ds [eval [list network::sproing2 NW TA dt $dt] $args]
      set t [expr {$t + $dt}]
      set s [expr {$s + $ds}]
      set ads [expr {0.7*$ads + 0.3*$ds}]
      if {$ds*$t<0.1*$s*$dt || $n >= 1000} then {break}
      set dt [expr {1.0/$ads}]
      if {$redraw>0} then {
         update
         if {![info exists autosproing]} then {
            network::elastic_edges NW TA
            network::redrawit NW TA
            set autosproing [after $redraw\
              [namespace code {::unset autosproing}]]
         }
      }
      incr n
   }
   if {$redraw>0} then {
      network::elastic_edges NW TA
      network::redrawit NW TA
   }
   list $n $t $s $ads
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \section{Utility set-up for testing}
% 
% \begin{tcl}
%</pkg>
% \end{tcl}
% The following commands set up a canvas |.c| for drawing networks in. 
% \begin{tcl}
%<*graphics&test>
canvas .c -width 150 -height 150 -relief solid -borderwidth 1
pack .c -fill both -expand yes
% \end{tcl}
% This adds a message line above the canvas.
% \begin{tcl}
label .msg -justify center
pack .msg -before .c -fill x
% \end{tcl}
% This makes the text of the message line specify the mouse coordinates 
% over the canvas.
% \begin{tcl}
bind .c <Motion> {
   .msg configure -text [
      format "X = %%g   Y = %%g" [%W canvasx %x] [%W canvasy %y]
   ]
}
bind .c <Leave> {.msg configure -text ""}
% \end{tcl}
% This makes it possible to ``grab'' the canvas surface by pressing the 
% mouse, so that it moves around with the mouse.
% \begin{tcl}
bind .c <ButtonPress-1> {%W scan mark %x %y}
bind .c <B1-Motion> {%W scan dragto %x %y 1}
%</graphics&test>
% \end{tcl}
% 
% An alternative set-up is to have a design with scrollbars and |grid| 
% geometry management.
% \begin{tcl}
%<*graphics&test2>
scrollbar .hscroll -orient horiz -command {.c xview}
scrollbar .vscroll -command {.c yview}
canvas .c -width 150 -height 150 -relief solid -borderwidth 1\
  -xscrollcommand {.hscroll set} -yscrollcommand {.vscroll set}
label .msg -justify center
grid .msg - -row 0 -column 0 -sticky nswe
grid .c -row 1 -column 0 -sticky nswe
grid .vscroll -row 1 -column 1 -sticky ns
grid .hscroll -row 2 -column 0 -sticky ew
grid rowconfig . 1 -weight 1
grid columnconfig . 0 -weight 1
bind .c <Motion> {
   .msg configure -text [
      format "X = %%g   Y = %%g" [%W canvasx %x] [%W canvasy %y]
   ]
}
bind .c <Leave> {.msg configure -text ""}
bind .c <ButtonPress-1> {%W scan mark %x %y}
bind .c <B1-Motion> {%W scan dragto %x %y 1}
%</graphics&test2>
% \end{tcl}
% A problem with scrollbars is that they will not be active unless one 
% sets a |-scrollregion|, and doing that restricts the area within 
% which it is possible to scroll. For that reason, this is not the 
% primary testing set-up.
% 
% 
% \begin{proc}{repeat&redraw}
%   The |repeat&redraw| procedure automates the task of doing some 
%   sproing and redrawing the network repeatedly some given number of 
%   times. The syntax is
%   \begin{quote}
%     |repeat&redraw| \word{times} \word{delay} \word{network-var}
%     \word{types-var} \word{script}
%   \end{quote}
%   This evaluates the \word{script} and then the two commands
%   \begin{quote}
%     |network::elastic_edges| \word{network-var} \word{types-var}\\
%     |network::redrawit| \word{network-var} \word{types-var}
%   \end{quote}
%   in the global context. Then, if \word{times} is positive, it sets up 
%   an |after| for itself with \word{times} decremented by one. This has 
%   the effect that the \word{script} is evaluated \word{times} times, 
%   with a pause of \word{delay} milliseconds between the evaluations.
%   \begin{tcl}
%<*test>
proc repeat&redraw {times delay NWvar TAvar script {endscript bell}} {
   uplevel #0 $script
   uplevel #0 [list network::elastic_edges $NWvar $TAvar]
   uplevel #0 [list network::redrawit $NWvar $TAvar]
   if {$times>0} then {
      after $delay [list repeat&redraw [expr {$times-1}] $delay\
        $NWvar $TAvar $script $endscript]
   } else $endscript
}
%</test>
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \section{A completion utility}
% \label{Sec:Tillslutning}
% 
% This section contains the implementation of a small utility for 
% computing the completion of a system of substitution rules. To keep 
% things simple, the rules will be pairs
% \begin{quote}
%   \word{left hand side network} \word{right hand side network}
% \end{quote}
% and a substitution system is a list of rules. Thus in particular, the 
% utility can only handle the special case that every element considered 
% has one coefficient equal to $1$ and all other coefficients equal to 
% $0$. Since this is what corresponds most closely to classical term 
% rewriting, it is still of interest.
% 
% \setnamespace{}
% 
% 
% \subsection{User interface}
% 
% The completion procedure is only meant to be semi-automatic; some 
% choices should be left for the user and interaction will therefore be 
% a necessary part of the program. 
% 
% 
% \begin{proc}{new_ambiguity_window}
%   The |new_ambiguity_window| procedure creates a new window in which 
%   one can show an ambiguity and its resolution. There syntax is
%   \begin{quote}
%     |new_ambiguity_window| \word{title}\regopt
%   \end{quote}
%   where \word{title} is a title for the window. The return value is 
%   the name of the |toplevel| created.
%   
%   \begin{variable}{last_ambiguity_window}
%     The |last_ambiguity_window| variable is a number that was used in 
%     the name of the last ambiguity window. It is incremented with 
%     every creation of an ambiguity resolution window.
%     \begin{tcl}
%<*util1>
set last_ambiguity_window 0
%     \end{tcl}
%   \end{variable}
%   The layout of the window created is roughly
%   \begin{center}
%     \begin{tabular}{ccc}
%       \textbf{Left}& \textbf{Top}& \textbf{Right}\\
%       \framebox[0.25\linewidth]{Network $1$\vrule width 0pt
%         height 10ex depth 9ex}&
%         \framebox[0.25\linewidth]{Network $0$\vrule width 0pt 
%         height 10ex depth 9ex}&
%         \framebox[0.25\linewidth]{Network $2$\vrule width 0pt 
%         height 10ex depth 9ex}\\
%       \meta{button}& \meta{message}&\meta{button}
%     \end{tabular}
%   \end{center}
%   where the middle network $0$ is the ambiguity and the flank networks 
%   $1$ and $2$ are things to which it can be reduced. The buttons are 
%   for choosing which of the two that will be made the left hand side 
%   of a new rule.
%   \begin{tcl}
proc new_ambiguity_window {{title {}}} {
   variable last_ambiguity_window
   incr last_ambiguity_window
   set t [toplevel .ambiguity$last_ambiguity_window]
   if {![string length $title]} then {
      set title "Ambiguity $last_ambiguity_window"
   }
   wm title $t $title
   bindtags $t [linsert [bindtags $t] 1 Ambiguity]
   label $t.hl -text "Left"
   label $t.hm -text "Top"
   label $t.hr -text "Right"
   grid $t.hl -row 0 -column 0 -sticky s
   grid $t.hm -row 0 -column 1 -sticky s
   grid $t.hr -row 0 -column 2 -sticky s
   foreach c [list $t.cl $t.cm $t.cr] {
      canvas $c -width 200 -height 400 -relief solid -borderwidth 1\
        -xscrollincrement 1 -yscrollincrement 1
   }
   grid $t.cl -row 1 -column 0 -sticky nswe
   grid $t.cm -row 1 -column 1 -sticky nswe
   grid $t.cr -row 1 -column 2 -sticky nswe
   button $t.bl -text "Reduce" -state disabled
   button $t.br -text "Reduce" -state disabled
   grid $t.bl -row 2 -column 0 -sticky n
   grid $t.br -row 2 -column 2 -sticky n
   label $t.lm -justify center -text {}
   grid $t.lm -row 2 -column 1 -sticky nwe
   grid rowconfigure $t 1 -weight 1
   grid columnconfigure $t 0 -weight 1
   grid columnconfigure $t 1 -weight 1
   grid columnconfigure $t 2 -weight 1
   foreach c [list $t.cl $t.cm $t.cr] {
      bindtags $c [linsert [bindtags $c] 1 Network]
   }
%<*test3>
   bind $t <FocusIn> [list puts stdout "$t got focus."]
   bind $t <FocusOut> [list puts stdout "$t lost focus."]
%</test3>
   return $t
}
%   \end{tcl}
% \end{proc}
% 
% The \describestring[bindtag]{Network}|Network| bindtag is used for 
% all canvases displaying networks. It offers bindings for grabbing the 
% network with the mouse and moving it around.
% \begin{tcl}
bind Network <ButtonPress-1> {%W scan mark %x %y}
bind Network <B1-Motion> {%W scan dragto %x %y 1}
% \end{tcl}
% 
% \begin{arrayvar}{after_id}
%   The |after_id| array is used for storing |after| identifiers which 
%   are related to a particular ambiguity. Every index should have the 
%   name of the toplevel window to which they belong as prefix. It is 
%   recommended that further qualifications use widget names as far as 
%   these are able to distinguish matters, and then use |'| as 
%   delimiter for further separation.
% \end{arrayvar}
% 
% \begin{proc}{ambiguity_cancel}
%   The |ambiguity_cancel| procedure cancels the |after| script(s) for a 
%   toplevel, if there are any. The syntax is
%   \begin{quote}
%     |ambiguity_cancel| \word{toplevel}
%   \end{quote}
%   It is meant to be called from an envent binding, e.g.~|FocusOut|.
%   \begin{tcl}
proc ambiguity_cancel {t} {
   global after_id
   foreach i [array names after_id "${t}*"] {
      after cancel $after_id($i)
      unset after_id($i)
   }
}
%   \end{tcl}
% \end{proc}
% 
% The \describestring[bindtag]{Ambiguity}|Ambiguity| bindtag is used for 
% toplevels displaying ambiguities. It is used for controlling which 
% ambiguity is being processed. An ambiguity whose window loses focus 
% should seize all processing.
% \begin{tcl}
bind Ambiguity <FocusOut> {ambiguity_cancel %W}
% \end{tcl}
% It seems toplevels have a tendency to wander off the screen, so the 
% ambiguity windows can do with a |<Configure>| binding to correct that.
% \begin{tcl}
bind Ambiguity <Configure> {ensure_on_screen %W}
% \end{tcl}
% 
% \begin{proc}{ensure_on_screen}
%   This procedure moves a toplevel to ensure that it is completely on 
%   its screen. The argument is the name of the toplevel.
%   \begin{tcl}
proc ensure_on_screen {w} {
   if {$w ne [winfo toplevel $w]} then {return}
   set extra_width\
     [expr {[winfo vrootwidth $w] - [winfo reqwidth $w]}]
   set extra_height\
     [expr {[winfo vrootheight $w] - [winfo reqheight $w]}]
   set x [winfo rootx $w]
   set y [winfo rooty $w]
   set moved 0
   if {$extra_width > 0 && $x > $extra_width} then {
      set x [expr {$x - $extra_width}]
      set moved 1
   }
   if {$extra_height > 0 && $y > $extra_height} then {
      set y [expr {$y - $extra_height}]
      set moved 1
   }
   if {$moved} then {
      wm geometry $w +${x}+${y}
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{create_controller}
%   The |create_controller| procedure creates a controller window, for 
%   controlling how the processing of ambiguities are run. The syntax is
%   \begin{quote}
%     |create_controller| \word{major-var} \word{minor-var}
%   \end{quote}
%   where \word{major-var} and \word{minor-var} are names of two global 
%   variables which are linked to |entry| widgets.
%   \begin{tcl}
proc create_controller {major_var minor_var} {
   set t [toplevel .controller]
   label $t.ll -text "Left rule:"
   label $t.lr -text "Right rule:"
   entry $t.el -textvariable $minor_var
   entry $t.er -textvariable $major_var
   foreach c [list $t.cl $t.cr] {
      canvas $c -width 200 -height 400 -relief solid -borderwidth 1
      bindtags $c [linsert [bindtags $c] 1 Network]
   }
   grid $t.cl - -row 0 -column 0 -sticky nsew
   grid $t.cr - -row 0 -column 2 -sticky nsew
   grid rowconfigure $t 0 -weight 1
   grid $t.ll -row 1 -column 0 -sticky e
   grid $t.el -row 1 -column 1 -sticky w
   grid $t.lr -row 1 -column 2 -sticky e
   grid $t.er -row 1 -column 3 -sticky w
   foreach i {0 1 2 3} {grid columnconfigure $t $i -weight 1}
   button $t.b_go -text Go
   grid $t.b_go -row 2 -column 3
   button $t.b_next -text Next
   grid $t.b_next -row 2 -column 0
}
%   \end{tcl}
% \end{proc}
% 
% \begin{arrayvar}{Network}
%   The |Network| array is used for storing networks directly associated 
%   with some widget. The indices are widget names (paths). The entries 
%   are the actual networks.
% \end{arrayvar}
% 
% \begin{variable}{type_array_name}
%   The |type_array_name| variable holds the name of a non-local array 
%   that serves as the type array for the vertex types currently occuring 
%   in the network. It is used by e.g.\ those procedures that draw or 
%   redraw networks.
% \end{variable}
% 
% \begin{proc}{display_network}
%   The |display_network| procedure displays a network (assuming 
%   coordinates have been assigned to its elements) in a canvas, taking 
%   care to first undraw a network already being shown there. The syntax 
%   is
%   \begin{quote}
%     |display_network| \word{network} \word{canvas}
%   \end{quote}
%   and the |Network| array entry of this \word{canvas} is used as the 
%   variable that keeps track of the canvas items related to the network.
%   There is no particular return value.
%   \begin{tcl}
proc display_network {NW c} {
   global Network type_array_name
   upvar #0 $type_array_name TA
   if {[info exists Network($c)]} then {
      if {[catch {network::undrawit Network($c)}]} then {
         $c delete all
      }
   }
   set Network($c) $NW
   network::drawit Network($c) TA $c
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{Reduction}
% 
% \begin{variable}{rulesL}
%   The |rulesL| variable contains the current list of reduction rules. 
%   New rules are appended at the end. Rules are never removed.
% \end{variable}
% 
% \begin{variable}{reduce_stats}
%   For the purpose of speeding up the reduction process, the normal 
%   reduction procedure requires an auxilliary table of how often the 
%   various rules have been used just after another rule. This table is 
%   implemented as a list with one elment per rule, where each list 
%   element is a list with the structure
%   \begin{quote}
%     \word{rule no.} \word{after $0$} \word{after $1$} \word{after $2$} 
%     \dots
%   \end{quote}
%   where each \word{after $i$} is the number of times this rule could be 
%   applied following an application of rule $i$. These numbers would be 
%   updated whenever a reduction was made.
%   
%   The table is stored in the variable |reduce_stats|.
% \end{variable}
% 
% 
% \begin{proc}{add_rule}
%   The |add_rule| procedure adds a rule to the list of rules and 
%   extends the table of reduction statistics accordingly. The syntax 
%   is
%   \begin{quote}
%     |add_rule| \word{left hand side} \word{right hand side}
%   \end{quote}
%   where both argumentas are networks, the \word{left hand side} being 
%   the one to use as principal side of the rule. The return value is 
%   the number of the new rule.
%   \begin{tcl}
proc add_rule {left right} {
   global rulesL reduce_stats type_array_name rule_queue
   upvar #0 $type_array_name TA
   cull_rules $left
   set index [llength $rulesL]
   network::clearaux left
   foreach {dx dy} [network::update_bbox left] {break}
   for {set n 0} {$n < [llength [lindex $left 0]]} {incr n} {
      lset left 0 $n 3 0 [expr {[lindex $left 0 $n 3 0] - $dx}]
      lset left 0 $n 3 1 [expr {[lindex $left 0 $n 3 1] - $dy}]
   }
   network::elastic_edges left TA
   lappend rulesL [list $left $right]
   set new_stats [list]
   foreach row $reduce_stats {
      lappend row 0
      lappend new_stats $row
   }
   lappend new_stats\
     [linsert [string repeat " 0" [llength $rulesL]] 0 $index]
   set reduce_stats $new_stats
   lappend rule_queue [list $index [llength [lindex $left 0]]]
   return $index
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{clear_rules}
%   The |clear_rules| procedure clears the lists of rules and statistics 
%   of rules. It takes no arguments.
%   \begin{tcl}
proc clear_rules {} {
   global rulesL reduce_stats rule_base rule_queue
   set rulesL [list]
   set reduce_stats [list]
   set rule_base [list]
   set rule_queue [list]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{cull_rules}
%   The |cull_rules| procedure searches through |reduce_stats| for rules 
%   that are should be removed from active use because their principal 
%   parts can be reduced by another rule. The syntax is
%   \begin{quote}
%     |cull_rules| \word{divisor network}
%   \end{quote}
%   \begin{tcl}
proc cull_rules {NW} {
   global reduce_stats rulesL
   set new_statsL [list]
   foreach row $reduce_stats {
      if {[llength [
         network::searchsub [lindex $rulesL [lindex $row 0] 0] $NW
      ]]} then {
%<test4>         puts stdout "Dropped rule [lindex $row 0]."
      } else {
         lappend new_statsL $row
      }
   }
   set reduce_stats $new_statsL
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{graphic_reduce}
%   The |graphic_reduce| procedure reduces a network one step, if 
%   possible, while updating its graphical appearance on a canvas. The 
%   syntax is
%   \begin{quote}
%     |graphic_reduce| \word{network-var} 
%     \word{canvas} \word{last rule}
%   \end{quote}
%   where \word{network-var} is the name of a
%   variable in the local context of the caller. The \word{network-var} 
%   is assumed to contain a network, which is currently drawn on the 
%   specified \word{canvas}. The procedure will try to reduce the network, 
%   starting with the assumption that \word{last rule} is the number of 
%   the most recently applied rule, and if it succeeds update the 
%   |reduce_stats| variable. In the case of success it will also replace 
%   the network on the canvas by the reduced form.
%   
%   The return value is the number of the rule that was applied, or |-1| 
%   if no rule could be applied. The \word{last rule} upon calling may 
%   be |-1|.
%   
%   \begin{tcl}
proc graphic_reduce {NWvar canvas last} {
   upvar 1 $NWvar NW
   global rulesL reduce_stats type_array_name
   upvar #0 $type_array_name TA
   set reduce_stats\
     [lsort -index [expr {$last+1}] -decreasing -integer $reduce_stats]
   set sites {}
   set i 0
   foreach t $reduce_stats {
      set n [lindex $t 0]
      set sites [network::searchsub $NW [lindex $rulesL $n 0]]
      if {[llength $sites]} then {break}
      incr i
   }
   if {![llength $sites]} then {return -1}
   if {$last>=0} then {
      lset reduce_stats $i [expr {$last+1}]\
        [expr {[lindex $reduce_stats $i [expr {$last+1}]] +1}]
   }
   set NW2 [eval [list network::replace $NW] [lindex $sites 0]\
     [list [lindex $rulesL $n 1]]]
   network::avglex_grid NW2 40 10 20
   network::elastic_edges NW2 TA
   network::undrawit NW
   network::drawit NW2 TA $canvas
   set NW $NW2
   return $n
}
%   \end{tcl}
% \end{proc}
% 
% \begin{arrayvar}{lastrule}
%   The |lastrule| array stores the number of the last reduction rule 
%   that was applied to the network in a particular canvas. The index 
%   is the canvas name (widget path).
% \end{arrayvar}
% 
% \begin{variable}{count_down}
%   The |count_down| variable is used for counting down to zero, in the 
%   delay before automatically closing an ambiguity window.
% \end{variable}
% 
% \begin{proc}{run_reduction}
%   The |run_reduction| procedure runs the step-wise reduction of an 
%   ambiguity, and is meant to be run as an |after| script. The syntax is
%   \begin{quote}
%     |run_reduction| \word{toplevel} \word{mode}
%   \end{quote}
%   where \word{toplevel} is the name of the toplevel window of the 
%   ambiguity. \word{mode} is one of:
%   \begin{enumerate}
%     \item[\texttt{cl}]
%       Reduce network in the left canvas.
%     \item[\texttt{cr}]
%       Reduce network in the right canvas.
%     \item[\texttt{equal}]
%       The left and right networks have been reduced to equal networks. 
%       When |count_down| reaches $0$, the toplevel will be destroyed.
%     \item[\texttt{autoleft}]
%       The left and right networks have been fully reduced, but are not 
%       equal. When |count_down| reaches zero, the left network will be 
%       chosen as the principal part of the new rule manufactured from 
%       this ambiguity.
%     \item[\texttt{autoright}]
%       The left and right networks have been fully reduced, but are not 
%       equal. When |count_down| reaches zero, the right network will be 
%       chosen as the principal part of the new rule manufactured from 
%       this ambiguity.
%     \item[\texttt{incomparable}]
%       The left and right networks have been fully reduced, but for 
%       some reason it was not possible to compare them (currently, this 
%       happens if there are disconnected components). In this case the 
%       user is given three options: reduce left network, reduce right 
%       network, or consider networks as equal.
%       \changes{alpha}{2005/10/29}{Added \texttt{incomparable} mode. 
%         (LH)}
%   \end{enumerate}
%   
%   \begin{tcl}
proc run_reduction {t mode} {
   global after_id lastrule Network count_down
   if {$mode eq "cl"} then {
      set c $t.cl
      if {![info exists Network($c)]} then {
         puts "Expected network for $c, but found none (hickup?)."
         return
      }
      set rule [graphic_reduce Network($c) $c $lastrule($c)]
      if {$rule >= 0} then {
         set lastrule($c) $rule
         set after_id($t) [after 1000 [list run_reduction $t cl]]
         return
      }
      set mode "cr"
   }
   if {$mode eq "cr"} then {
      set c $t.cr
      if {![info exists Network($c)]} then {
         puts "Expected network for $c, but found none (hickup?)."
         return
      }
      set rule [graphic_reduce Network($c) $c $lastrule($c)]
      if {$rule >= 0} then {
         set lastrule($c) $rule
         set after_id($t) [after 1000 [list run_reduction $t cr]]
         return
      }
      set mode "compare"
   }
   if {$mode eq "compare"} then {
      if {[
         catch {network::canonical_form $Network($t.cl) c1} NW1
      ]} then {set mode "incomparable"} elseif {[
         catch {network::canonical_form $Network($t.cr) c2} NW2
      ]} then {set mode "incomparable"}
%   \end{tcl}
%   The networks have now reached their final form, so it now makes 
%   sense to start sproinging them.
%   \begin{tcl}
      network::clearaux Network($t.cl)
      network::clearaux Network($t.cr)
      idle_reschedule $t.cl'sproing [
         list idle_sproing $t.cl 10.0 l0 25
      ]
      idle_reschedule $t.cr'sproing [
         list idle_sproing $t.cr 10.0 l0 25
      ]
      after 50 [list network_refresh $t.cl 50]
      after 50 [list network_refresh $t.cr 50]
%   \end{tcl}
%   Exactly what will be done depends on the networks. If both are equal 
%   then the course of action is obvious. If they are not equal then the 
%   buttons need to be activated, but if one of the network has more 
%   components than the other then it is natural to make the most 
%   disconnected one that which one reduces to.
%   \begin{tcl}
      if {$mode eq "incomparable"} then {
         $t.bl configure -state normal
         $t.br configure -state normal
         destroy $t.lm
         button $t.bm -text "Equal" -state normal -command [
            list rule_ambiguity $t neither
         ]
         grid $t.bm -row 2 -column 1 -sticky n
         return
      } elseif {$NW1 eq $NW2} then {
         set mode "equal"
         set count_down 2
      } else {
         $t.bl configure -state normal
         $t.br configure -state normal
         set count_down 5
         if {$c1 > $c2} then {
            set mode "autoright"
         } elseif {$c1 < $c2} then {
            set mode "autoleft"
         } else {
            return
         }
      }
   }
   switch -- $mode "equal" {
      $t.lm configure -text "Equal! $count_down"
      if {$count_down <= 0} then {
         rule_ambiguity $t neither
         return
      }
   } "autoleft" {
      $t.lm configure -text "<- in $count_down"
      if {$count_down <= 0} then {
         $t.bl invoke
         return
      }
   } "autoright" {
      $t.lm configure -text "-> in $count_down"
      if {$count_down <= 0} then {
         $t.br invoke
         return
      }
   } default {
      error "This shouldn't happen!"
   }
   incr count_down -1
   set after_id($t) [after 1000 [list run_reduction $t $mode]]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{idle_sproing}
%   The |idle_sproing| procedure does a |sproing2| step on a network 
%   in the |Network| array. The syntax is
%   \begin{quote}
%     |idle_sproing| \word{index} \word{ads}
%     \begin{regblock}[\regstar]\word{option} \word{value}\end{regblock}
%   \end{quote}
%   where \word{index} is the index (a canvas name) into |Network| of 
%   the network to operate on and \word{ads} is a weighted average of 
%   the movements from previous spoing steps. \word{ads} is used to 
%   estimate the time step length to use. All remaining arguments are 
%   passed on to |sproing2| as options.
%   
%   After the step, this procedure sets up an |after 0| that calls 
%   itself again with an updated value of \word{ads}. The identifier of 
%   that |after| is stored in the |after_id| array, with a |'sproing| 
%   suffix.
%   \begin{tcl}
proc idle_sproing {index ads args} {
   global type_array_name Network after_id count_down
   upvar 1 $type_array_name TA
   set dt [expr {1.0/$ads}]
   set ds [eval [list network::sproing2 Network($index) TA dt $dt]\
     $args]
   if {$ds>0.8 && $count_down==2} then {set count_down 3}
   set ads [expr {0.7*$ads + 0.3*$ds}]
   idle_reschedule $index'sproing [
      linsert $args 0 idle_sproing $index $ads
   ]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{idle_reschedule}
%   The |idle_reschedule| procedure schedules a command for being 
%   executed later, after an |after 0| and |after idle| loop. The 
%   syntax is
%   \begin{quote}
%     |idle_reschedule| \word{index} \word{script}
%   \end{quote}
%   where \word{script} is the script to execute and \word{index} is 
%   the entry in the |after_id| array where the relevant |after| 
%   identifiers will be kept.
%   \begin{tcl}
proc idle_reschedule {index script} {
   global after_id
   set after_id($index) [after 0 "[list set after_id($index)]\
     \[[list after idle $script]\]"]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{network_refresh}
%   The |network_refresh| procedure computes |elastic_edges| and does a 
%   |redrawit| on a network in the |Network| array, after which it 
%   arranges for itself to be called again |after| some further time.
%   The syntax is
%   \begin{quote}
%     |network_refresh| \word{canvas} \word{delay}
%   \end{quote}
%   where \word{canvas} is the name of the canvas to redraw things in 
%   and \word{delay} is the delay (in milliseconds) to use for |after|.
%   The identifier of that |after| is stored in the |after_id| array, 
%   with a |'refresh| suffix.
%   \begin{tcl}
proc network_refresh {c delay} {
   global type_array_name Network after_id
   upvar 1 $type_array_name TA
   network::elastic_edges Network($c) TA
   network::redrawit Network($c) TA
   set bbox [$c bbox all]
   if {[llength $bbox]} then {
      foreach {xmin ymin xmax ymax} [$c bbox all] {break}
      if {$xmin < [$c canvasx 0]} then {
         $c xview scroll -1 unit
      } elseif {$xmax > [$c canvasx [expr {1+[winfo width $c]}]]} then {
         $c xview scroll 1 unit
      }
      if {$ymin < [$c canvasy 3]} then {
         $c yview scroll -1 unit
      } elseif {$ymax > [$c canvasy [expr {4+[winfo height $c]}]]} then {
         $c yview scroll 1 unit
      }
   }
   set after_id($c'refresh) [after $delay [
      list network_refresh $c $delay
   ]]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Ambiguities}
% 
% \begin{proc}{make_ambiguities}
%   The |make_ambiguities| procedure computes all ambiguities for a 
%   pair of rules and creates windows displaying these and their two 
%   main descendants. The syntax is
%   \begin{quote}
%     |make_ambiguities| \word{rule no.~$1$} \word{rule no.~$2$} 
%     \word{base window}
%   \end{quote}
%   where the two \emph{rule} arguments are rule numbers. The 
%   \word{base window} is used in positioning the new windows.
%   The return value is the list of names of toplevels that were created.
%   
%   The way that the \word{base window}, which should better be visible 
%   when this procedure is called, is used is the following: a 
%   displacement is computed by taking the maximal of the vertical and 
%   horizontal differences between the |winfo root|[|xy|] and the |wm\
%   geometry| coordinates of that \word{base window}. Then the 
%   geometries of the new windows are positioned some multiple of that 
%   displacement from the geometry of the \word{base window}.
%   \begin{tcl}
proc make_ambiguities {rule1 rule2 base_w} {
   global rulesL Network lastrule type_array_name
   upvar #0 $type_array_name TA
   foreach {wm_wh wm_x wm_y} [split [wm geometry $base_w] +] {break}
   set delta_x [expr {abs( [winfo rootx $base_w] - $wm_x )}]
   set delta_y [expr {abs( [winfo rooty $base_w] - $wm_y )}]
   set delta [expr {$delta_x>$delta_y ? $delta_x : $delta_y}]
   set res [list]
   foreach ambiguity [
      network::ambiguities [lindex $rulesL $rule1 0]\
        [lindex $rulesL $rule2 0]
   ] {
      set t [new_ambiguity_window]
      set wm_x [expr {$wm_x + $delta}]
      set wm_y [expr {$wm_y + $delta}]
      wm geometry $t +${wm_x}+${wm_y}
      set Network($t.cm) [lindex $ambiguity 0]
      set Network($t.cl) [
         eval [list network::replace [lindex $ambiguity 0]]\
           [lindex $ambiguity 1] [lrange [lindex $rulesL $rule1] 1 1]
      ]
      set lastrule($t.cl) $rule1
      set Network($t.cr) [
         eval [list network::replace [lindex $ambiguity 0]]\
           [lindex $ambiguity 2] [lrange [lindex $rulesL $rule2] 1 1]
      ]
      set lastrule($t.cr) $rule2
      foreach c [list $t.cm $t.cl $t.cr] {
         network::avglex_grid Network($c) 40 0 20
         network::elastic_edges Network($c) TA
         network::drawit Network($c) TA $c
      }
      $t.bl configure -command [list rule_ambiguity $t left]
      $t.br configure -command [list rule_ambiguity $t right]
      lappend res $t
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% The processing to resolve an ambiguity is initiated by a |<FocusIn>| 
% binding for the \describestring[bindtag]{Ambiguity}|Ambiguity| 
% bindtag. This has the effect that the processing for a network begins 
% anew whenever one switches to an ambiguity window. The delay is 
% needed to allow observing the initial state of the window.
% \begin{tcl}
bind Ambiguity <FocusIn> {
   set after_id(%W) [after 1000 {run_reduction %W cl}]
}
% \end{tcl}
% 
% 
% \begin{proc}{rule_ambiguity}
%   This procedure is called to end an ambiguity by turning it into a 
%   new rule. The syntax is
%   \begin{quote}
%     |rule_ambiguity| \word{toplevel} \word{choice}
%   \end{quote}
%   where \word{toplevel} is the toplevel of the ambiguity and 
%   \word{choice} is |left|, |right|, or |neither| depending on which 
%   network was chosen for the principal part in the rule. The procedure 
%   |destroy|s the ambiguity toplevel.
%   
%   \begin{tcl}
proc rule_ambiguity {t choice} {
   global Network rule_queue
   network::undrawit Network($t.cl)
   network::undrawit Network($t.cr)
   if {$choice eq "left"} then {
%<test4>      puts stdout "Added rule [
      add_rule $Network($t.cl) $Network($t.cr)
%<test4>      ] (left)"
   } elseif {$choice eq "right"} then {
%<test4>      puts stdout "Added rule [
      add_rule $Network($t.cr) $Network($t.cl)
%<test4>      ] (right)"
   }
   ambiguity_cancel $t
   array unset Network $t.c\[lmr\]
   destroy $t
}
%   \end{tcl}
% \end{proc}
% 
% \begin{variable}{rule_queue}
% \begin{variable}{rule_base}
%   The |rule_queue| and |rule_base| are two lists of rule numbers that 
%   are used to select which ambiguities to process next. When rules 
%   are added to the |rulesL|, also an element
%   \begin{quote}
%     \word{rule number} \word{sort key}
%   \end{quote}
%   is appended to the |rule_queue|. When all ambiguities that can be 
%   formed from the rules in the |rule_base| have been examined, the 
%   rule in |rule_queue| that has the smallest \word{sort key} is 
%   removed and that \word{rule number} is instead appended to the 
%   |rule_base|. The remaining ambiguities are then those which have 
%   the new rule on one side and one of the elements in the |rule_base| 
%   on the other.
% \end{variable}\end{variable}
% 
% 
% \begin{variable}{minor_index}
%   The |minor_index| variable stores the index in |rule_base| of the 
%   next rule to form ambiguities by.
% \end{variable}
% 
% 
% \begin{proc}{run_ambiguities}
%   The |run_ambiguities| procedure is the body of an interation in 
%   which the |minor_index| variable is incremented until it reaches the 
%   length of the |rule_base| and then stops, while simultaneously 
%   computing all ambiguities for the current pair of these. The 
%   increment part happens in |minor_step_ambiguities|. What happens here 
%   is that the ambiguity windows (if any) are created and another call 
%   to |minor_step_ambiguity| is arranged for (either via a binding or as 
%   a direct call).
%   \begin{tcl}
proc run_ambiguities {} {
   global rule_base minor_index
   if {[llength [
      make_ambiguities [lindex $rule_base $minor_index]\
        [lindex $rule_base end] .controller
   ]]} then {
      bind .controller <FocusIn> {minor_step_ambiguity}
   } else {
      minor_step_ambiguity
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{minor_step_ambiguity}
%   The |minor_step_ambiguity| procedure increments the |minor_rule| 
%   variable, updates the left network in the controller window, and 
%   arranges for |run_ambiguities| to be called a second later. There 
%   are no arguments, nor any particular return value.
%   \begin{tcl}
proc minor_step_ambiguity {} {
   global minor_index rule_base rulesL minor_rule_no
   bind .controller <FocusIn> {}
   if {[incr minor_index] >= [llength $rule_base]} then {return}
   set minor_rule_no [lindex $rule_base $minor_index]
   display_network [lindex $rulesL $minor_rule_no 0]\
     .controller.cl
   after 1000 {run_ambiguities}
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{major_step_ambiguity}
%   The |major_step_ambiguity| procedure moves one rule from the 
%   |rule_queue| to the |rule_base|, and then resets the |minor_index|. 
%   As part of this, the other rules in the base and queue are checked 
%   for whether their principal parts contain the new rule, and if they 
%   do then they are dropped from these lists and corresponding 
%   ambiguities are prepared to be checked.
%   
%   There are no arguments, nor any particular return value.
%   \begin{tcl}
proc major_step_ambiguity {base_w} {
   global minor_index rule_base rule_queue rulesL Network lastrule\
     type_array_name minor_rule_no major_rule_no
   upvar #0 $type_array_name TA
   if {![llength $rule_queue]} then {return}
   set rule_queue [lsort -dictionary -index 1 $rule_queue]
   set new [lindex $rule_queue 0 0]
   foreach {wm_wh wm_x wm_y} [split [wm geometry $base_w] +] {break}
   set delta_x [expr {abs( [winfo rootx $base_w] - $wm_x )}]
   set delta_y [expr {abs( [winfo rooty $base_w] - $wm_y )}]
   set delta [expr {$delta_x>$delta_y ? $delta_x : $delta_y}]
% \smallskip
   set new_base [list]
   foreach n $rule_base {
      set L [network::searchsub [lindex $rulesL $n 0]\
        [lindex $rulesL $new 0]]
      if {![llength $L]} then {
         lappend new_base $n
         continue
      }
      set t [new_ambiguity_window]
      set wm_x [expr {$wm_x + $delta}]
      set wm_y [expr {$wm_y + $delta}]
      wm geometry $t +${wm_x}+${wm_y}
      set Network($t.cm) [lindex $rulesL $n 0]
      set Network($t.cl) [lindex $rulesL $n 1]
      set lastrule($t.cl) $n
      set Network($t.cr) [
         eval [list network::replace $Network($t.cm)] [lindex $L 0]\
           [list [lindex $rulesL $new 1]]
      ]
      set lastrule($t.cr) $new
      foreach c [list $t.cm $t.cl $t.cr] {
         network::avglex_grid Network($c) 40 0 20
         network::elastic_edges Network($c) TA
         network::drawit Network($c) TA $c
      }
      $t.bl configure -command [list rule_ambiguity $t left]
      $t.br configure -command [list rule_ambiguity $t right]
%<test4>      puts stdout "Removed rule $n from base."
   }
   set rule_base $new_base
   lappend rule_base $new
% \smallskip
   set new_queue [list]
   foreach pair [lrange $rule_queue 1 end] {
      set n [lindex $pair 0]
      set L [network::searchsub [lindex $rulesL $n 0]\
        [lindex $rulesL $new 0]]
      if {![llength $L]} then {
         lappend new_queue $pair
         continue
      }
      set t [new_ambiguity_window]
      set wm_x [expr {$wm_x + $delta}]
      set wm_y [expr {$wm_y + $delta}]
      wm geometry $t +${wm_x}+${wm_y}
      set Network($t.cm) [lindex $rulesL $n 0]
      set Network($t.cl) [lindex $rulesL $n 1]
      set lastrule($t.cl) $n
      set Network($t.cr) [
         eval [list network::replace $Network($t.cm)] [lindex $L 0]\
           [list [lindex $rulesL $new 1]]
      ]
      set lastrule($t.cr) $new
      foreach c [list $t.cm $t.cl $t.cr] {
         network::avglex_grid Network($c) 40 0 20
         network::elastic_edges Network($c) TA
         network::drawit Network($c) TA $c
      }
      $t.bl configure -command [list rule_ambiguity $t left]
      $t.br configure -command [list rule_ambiguity $t right]
%<test4>      puts stdout "Removed rule $n from queue."
   }
   set rule_queue $new_queue
% \smallskip
   set minor_index 0
   set minor_rule_no [lindex $rule_base 0]
   display_network [lindex $rulesL $minor_rule_no 0]\
     .controller.cl
   set major_rule_no [lindex $rule_base end]
   display_network [lindex $rulesL $major_rule_no 0]\
     .controller.cr
}
%   \end{tcl}
% \end{proc}
% 
% \begin{variable}{major_rule_no}
% \begin{variable}{minor_rule_no}
%   These two variables are displayed in the two entry widgets in the 
%   controller window. They should be set when the networks displayed 
%   there change.
%   \begin{tcl}
create_controller major_rule_no minor_rule_no
%   \end{tcl}
% \end{variable}\end{variable}
% 
% 
% Any pending |run_ambiguities| script is cancelled when the controller 
% window loses focus.
% \begin{tcl}
bind .controller <FocusOut> {after cancel {run_ambiguities}}
% \end{tcl}
% 
% Any pending |run_ambiguities| script is cancelled when the controller 
% window loses focus.
% \begin{tcl}
.controller.b_next configure -command {
   major_step_ambiguity .controller
}
.controller.b_go configure -command {run_ambiguities}
% \end{tcl}
% 
% 
% \subsection{A rule browser}
% 
% The following implements a window that allows one to browse the list 
% of rules.
% 
% \begin{proc}{rule_browser_layout}
%   This procedure creates a window for the rule browser and sets up 
%   the widgets that should reside in it. At the top there is a |text| 
%   widget that shows text data about the rule. Below that are two 
%   canvases that show the principal and non-principal parts of the 
%   rule, and an additional canvas that just displays an arrow pointing 
%   right. In addition, the text widget has a vertical scrollbar and 
%   the canvases have horizontal and vertical scroll bars.
%   
%   The geometry is |grid|ded, with five columns (canvas, vscrollbar, 
%   arrow, canvas, vscrollbar) and four rows (control bar, text, canvas, 
%   hscrollbars).
%   
%   \begin{tcl}
proc rule_browser_layout {} {
   set t [toplevel .rulebrowser]
   wm title $t "Rule browser"
%   \end{tcl}
%   First order of business: the network canvases.
%   \begin{tcl}
   foreach c_ [list $t.left_ $t.right_] {
      scrollbar ${c_}h -orient horiz -command [list ${c_}c xview]
      scrollbar ${c_}v -command [list ${c_}c yview]
      canvas ${c_}c -width 200 -height 400 -relief solid -borderwidth 1\
        -xscrollcommand [list ${c_}h set]\
        -yscrollcommand [list ${c_}v set]
      bindtags ${c_}c [linsert [bindtags ${c_}c] 1 Network]
   }
   grid $t.left_c  -row 2 -column 0 -sticky nsew
   grid $t.right_c -row 2 -column 3 -sticky nsew
   grid $t.left_v  -row 2 -column 1 -sticky ns
   grid $t.right_v -row 2 -column 4 -sticky ns
   grid $t.left_h  -row 3 -column 0 -sticky ew
   grid $t.right_h -row 3 -column 3 -sticky ew
   grid rowconfigure $t 2 -weight 1
   grid columnconfigure $t 0 -weight 1
   grid columnconfigure $t 3 -weight 1
%   \end{tcl}
%   Then the arrow canvas \dots
%   \begin{tcl}
   canvas $t.arrow_c -width 20 -height 20
   $t.arrow_c create line {0 10 20 10} -arrow last -width 2
   grid $t.arrow_c -row 2 -column 2
%   \end{tcl}
%   \dots\ and the text widget.
%   \begin{tcl}
   scrollbar $t.text_v -command [list $t.text_t yview]
   text $t.text_t -height 5 -yscrollcommand [list $t.text_v set]
   grid $t.text_t - - - -row 1 -column 0 -sticky nsew
   grid $t.text_v -row 1 -column 4 -sticky ns
%   \end{tcl}
%   The control bar is a frame, into which the individual controls are 
%   packed. Its background has a colour.
%   \begin{tcl}
   set bg grey90
   frame $t.f -background $bg
   grid $t.f - - - - -row 0 -column 0 -sticky ew
   pack [button $t.f.prev -text "Prev" -highlightbackground $bg] -side left
   pack [button $t.f.next -text "Next" -highlightbackground $bg] -side left
   pack [button $t.f.go -text "Go" -highlightbackground $bg] -side right
   pack [entry $t.f.go_e -width 4] -side right
   pack [label $t.f.go_l -text "Rule" -background $bg] -side right
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{display_rule}
%   The |display_rule| procedure updates the rule browser window to 
%   show the specified rule. The syntax is
%   \begin{quote}
%     |display_rule| \word{rule number}
%   \end{quote}
%   
%   \begin{tcl}
proc display_rule {rule} {
   global Network rulesL type_array_name
   upvar #0 $type_array_name TA
   set t .rulebrowser
%
   $t.left_c delete all
   set Network($t.left_c) [lindex $rulesL $rule 0]
   if {[llength [lindex $Network($t.left_c) 1 0]] < 4} then {
      network::elastic_edges Network($t.left_c) TA
   }
   network::drawit Network($t.left_c) TA $t.left_c
   $t.left_c configure -scrollregion [$t.left_c bbox all]
%
   $t.right_c delete all
   set Network($t.right_c) [lindex $rulesL $rule 1]
   if {[llength [lindex $Network($t.right_c) 1 0]] < 4} then {
      network::elastic_edges Network($t.right_c) TA
   }
   network::drawit Network($t.right_c) TA $t.right_c
   $t.right_c configure -scrollregion [$t.right_c bbox all]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Exporting data}
% 
% Thanks to \Tcllogo's principle that \emph{everything is a string}, 
% exporting the entire list of rules is in principle just a 
% |puts $rulesL|, but no-one in their right mind would like to read the 
% rules in that format. Networks should be graphical, so a method which 
% exports them as portable graphics is needed. Luckily, there is PDF.
% 
% \begin{proc}{rule_PDF_page}
%   The |rule_PDF_page| procedure appends a page showing a rule to a PDF 
%   file. The syntax is
%   \begin{quote}
%     |rule_PDF_page| \word{file} \word{label root} \word{page rect} 
%     \word{rule}
%     \begin{regblock}[\regstar]\word{option} \word{value}\end{regblock}
%   \end{quote}
%   where \word{file} is the target PDF file and \word{rule} is the rule 
%   to output. \word{page rect} is the MediaBox rectangle. \word{label 
%   root} is a string to use as root for all PDF object labels generated.
%   The actual graphics for networks are generated using 
%   |network::topdf::write_XObject|, and the options are passed on to 
%   that procedure.
%   
%   There is no particular return value, but a page is shipped out to 
%   the PDF file (thus the pages system must have been initialised).
%   \begin{tcl}
%<*pdf>
proc rule_PDF_page {F root rect rule args} {
   global type_array_name
   upvar #0 $type_array_name TA
   set bbox1 [pdf::standard_rect [eval [linsert $args 0\
     network::topdf::write_XObject $F $root/l [lindex $rule 0] TA]]]
   set bbox2 [pdf::standard_rect [eval [linsert $args 0\
     network::topdf::write_XObject $F $root/r [lindex $rule 1] TA]]]
% \medskip
   pdf::begin_contents "" $F $root/contents
   pdf::name_resource NW1 $F XObject [pdf::obj_ref $F $root/l]
   pdf::name_resource NW2 $F XObject [pdf::obj_ref $F $root/r]
   set margin [pdf::length 1 cm]
   set width_limit [expr {[rect_width $rect] - 2*$margin}]
   set height_limit [expr {0.5*[rect_height $rect] - 1.5*$margin}]
% \smallskip
   set width [rect_width $bbox1]
   set height [rect_height $bbox1]
   set scale 1
   if {$scale*$height > $height_limit} then {
      set scale [expr {$height_limit/$height}]
   }
   if {$scale*$width > $width_limit} then {
      set scale [expr {$width_limit/$width}]
   }
   set dx [expr {[rect_x $rect 0.5] - $scale*[rect_x $bbox1 0.5]}]
   set dy [expr {[rect_y $rect 0.5] + 0.5*$margin -\
     $scale*[rect_y $bbox1 0]}]
   pdf::printf $F {q %r 0 0 %r3 cm %r w %o Do Q} $scale $scale $dx $dy\
     0.5 $NW1
   set max_width [expr {$width*$scale}]
   set top [expr {$dy + $scale*[rect_y $bbox1 1]}]
% \smallskip
   set width [rect_width $bbox2]
   set height [rect_height $bbox2]
   set scale 1
   if {$scale*$height > $height_limit} then {
      set scale [expr {$height_limit/$height}]
   }
   if {$scale*$width > $width_limit} then {
      set scale [expr {$width_limit/$width}]
   }
   set dx [expr {[rect_x $rect 0.5] - $scale*[rect_x $bbox2 0.5]}]
   set dy [expr {[rect_y $rect 0.5] - 0.5*$margin -\
     $scale*[rect_y $bbox2 1]}]
   pdf::printf $F {q %r 0 0 %r3 cm %r w %o Do Q} $scale $scale $dx $dy\
     0.5 $NW2
   set max_width\
     [expr {$width*$scale>$max_width ? $width*$scale : $max_width}]
   set bottom [expr {$dy + $scale*[rect_y $bbox2 0]}]
% \smallskip
   set y [rect_y $rect 0.5]
   set x [expr {[rect_x $rect 0.5] - 0.5*$max_width}]
   pdf::printf $F {0 0 1 RG 1 w %r2 m %r2 l S}\
     $x $y [expr {$x + $max_width}] $y
% \smallskip
   pdf::end_contents Rez $F
   pdf::shipout $F $root\
     /Contents [pdf::obj_ref $F $root/contents]\
     /Resources [pdf::resource_dict_obj Rez]\
     /MediaBox [pdf::rect_obj $rect]\
     /ArtBox [pdf::rect_obj [
       pdf::make_rect -top $top -bottom $bottom -left $x\
         -width $max_width
     ]]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{rect_height}
% \begin{proc}{rect_width}
%   Returns the height and width respectively of a PDF rectangle.
%   \begin{tcl}
proc rect_height {R} {expr {abs([lindex $R 3] - [lindex $R 1])}}
proc rect_width {R} {expr {abs([lindex $R 2] - [lindex $R 0])}}
%   \end{tcl}
% \end{proc}\end{proc}

% \begin{proc}{rect_x}
% \begin{proc}{rect_y}
%   Translates an $x$- or $y$-coorinate respectively given relative to a 
%   PDF rectangle (left and bottom are $0$, right and top are $1$) to 
%   coordinates in the coordinate system used for the rectangle itself.
%   \begin{tcl}
proc rect_x {R t} {expr {(1-$t)*[lindex $R 0] + $t*[lindex $R 2]}}
proc rect_y {R t} {expr {(1-$t)*[lindex $R 1] + $t*[lindex $R 3]}}
%   \end{tcl}
% \end{proc}\end{proc}
% 
% \begin{proc}{write_rules_file}
%   The |write_rules_file| procedure takes a list of rules and writes a 
%   PDF file which presents those rules, one per page. The syntax is
%   \begin{quote}
%     |write_rules_file| \word{filename} \word{rule list}
%   \end{quote}
%   and there is no particular return value. It is assumed that the 
%   rules already have all the graphic coordinates and such set up.
%   
%   \begin{tcl}
proc write_rules_file {filename ruleL} {
   set F [pdf::rewrite_pdf $filename]
   pdf::begin_pages $F Pages
   set page 1
   if {[catch {
      foreach rule $ruleL {
         rule_PDF_page $F "page$page" $pdf::paper_rect(A4) $rule
         incr page
      }
      pdf::put_obj $F "The catalog" [pdf::dict_obj\
        /Type /Catalog\
        /Pages [pdf::obj_ref $F [pdf::end_pages $F]]]
      pdf::close_pdf $F "The catalog"
   } res]} then {
      close $F
      return -code error -errorinfo $::errorInfo\
        -errorcode $::errorCode $res
   } else {
      return $res
   }
}
%</pdf>
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{Hopf algebra rules}
% 
% The following sets up the rules for a Hopf algebra. First, there are 
% the rules for the identity map.
% \begin{tcl}
%<*Hopf>
clear_rules
set type_array_name Hopf_types
set u 40
add_rule [network::gconstruct $u $u Hopf_types m \r id]\
         [network::gconstruct $u $u Hopf_types m]
add_rule [network::gconstruct $u $u Hopf_types id . \r m]\
         [network::gconstruct $u $u Hopf_types m]
add_rule [network::gconstruct $u $u Hopf_types . id \r m]\
         [network::gconstruct $u $u Hopf_types m]
%
add_rule [network::gconstruct $u $u Hopf_types unit \r id]\
         [network::gconstruct $u $u Hopf_types unit]
%
add_rule [network::gconstruct $u $u Hopf_types Delta \r id .]\
         [network::gconstruct $u $u Hopf_types Delta]
add_rule [network::gconstruct $u $u Hopf_types id \r Delta]\
         [network::gconstruct $u $u Hopf_types Delta]
add_rule [network::gconstruct $u $u Hopf_types Delta \r . id]\
         [network::gconstruct $u $u Hopf_types Delta]
%
add_rule [network::gconstruct $u $u Hopf_types id \r epsilon]\
         [network::gconstruct $u $u Hopf_types epsilon]
%
add_rule [network::gconstruct $u $u Hopf_types S \r id]\
         [network::gconstruct $u $u Hopf_types S]
add_rule [network::gconstruct $u $u Hopf_types id \r S]\
         [network::gconstruct $u $u Hopf_types S]
%
add_rule [network::gconstruct $u $u Hopf_types id \r id]\
         [network::gconstruct $u $u Hopf_types id]
% \end{tcl}
% Then comes the rules for an algebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types unit . \r m]\
         [network::gconstruct $u $u Hopf_types id]
add_rule [network::gconstruct $u $u Hopf_types . unit \r m]\
         [network::gconstruct $u $u Hopf_types id]
%
add_rule [network::gconstruct $u $u Hopf_types . m \r m]\
         [network::gconstruct $u $u Hopf_types m . \r m]
% \end{tcl}
% The rules for a coalgebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types Delta \r epsilon .]\
         [network::gconstruct $u $u Hopf_types id]
add_rule [network::gconstruct $u $u Hopf_types Delta \r . epsilon]\
         [network::gconstruct $u $u Hopf_types id]
%
add_rule [network::gconstruct $u $u Hopf_types Delta \r . Delta]\
         [network::gconstruct $u $u Hopf_types Delta \r Delta .]
% \end{tcl}
% The additional rules for a bialgebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types unit \r Delta]\
         [network::gconstruct $u $u Hopf_types unit unit]
add_rule [network::gconstruct $u $u Hopf_types unit \r epsilon]\
         [network::gconstruct $u $u Hopf_types]
add_rule [network::gconstruct $u $u Hopf_types m \r epsilon]\
         [network::gconstruct $u $u Hopf_types epsilon epsilon]
%<*!twist>
add_rule [network::gconstruct $u $u Hopf_types m \r Delta]\
         [network::gconstruct $u $u Hopf_types Delta Delta \r . x . . \r m m]
%</!twist>
%<*twist>
add_rule [network::gconstruct $u $u Hopf_types id . \r twist]\
         [network::gconstruct $u $u Hopf_types twist]
add_rule [network::gconstruct $u $u Hopf_types . id \r twist]\
         [network::gconstruct $u $u Hopf_types twist]
add_rule [network::gconstruct $u $u Hopf_types twist \r id .]\
         [network::gconstruct $u $u Hopf_types twist]
add_rule [network::gconstruct $u $u Hopf_types twist \r . id]\
         [network::gconstruct $u $u Hopf_types twist]
add_rule [network::gconstruct $u $u Hopf_types m \r Delta]\
         [network::gconstruct $u $u Hopf_types Delta Delta \r . twist . \r m m]
%</twist>
% \end{tcl}
% And finally the rules for a Hopf algebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types Delta \r . S \r m]\
         [network::gconstruct $u $u Hopf_types epsilon unit]
add_rule [network::gconstruct $u $u Hopf_types Delta \r S . \r m]\
         [network::gconstruct $u $u Hopf_types epsilon unit]
%</Hopf>
% \end{tcl}
% 
% As a variant, one can add the rule that the antipode has order $2$ 
% or $4$.
% \begin{tcl}
%<*Hopf2>
add_rule [network::gconstruct $u $u Hopf_types S \r S]\
         [network::gconstruct $u $u Hopf_types id]
%</Hopf2>
%<*Hopf4>
add_rule [network::gconstruct $u $u Hopf_types S \r S \r S \r S]\
         [network::gconstruct $u $u Hopf_types id]
%</Hopf4>
% \end{tcl}
% 
% \subsection{Hom-algebra rules}
% 
% The following sets up the rules for a Hom-algebra:
% $$
%   \alpha(x) (yz) = (xy) \alpha(z)
% $$
% \begin{tcl}
%<*HomAlg>
clear_rules
set type_array_name HomAlg_types
set u 40
% \end{tcl}
% First, there is the core rule.
% \begin{tcl}
add_rule [network::gconstruct $u $u HomAlg_types S m \r m]\
         [network::gconstruct $u $u HomAlg_types m S \r m]
% \end{tcl}
% Then the rules that |S| and |Sinv| are inverses of each other.
% \begin{tcl}
add_rule [network::gconstruct $u $u HomAlg_types S \r Sinv]\
         [network::gconstruct $u $u HomAlg_types id]
add_rule [network::gconstruct $u $u HomAlg_types Sinv \r S]\
         [network::gconstruct $u $u HomAlg_types id]
% \end{tcl}
% Finally rules about the identity.
% \begin{tcl}
add_rule [network::gconstruct $u $u HomAlg_types m \r id]\
         [network::gconstruct $u $u HomAlg_types m]
add_rule [network::gconstruct $u $u HomAlg_types id . \r m]\
         [network::gconstruct $u $u HomAlg_types m]
add_rule [network::gconstruct $u $u HomAlg_types . id \r m]\
         [network::gconstruct $u $u HomAlg_types m]
%
add_rule [network::gconstruct $u $u HomAlg_types S \r id]\
         [network::gconstruct $u $u HomAlg_types S]
add_rule [network::gconstruct $u $u HomAlg_types id \r S]\
         [network::gconstruct $u $u HomAlg_types S]
%
add_rule [network::gconstruct $u $u HomAlg_types Sinv \r id]\
         [network::gconstruct $u $u HomAlg_types Sinv]
add_rule [network::gconstruct $u $u HomAlg_types id \r Sinv]\
         [network::gconstruct $u $u HomAlg_types Sinv]
%</HomAlg>
% \end{tcl}
% 
% 
% \subsection{Alternating bialgebra rules}
% 
% The following sets up some rules that simulate three axioms for an 
% alternating algebra using a coproduct. Could perhaps be called an 
% ``alternating bialgebra''?
% \begin{tcl}
%<*altbialg>
clear_rules
set type_array_name Hopf_types
set u 40
% \end{tcl}
% The coproduct is just supposed to be the diagonal map, so it is 
% reasonable to make it coassociative.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types Delta \r . Delta]\
         [network::gconstruct $u $u Hopf_types Delta \r Delta .]
% \end{tcl}
% The product, on the other hand, is only associative when two of the 
% three factors are ``the same'', i.e., come from the same coproduct.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types . Delta \r . m \r m]\
         [network::gconstruct $u $u Hopf_types . Delta \r m . \r m]
add_rule [network::gconstruct $u $u Hopf_types Delta . \r . m \r m]\
         [network::gconstruct $u $u Hopf_types Delta . \r m . \r m]
add_rule [network::gconstruct $u $u Hopf_types Delta . \r . x . \r . m \r m]\
         [network::gconstruct $u $u Hopf_types Delta . \r . x . \r m . \r m]
% \end{tcl}
% Finally, the product--coproduct rule for a bialgebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u Hopf_types m \r Delta]\
         [network::gconstruct $u $u Hopf_types Delta Delta \r . x . . \r m m]
%</altbialg>
% \end{tcl}
% 
% 
% \subsection{Frobenius algebra rules}
% 
% The following sets up the rules (in terms of product, coproduct, 
% identity, unit, and counit for a Frobenius algebra. First, there are 
% the rules for the identity map.
% \begin{tcl}
%<*Frobenius>
clear_rules
set type_array_name Frobenius_types
set u 40
add_rule [network::gconstruct $u $u $type_array_name m \r id]\
         [network::gconstruct $u $u $type_array_name m]
add_rule [network::gconstruct $u $u $type_array_name id . \r m]\
         [network::gconstruct $u $u $type_array_name m]
add_rule [network::gconstruct $u $u $type_array_name . id \r m]\
         [network::gconstruct $u $u $type_array_name m]
%
add_rule [network::gconstruct $u $u $type_array_name unit \r id]\
         [network::gconstruct $u $u $type_array_name unit]
%
add_rule [network::gconstruct $u $u $type_array_name Delta \r id .]\
         [network::gconstruct $u $u $type_array_name Delta]
add_rule [network::gconstruct $u $u $type_array_name id \r Delta]\
         [network::gconstruct $u $u $type_array_name Delta]
add_rule [network::gconstruct $u $u $type_array_name Delta \r . id]\
         [network::gconstruct $u $u $type_array_name Delta]
%
add_rule [network::gconstruct $u $u $type_array_name id \r epsilon]\
         [network::gconstruct $u $u $type_array_name epsilon]
%
add_rule [network::gconstruct $u $u $type_array_name id \r id]\
         [network::gconstruct $u $u $type_array_name id]
% \end{tcl}
% Then comes the rules for an algebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u $type_array_name unit . \r m]\
         [network::gconstruct $u $u $type_array_name id]
add_rule [network::gconstruct $u $u $type_array_name . unit \r m]\
         [network::gconstruct $u $u $type_array_name id]
%
add_rule [network::gconstruct $u $u $type_array_name . m \r m]\
         [network::gconstruct $u $u $type_array_name m . \r m]
% \end{tcl}
% The rules for a coalgebra.
% \begin{tcl}
add_rule [network::gconstruct $u $u $type_array_name Delta \r epsilon .]\
         [network::gconstruct $u $u $type_array_name id]
add_rule [network::gconstruct $u $u $type_array_name Delta \r . epsilon]\
         [network::gconstruct $u $u $type_array_name id]
%
add_rule [network::gconstruct $u $u $type_array_name Delta \r . Delta]\
         [network::gconstruct $u $u $type_array_name Delta \r Delta .]
% \end{tcl}
% And finally the rules for a Frobenius algebra. For left--right symmetry, 
% it seems most natural to put multiplication above comultiplication here, 
% which is the opposite of what one does in a bialgebra.
% \begin{tcl}
%<*lr-symmetric>
add_rule [network::gconstruct $u $u $type_array_name Delta . \r . m]\
         [network::gconstruct $u $u $type_array_name m \r Delta]
add_rule [network::gconstruct $u $u $type_array_name . Delta \r m .]\
         [network::gconstruct $u $u $type_array_name m \r Delta]
%</lr-symmetric>
%<*!lr-symmetric>
add_rule [network::gconstruct $u $u $type_array_name m \r Delta]\
         [network::gconstruct $u $u $type_array_name Delta . \r . m]
add_rule [network::gconstruct $u $u $type_array_name . Delta \r m .]\
         [network::gconstruct $u $u $type_array_name m \r Delta]
%</!lr-symmetric>
%</Frobenius>
% \end{tcl}
% 
% 
% 
% \begin{tcl}
%</util1>
% \end{tcl}
