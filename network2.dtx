% 
% \iffalse (driver)
%<*driver>
\documentclass[a4paper]{tclldoc}[2007/04/01]
\usepackage{longtable}
\usepackage{amsmath,amssymb,amsfonts,amsthm}

\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}[lemma]{Theorem}
\theoremstyle{definition}
\newtheorem{definition}[lemma]{Definition}
\newtheorem{example}[lemma]{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{algsketch}{Algorithm sketch}

\PageIndex
\CodelineNumbered
\setcounter{IndexColumns}{2}

\providecommand{\marg}[1]{\textnormal{%
   \texttt{\symbol{123}}\meta{#1}\texttt{\symbol{125}}%
}}

\newenvironment{ttdescription}{%
  \description
  \def\makelabel##1{\hspace\labelsep\normalfont\ttfamily ##1}%
}{\enddescription}

\def\SH{\raise.7ex\hbox{$\scriptstyle\#$}} 
  % sharp sign for sharped MF units

% Environment for figures included in the source:
\newenvironment{mpgraphics}[2][]{%
   \ifx |#1|% `|' is ordinary here, but active in document.
      \includegraphics{#2}%
   \else
      \includegraphics[#1]{#2}%
   \fi
   \begingroup
      \let\begin=\iffalse
      \let\end=\fi
   \expandafter\endgroup
   \expandafter\end \begin %^^A This \begin is \iffalse
}{}
\newenvironment{mpgraphics*}{%
  \vcenter\bgroup\hbox\bgroup\mpgraphics
}{\egroup\egroup}
\RequirePackage{graphicx}

\usepackage{ifpdf}
\ifpdf
   \DeclareGraphicsRule{*}{mps}{*}{} % For pdfLaTeX
   % \newcommand{\myepssuffix}{}
\else
   % \newcommand{\myepssuffix}{.eps}
\fi


\makeatletter
\DeclareRobustCommand\SMC{%
  \ifx\@currsize\normalsize\small\else
   \ifx\@currsize\small\footnotesize\else
    \ifx\@currsize\footnotesize\scriptsize\else
     \ifx\@currsize\large\normalsize\else
      \ifx\@currsize\Large\large\else
       \ifx\@currsize\LARGE\Large\else
        \ifx\@currsize\scriptsize\tiny\else
         \ifx\@currsize\tiny\tiny\else
          \ifx\@currsize\huge\LARGE\else
           \ifx\@currsize\Huge\huge\else
            \small\SMC@unknown@warning
 \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
}
\newcommand{\SMC@unknown@warning}{\TBWarning{\string\SMC: unrecognised
    text font size command -- using \string\small}}
\makeatother

\newcommand{\PROP}{{\SMC PROP}}
\newcommand{\PROPs}{{\SMC PROP}s}
\newcommand{\PRO}{{\SMC PRO}}
\newcommand{\ISBN}{{\SMC ISBN}}
\newcommand{\ISBNX}{{\SMC X}}
\providecommand*{\Dash}{%
   \hspace*{0.166667em}\textemdash\hspace{0.166667em}%
}
\providecommand*{\Ldash}{%
   \hspace{0.166667em}\textemdash\hspace*{0.166667em}%
}
\providecommand*{\Rdash}{%
   \hspace*{0.166667em}\textemdash\hspace{0.166667em}%
}
\providecommand*{\dash}{\textendash\hspace{0pt}}

\newcommand{\package}[1]{\textsf{#1}}

\newcommand{\Tcl}{\Tcllogo}
\newcommand*{\DefOrd}[2][]{\textbf{#2}}
\newcommand*{\emDefOrd}[2][]{\emph{#2}}

\newcommand{\mc}{\mathcal}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Zp}{\mathbb{Z}_{>0}}
\newcommand{\Fpil}{\longrightarrow}
\newcommand{\cross}[2]{{}^{#1}\mathsf{X}^{#2}}
\newcommand{\same}[1]{\mathsf{I}^{#1}}

\newcommand{\arity}{\mathrm{ar}}
\newcommand{\coarity}{\mathrm{ca}}
\newcommand{\id}{\mathrm{id}}

\newcommand{\GV}{\mathrm{V}}
\newcommand{\GE}{\mathrm{E}}

\makeatletter
\newcommand*{\setOf}[3][\@gobble]{%
   \left\{ \, #2 \,\,\vrule\relax#1.\,\, #3 \, \right\}%
}
\newcommand*{\card}[2][\@gobble]{\left|#1. #2 \right|}
\makeatother

\newcommand*{\pin}[1]{%
   \mathchoice{%
      \mathrel{\mathrm{in}}%
   }{%
      \mathrel{\mathrm{in}}%
   }{%
      \mathop{\mathrm{in}}%
   }{%
      \mathop{\mathrm{in}}%
   }#1%
}
\newcommand{\restr}[2]{#1_{\lvert #2}}

\stringtypeheading{rich entry}{Rich network entries:}


\begin{document}
\DocInput{network2.dtx}
\PrintIndex
\end{document}
%</driver>
% \fi
% 
% \title{A \PROP py network library}
% \author{Lars Hellstr\"om}
% \maketitle
% 
% \begin{abstract}
%   This is a library of code for computations with graphic \PROP\ 
%   expressions, as needed in order to perform a Knuth--Bendix\slash 
%   Buchberger style completion on a set of identities. For the sakes 
%   of simplicity, platform independence, and purity, it is written 
%   in \Tcl.
% \end{abstract}
% 
% 
% \tableofcontents
% 
% 
% \section{Theory and introduction}
% 
% Best current reference for this is \emph{Network Rewriting I: The 
% Foundation}. 
% \iffalse
% The main points of deviation from the formalism there are:
% \begin{itemize}
%   \item
%     Indices (in particular head and tail indices) here start at $0$ 
%     rather than $1$, since \Tcl\ uses zero-based-indexing for lists.
%   \item
%     Transferrence matrices are stored sparsely, as lists of (the 
%     indices of) those positions which are $0$.
% \end{itemize}
% In other words, the differences are very small.
% \fi
% 
% 
% \section{Preparations}
% 
% The code is declared as a package. Commands are kept in the |network| 
% namespace (although mostly in the children of |network|).
% \begin{tcl}
%<*pkg>
package require Tcl 8.4
package provide network 2
namespace eval network {}
% \end{tcl}
% \setnamespace{network}
% 
% For some commands, test code is inlined in these sources, guarded 
% by the \Module{test} expression. These are currently not structured 
% to be extracted into a separate test file.
% \begin{tcl}
%<test>package require tcltest 2
% \end{tcl}
% 
% 
% \subsection{General utilities}
% 
% \begin{proc}{setconstlist}
%   This command sets variables to lists of the same length as a 
%   given list, but with all elements a given ``constant''. The call 
%   syntax is
%   \begin{quote}
%     |network::setconstlist| 
%     \begin{regblock}[\regstar]\word{variable} \word{value} 
%     \word{list}\end{regblock}
%   \end{quote}
%   where \word{variable} is (the name in the calling context of) the 
%   variable to set, \word{value} is the value to use for its 
%   elements, and \word{list} is the list whose elements should be 
%   mirrored. There is no particular return value.
%   \begin{tcl}
proc network::setconstlist {args} {
   foreach {var val list} $args {
      set L {}
      foreach item $list {lappend L $val}
      uplevel 1 [list ::set $var $L]
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Dictionary compatibility}
% 
% It would be possible to do a pure-\Tcl\ emulation of |dict|, but 
% the following is sufficient for my needs right now.
% \begin{tcl}
if {![llength [info commands dict]]} then {
   package require dict
}
% \end{tcl}
% 
% 
% \section{Pure networks}
% 
% The data structure employed is basically the same as in the 
% theoretical setting, but there is some duplication of information 
% (the vertices know which edges are incident to them) and indices 
% start from $0$ rather than from $1$ (to ensure that they are valid 
% \Tcl\ list indices). A \emph{network} in this package is a list
% \begin{quote}
%   \word{vertices} \word{edges}
% \end{quote}
% where \word{vertices} is the list of vertices in the network (in the 
% order of their labels) and \word{edges} is the list of edges in the 
% network (in the order of \emph{their} labels). The input vertex 
% always has label $1$ and the output vertex always has label $0$.
% 
% A \emph{vertex} is a list
% \begin{quote}
%   \word{annotation} \word{out-edges} \word{in-edges}
% \end{quote}
% where \word{annotation} is the vertex annotation (a string, which may 
% be empty only for the input and output vertices), whereas 
% \word{out-edges} and \word{in-edges} are lists of the incident input 
% and output edge labels (in the order given by their tail and head 
% respecively indices). An \emph{edge} is a list
% \begin{quote}
%   \word{head-label} \word{head-index} \word{tail-label} 
%   \word{tail-index}
% \end{quote}
% 
% Commands operating on pure networks are kept mostly in the 
% |network::pure| namespace. The intention is that namespaces for 
% other types of networks may mirror what |network::pure| provides, 
% so that in higher level code the choice of namespace to import 
% basic commands from will determine what type of networks are being 
% operated on.
% \begin{tcl}
namespace eval network {namespace eval pure {}}
% \end{tcl}
% \setnamespace{network::pure}
% 
% 
% 
% \subsection{Construction}
% 
% It's hard to do anything with networks if there aren't any to 
% operate on to begin with, so a first order of business is to 
% provide a convenient way of setting up networks.
% 
% \begin{proc}{construct}
%   The |construct| procedure constructs a network from a table of 
%   vertex types and a list of components. The syntax is
%   \begin{quote}
%     |network::pure::construct| \word{type-dict} \word{scan-list}
%   \end{quote}
%   where \word{scan-list} is a list of ``items'' in the network 
%   written in a top--down (input--output) and left--right (low index 
%   to hight index) manner, and \word{type-dict} is a dictionary 
%   specifying how these items should be interpreted. The return 
%   value is the result network.
%   
%   Most items are the annotation string for a vertex; in that case 
%   the corresponding entry in the \word{type-dict} is a pair
%   \begin{quote}
%     \word{arity} \word{coarity}
%   \end{quote}
%   There are however also some item types which do not insert 
%   vertices, and in that case the \word{type-dict} entry is a list 
%   whose first element is not an integer. The following first 
%   elements are understood
%   \begin{description}
%     \item[\texttt{same} \word{n}]
%       The next $n$ edges are passed on to the next row. This is 
%       effectively a $\same{n}$ permutation.
%     \item[\texttt{cross} \word{m} \word{n}]
%       The next $m+n$ edges are passed on to the next row, but the 
%       first $m$ of them will be placed after the last $n$. This is 
%       effectively a $\cross{m}{n}$ permutation.
%     \item[\texttt{newline}]
%       All remaining edges are passed on to the next row, and a 
%       new is begun.
%   \end{description}
%   Unless this is explicitly overridden by the \word{type-dict}, the 
%   following items have such special meanings:
%   \begin{description}
%     \item[\texttt{.} (period)]
%       Equivalent to |same 1|.
%     \item[carriage return]
%       Equivalent to |newline|.
%     \item[line feed]
%       Equivalent to |newline|.
%     \item[\texttt{X}]
%       Equivalent to |cross 1 1|.
%     \item[\meta{k}\texttt{X}\meta{l}]
%       Equivalent to |cross| \word{k} \word{l}.
%   \end{description}
%   The \meta{k}\texttt{X}\meta{l} items are generated on the fly, 
%   but the other ones are put into the |Type| array to start with.
%   \begin{tcl}
proc network::pure::construct {typedict scanL} {
   array set Type {
      . {same 1}
      X {cross 1 1}
      \r newline
      \n newline
   }
   array set Type $typedict
   set V [list {"" {} {}} {"" {} {}}]
   set E {}
   set NWin {}
   set in {}
   set out {}
%   \end{tcl}
%   |in| in the list of labels of edges going in to the current 
%   level, |out| is the list of labels of edges going out from the 
%   current level. These edges have been added to |E|, but their 
%   output ends are empty strings until they get attached to 
%   something. |NWin| similarly is the list of labels of input legs. 
%   The |i| variable is a pointer to the next |in| edge to use.
%   \begin{tcl}
   set i 0
   foreach t $scanL {
      if {![info exists Type($t)]} then {
         if {[
            regexp -- {^([1-9][0-9]*)X([1-9][0-9]*)$} $t -> k l
         ]} then {
            set Type($t) [list cross $k $l]
         } else {
            error "Unknown item type: $t"
         }
      }
      switch -- [lindex $Type($t) 0] "newline" {
         set in [concat $out [lrange $in $i end]]
         set i 0
         set out {}
      } "same" {
         for {set n [lindex $Type($t) 1]} {$n >= 1} {incr n -1} {
            if {$i < [llength $in]} then {
               lappend out [lindex $in $i]
               incr i
            } else {
               lappend NWin [llength $E]
               lappend out [llength $E]
               lappend E {"" "" "" ""}
            }
         }
      } "cross" {
         set L [list lappend out]
         for {set n [lindex $Type($t) 1]} {$n >= 1} {incr n -1} {
            if {$i < [llength $in]} then {
               lappend L [lindex $in $i]
               incr i
            } else {
               lappend L [llength $E]
               lappend NWin [llength $E]
               lappend E {"" "" "" ""}
            }
         }
         for {set n [lindex $Type($t) 2]} {$n >= 1} {incr n -1} {
            if {$i < [llength $in]} then {
               lappend out [lindex $in $i]
               incr i
            } else {
               lappend out [llength $E]
               lappend NWin [llength $E]
               lappend E {"" "" "" ""}
            }
         }
         eval $L
      } default {
         foreach {ar ca} $Type($t) break
         if {![string is integer $ar] || ![string is integer $ca]}\
         then {error "Malformed definition of item type: $t"}
%   \end{tcl}
%   Need to construct a new vertex, construct the edges out from it, 
%   and attach the edges coming in to it.
%   \begin{tcl}
         set new [list $t]
         set L {}
         for {set n 0} {$n<$ca} {incr n} {
            lappend out [llength $E]
            lappend L [llength $E]
            lappend E [list "" "" [llength $V] $n]
         }
         lappend new $L
         set L {}
         for {set n 0} {$n<$ar} {incr n} {
            if {$i < [llength $in]} then {
               lappend L [lindex $in $i]
               lset E [lindex $in $i] 0 [llength $V]
               lset E [lindex $in $i] 1 $n
               incr i
            } else {
               lappend NWin [llength $E]
               lappend L [llength $E]
               lappend E [list [llength $V] $n "" ""]
            }
         }
         lappend new $L
         lappend V $new
      }
   }
%   \end{tcl}
%   Complete the network.
%   \begin{tcl}
   eval [list lappend out] [lrange $in $i end]
   lset V 0 2 $out
   set n -1; foreach e $out {incr n
      lset E $e 0 0
      lset E $e 1 $n
   }
   lset V 1 1 $NWin
   set n -1; foreach e $NWin {incr n
      lset E $e 2 1
      lset E $e 3 $n
   }
   return [list $V $E]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{edgeorder}
%   The |edgeorder| procedure computes the dependence partial order on 
%   the edges of a network. The dependence is represented as an array 
%   which has an entry \meta{$e_1$}\verb*" "\meta{$e_2$} if and only 
%   if edge $e_1$ depends on edge $e_2$. The contents of these 
%   entries are irrelevant.
%   
%   The call syntax is
%   \begin{quote}
%     |network::pure::edgeorder| \word{network} \word{var-name}\regopt
%   \end{quote}
%   and the return value depends on whether a \word{var-name} is 
%   specified. If it is not, then |array get| of the encoding array is 
%   returned. If \word{var-name} is specified, then nothing 
%   particular is returned, but the partial order is computed in the 
%   array \word{var-name} of the calling context. It is an error if 
%   this array initially has some index which is not of the form 
%   specified above, for $e_1$ and $e_2$ being edge labels.
%   
%   \begin{tcl}
proc network::pure::edgeorder {NW {arr ""}} {
   if {$arr ne ""} then {upvar 1 $arr P}
   set n -1; foreach e [lindex $NW 1] {incr n
      set "P($n $n)" {}
   }
   foreach v [lindex $NW 0] {
      set aboveL {}
      foreach e [lindex $v 2] {
         foreach pair [array names P "$e *"] {
            lappend aboveL [lindex $pair 1]
         }
      }
      set belowL {}
      foreach e [lindex $v 1] {
         foreach pair [array names P "* $e"] {
            lappend belowL [lindex $pair 0]
         }
      }
      set belowL [lsort -integer -unique $belowL]
      foreach j [lsort -integer -unique $aboveL] {
         foreach i $belowL {
            set "P($i $j)" {}
         }
      }
   }
   if {$arr eq ""} then {return [array get P]}
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Canonical representation}
% 
% The canonical form of a network is a pure network, where (i)~all the 
% lists have their canonical string representation and (ii)~the vertices 
% and edges have a canonical labelling. As usual, the last point is where 
% things get tricky. Matters aren't quite as bad as for ordinary graphs 
% though, because the presence of head and tail indices have the effect 
% that isomorphisms are even in the worst case uniquely determined by 
% one vertex per component. For connected networks the uniqueness of 
% the output vertex thus suffices for fixing the complete structure, 
% but when there are isolated components then different choices are 
% possible. If there are many components then there is also the problem 
% of which order the components should be in.
% 
% The solution to the subproblem of ordering the components is to compute 
% a simplified canonical representation for each component (not 
% containing the input or output vertex), and then sort the components 
% according to this representation\Dash if it then happens that two 
% components have the same representation, then they are equal and 
% their relative order is irrelevant. The solution to the labelling 
% within a component is less straightforward; basically it will have to 
% be checked for each vertex which representation arises from giving 
% this vertex the smallest label, and then one picks the smallest of 
% these representations as canonical representation for the component. 
% This can in principle lead to a lot of work, but it is possible to 
% cut it down somewhat by only considering the vertices with minimal 
% annotation within the component; pretty often, it will be unique. 
% \emph{Most} of the time it will also be the case that an 
% |lsort -dictionary| on all component representations would pick as 
% the smallest one where the first vertex has minimal annotation, but 
% due to special cases in \Tcl\ canonical list representation this is 
% \emph{not} true in general (i.e., |lsort -dictionary| sorts a list of 
% strings and the corresponding list of one-element lists of strings 
% differently), so formally the order used to pick a minimal 
% representation of a component is: first compare annotations of first 
% vertices, then compare the complete representations.
% 
% The simplified canonical representation of a network (or component of 
% a network) is a list of vertices-and-edges, where the edges are 
% formatted as vertices (with empty annotation, one output, and one 
% input) and share a label space with these. The structure is thus
% \begin{quote}
%   \word{annotation} \word{out-neighbours} \word{in-neighbours}
% \end{quote}
% The edges are characterised in this representation by having empty 
% annotation and positive length of both \word{out-neighbours} and 
% \word{in-neighbours}. Labels are assigned via a breadth first search, 
% where one traverses first the output edges at a vertex and then the 
% input edges.
% 
% The breadth first search is practically carried out by two commands 
% \describestring[proc][network::pure::canonise]{vertex}|vertex| and 
% \describestring[proc][network::pure::canonise]{edge}|edge|, which 
% expect to be called from a context where a couple of variables 
% (which can be local) to operate on exist. The first of these is 
% \describestring[var.]{NW}|NW|, which is 
% the original network being searched through; it is not modified in 
% this process. \describestring[var.]{queue}|queue| is a list whose 
% elements are on one of the two forms
% \begin{quote}
%   |vertex| \word{label}\\
%   |edge| \word{label}
% \end{quote}
% The \word{label}s are labels in the |NW| network of a vertex and edge 
% respectively. Elements are appended to the |queue| list when new 
% canonical-network labels are assigned to things, but elements are not 
% deleted, so |llength $queue| is always the next label to assign to 
% something, and the |queue| elements give a mapping from 
% canonical-network labels to original network labels.
% 
% The opposite mapping is provided by the two arrays 
% \describestring[array]{Vcan}|Vcan| and 
% \describestring[array]{Ecan}|Ecan|, 
% whose indices are labels (vertex and edge respectively) of |NW| and 
% the entries are the corresponding labels in the canonical network (if 
% any have been assigned). Finally, \describestring[var.]{SCR}|SCR| is 
% the Simplified Canonical Representation being constructed. The search 
% is complete when |SCR| and |queue| have the same number of elements.
% 
% \begin{tcl}
namespace eval network::pure::canonise {}
% \end{tcl}
% \setnamespace{network::pure::canonise}
% 
% \begin{proc}{vertex}
%   The |vertex| procedure has the syntax
%   \begin{quote}
%     |vertex| \word{label}
%   \end{quote}
%   Its task is to append the element for the vertex with label 
%   \word{label} in |NW| to the |SCR| list and update |queue| 
%   and |Ecan| with any new edges it discovers. There is no 
%   particular return value.
%   \begin{tcl}
proc network::pure::canonise::vertex {label} {
   upvar 1 NW NW SCR SCR Ecan Ecan queue queue
   set me [list [lindex $NW 0 $label 0]]
   foreach i {1 2} {
      set L {}
      foreach e [lindex $NW 0 $label $i] {
         if {![info exists Ecan($e)]} then {
            set Ecan($e) [llength $queue]
            lappend queue [list edge $e]
         }
         lappend L $Ecan($e)
      }
      lappend me $L
   }
   lappend SCR $me
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{edge}
%   The |edge| procedure has the syntax
%   \begin{quote}
%     |edge| \word{label}
%   \end{quote}
%   Its task is to append the element for the edge with label 
%   \word{label} in |NW| to the |SCR| list and update |queue| 
%   and |Vcan| with any new vertices it discovers. There is no 
%   particular return value.
%   \begin{tcl}
proc network::pure::canonise::edge {label} {
   upvar 1 NW NW SCR SCR Vcan Vcan queue queue
   set me [list ""]
   foreach {v i} [lindex $NW 1 $label] {
      if {![info exists Vcan($v)]} then {
         set Vcan($v) [llength $queue]
         lappend queue [list vertex $v]
      }
      lappend me [list $Vcan($v)]
   }
   lappend SCR $me
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{component_SCR}
%   The |component_SCR| procedure computes a canonical representation 
%   for a component in a network, given a starting vertex. The call 
%   syntax is
%   \begin{quote}
%     |component_SCR| \word{network} \word{start}
%   \end{quote}
%   where \word{network} is the network and \word{start} is the label 
%   in that network of the vertex to give label $0$ in the SCR. The 
%   return value is a list
%   \begin{quote}
%     \word{SCR} \word{originals}
%   \end{quote}
%   where \word{SCR} is the wanted simplified canonical representation 
%   and \word{originals} is a list with the same structure as |queue| 
%   above (actually the final value of that list) that gives a mapping 
%   of SCR labels to \word{network} labels.
%   \begin{tcl}
proc network::pure::canonise::component_SCR {NW start} {
   set queue [list [list vertex $start]]
   set Vcan($start) 0
   set SCR {}
   while {[llength $SCR] < [llength $queue]} {
      eval [lindex $queue [llength $SCR]]
   }
   return [list $SCR $queue]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{labelling}
%   The |labelling| procedure is the top-level command in the 
%   |network::pure::canonise| namespace. It has the syntax
%   \begin{displaysyntax}
%     network::pure::canonise::labelling \word{network}
%   \end{displaysyntax}
%   and returns a list of four lists $V_\mathrm{c}$, $E_\mathrm{c}$, 
%   $V_\mathrm{nc}$, and $E_\mathrm{nc}$, in that order. The c-lists 
%   map noncanonical labels to canonical labels, whereas the nc-lists 
%   map canonical labels to noncanonical labels.
%   
%   The procedure starts by computing an SCR for the ``exterior 
%   component'' (i.e., the set of vertices in the same component as 
%   the input or output vertex). The vertices and edges encountered 
%   in this work appear in the proper order, even if the labels may 
%   be a little off (but that can be sorted out later).
%   \begin{tcl}
proc network::pure::canonise::labelling {NW} {
   set queue [list [list vertex 0] [list vertex 1]]
   array set Vcan {0 0 1 1}
   set SCR {}
   while {[llength $SCR] < [llength $queue]} {
      eval [lindex $queue [llength $SCR]]
   }
%   \end{tcl}
%   In the typical case we now know the order of labels in the return 
%   value, but in the general case there are additional components 
%   that need to be delt with. Therefore an array |moreV| (index is 
%   |NW| vertex label, entries are irrelevant) is created to keep 
%   track of those vertices which have not yet been put into a 
%   component.
%   \begin{tcl}
   set n -1; foreach v [lindex $NW 0] {incr n
      set moreV($n) {}
   }
   foreach pair $queue {
      if {[lindex $pair 0] eq "vertex"} then {
         unset moreV([lindex $pair 1])
      }
   }
%   \end{tcl}
%   There is furthermore a list |decL| of pairs
%   \begin{quote}
%     \word{annotation} \word{vertex label}
%   \end{quote}
%   which is sorted by \word{annotation}. By looking through the 
%   network in the order of this list, it is possible to identify a 
%   component by computing its SCR with respect to one vertex therein 
%   which has minimal annotation. |compL| is the list of components 
%   (the exterior component not included) which will eventually be 
%   sorted to find their canonical order.
%   \changes{2.3}{2009/03/31}{Bugfix; isolated components were 
%     being dropped! (LH)}
%   \begin{tcl}
   set compL {}
   set decL {}
   foreach v [array names moreV] {
      lappend decL [list [lindex $NW 0 $v 0] $v]
   }
   foreach vertex [lsort -dictionary -index 0 $decL] {
      set start [lindex $vertex 1]
      if {![info exists moreV($start)]} then {continue}
      set pair [component_SCR $NW $start]
      set rootL {}
      foreach q [lindex $pair 1] {
         if {[lindex $q 0] eq "vertex"} then {
            set v [lindex $q 1]
            unset moreV($v)
            if {[lindex $NW 0 $start 0] eq [lindex $NW 0 $v 0]} then {
               lappend rootL $v
            }
         }
      }
      set L [list $pair]
      foreach v [lrange $rootL 1 end] {
         lappend L [component_SCR $NW $v]
      }
      lappend compL [lindex [lsort -dictionary -index 0 $L] 0]
   }
%   \end{tcl}
%   OK, now the components are known and canonical representations 
%   have been computed for all of them. The next step is to order the 
%   components, construct lists |ncVL| and |ncEL| mapping canonical 
%   labels to noncanonical labels, and also make lists mapping the 
%   other way round.
%   \begin{tcl}
   set ncVL {}
   set ncEL {}
   foreach pair [
      linsert [lsort -dictionary -index 0 $compL] 0 [list $SCR $queue]
   ] {
      foreach item [lindex $pair 1] {
         switch -- [lindex $item 0] "vertex" {
            lappend ncVL [lindex $item 1]
         } "edge" {
            lappend ncEL [lindex $item 1]
         }
      }
   }
   set cVL $ncVL
   set n -1; foreach l $ncVL {incr n; lset cVL $l $n}
   set cEL $ncEL
   set n -1; foreach l $ncEL {incr n; lset cEL $l $n}
   return [list $cVL $cEL $ncVL $ncEL]
}
%   \end{tcl}
% \end{proc}
% 
% \setnamespace{network::pure}
% 
% \begin{proc}{canonise}
%   The |network::pure::canonise| procedure is the top-level command 
%   for computing the canonical form of a network. It has the syntax
%   \begin{displaysyntax}
%     network::pure::canonise \word{network} \word{embed-var}\regopt
%   \end{displaysyntax}
%   and returns an equivalent network, but in canonical form. If a 
%   \word{embed-var} is specified, then the variable by that name in 
%   the calling context is filled in with the embedding 
%   (see~Subsection~\ref{Ssec:Regionkirurgi}) of the old labelling 
%   into the canonical network.
%   
%   Most of the actual work of finding the canonical labelling is 
%   done by |canonise::labelling|, so this procedure is mostly about 
%   rebuilding the network.
%   \begin{tcl}
proc network::pure::canonise {NW {embedvar ""}} {
   foreach {cVL cEL ncVL ncEL} [canonise::labelling $NW] break
   if {$embedvar ne ""} then {
      uplevel 1 [list ::set $embedvar [list $cVL $cEL [llength $cEL]]]
   }
   set V {}
   foreach v $ncVL {
      set L [list [lindex $NW 0 $v 0]]
      foreach i {1 2} {
         set L2 {}
         foreach e [lindex $NW 0 $v $i] {lappend L2 [lindex $cEL $e]}
         lappend L $L2
      }
      lappend V $L
   }
   set E {}
   foreach e $ncEL {
      set L {}
      foreach {v i} [lindex $NW 1 $e] {lappend L [lindex $cVL $v] $i}
      lappend E $L
   }
   return [list $V $E]
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{\PROP py operations}
% 
% Since networks represent elements of the free \PROP, the elementary 
% operations on a \PROP\ should be available for networks (although, as 
% it turns out, these aren't directly needed for neither reduction nor 
% completion).
% 
% \begin{proc}{composition}
%   This procedure computes the composition of a list of pure 
%   networks, i.e., it places them all in sequence (with the first 
%   on the output side). The syntax is
%   \begin{quote}
%     |network::pure::composition| \word{network}\regplus
%   \end{quote}
%   and the return value is the resulting network. It is typically 
%   not on canonical form. It is an error if the number of outputs in 
%   one network does not match the number of inputs in the following.
%   
%   The implementation is a basic loop over the arguments, and at 
%   each round a new network is composed. The current input side is 
%   kept track of as the list |inL| of labels of input edges, in 
%   their proper order. New edges and vertices are appended to the 
%   |E| and |V| lists for the result as they are encountered.
%   \begin{tcl}
proc network::pure::composition {NW0 args} {
   foreach {V E} $NW0 {break}
   set inL [lindex $V 1 1]
   foreach NW $args {
      if {[llength $inL] != [llength [lindex $NW 0 0 2]]} then {
         error [format {Mismatch in composition: %d != %d}\
           [llength $inL] [llength [lindex $NW 0 0 2]]]
      }
%   \end{tcl}
%   Since edges of |NW| may fuse with edges in |E|, a generic 
%   translation is needed. The |renumEL| list maps |NW| edge labels 
%   to |E| edge labels. Vertices are relabelled by a simple offset 
%   |vOfs|.
%   \begin{tcl}
      set vOfs [expr {[llength $V] - 2}]
      set renumEL {}
      foreach e [lindex $NW 1] {
         if {[lindex $e 0] == 0} then {
            set m [lindex $inL [lindex $e 1]]
            lset E $m 2 [expr {[lindex $e 2] + $vOfs}]
            lset E $m 3 [lindex $e 3]
            lappend renumEL $m
         } else {
            set L {}
            foreach {v i} $e {lappend L [expr {$v+$vOfs}] $i}
            lappend renumEL [llength $E]
            lappend E $L
         }
      }
      foreach v [lrange [lindex $NW 0] 2 end] {
         set L [lrange $v 0 0]
         foreach side [lrange $v 1 2] {
            set L2 {}
            foreach e $side {lappend L2 [lindex $renumEL $e]}
            lappend L $L2
         }
         lappend V $L
      }
      set inL {}
      foreach m [lindex $NW 0 1 1] {lappend inL [lindex $renumEL $m]}
   }
   lset V 1 1 $inL
   set i -1; foreach e $inL {incr i
      lset E $e 2 1
      lset E $e 3 $i
   }
   return [list $V $E]
}
namespace eval network::pure {namespace export composition}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{tensorprod}
%   This procedure computes the tensor product of a list of pure 
%   networks, i.e., it places them all side by side. The syntax is
%   \begin{quote}
%     |network::pure::tensorprod| \word{network}\regstar
%   \end{quote}
%   and the return value is the resulting network. It is typically 
%   not on canonical form.
%   
%   The implementation simply appends elements to the \word{vertices} 
%   and \word{edges} lists, renumbering the incides as necessary.
%   \begin{tcl}
proc network::pure::tensorprod {args} {
   set V {{"" {} L0} {"" L1 {}}}
   set E {}
   set L0 {}
   set L1 {}
   foreach NW $args {
      set vdiff [expr {[llength $V] - 2}]
      set ediff [llength $E]
      set l1diff [llength $L1]
      set l0diff [llength $L0]
      foreach i [lindex $NW 0 0 2] {lappend L0 [expr {$i + $ediff}]}
      foreach i [lindex $NW 0 1 1] {lappend L1 [expr {$i + $ediff}]}
      foreach v [lrange [lindex $NW 0] 2 end] {
         set vnew [lrange $v 0 0]
         foreach l [lrange $v 1 2] {
            set Inew {}
            foreach i $l {lappend Inew [expr {$i+$ediff}]}
            lappend vnew $Inew
         }
         lappend V $vnew
      }
      foreach e [lindex $NW 1] {
         foreach {h g t s} $e break
         set enew {}
         if {$h==0} then {
            lappend enew 0 [expr {$g + $l0diff}]
         } else {
            lappend enew [expr {$h + $vdiff}] $g
         }
         if {$t==1} then {
            lappend enew 1 [expr {$s + $l1diff}]
         } else {
            lappend enew [expr {$t + $vdiff}] $s
         }
         lappend E $enew
      }
   }
   lset V 0 2 $L0
   lset V 1 1 $L1
   return [list $V $E]
}
namespace eval network::pure {namespace export tensorprod}
%   \end{tcl}
% \end{proc}
% 
% 
% A \index{permutation}\emph{permutation} $\sigma$ is encoded as the 
% list where item $i$ is $\sigma(i)$.
% 
% \begin{proc}{permutation}
%   The |permutation| procedure implements the $\phi_n$ maps of 
%   Definition~\ref{Def:PROP}, i.e., it returns the network 
%   corresponding to a given permutation. The call syntax is
%   \begin{quote}
%     |network::pure::permutation| \word{permutation}
%   \end{quote}
%   
%   The edge labels are selected to coincide with the input indices. 
%   The output list 
%   \begin{tcl}
proc network::pure::permutation {sigma} {
   set outL $sigma
   set inL {}
   set E {}
   foreach i $sigma {
      lset outL $i [llength $E]
      lappend inL [llength $E]
      lappend E [list 0 $i 1 [llength $E]]
   }
   return [list [list [list "" {} $outL] [list "" $inL {}]] $E]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{left_action}
%   This procedure implements the left action of a permutation on a 
%   network, i.e., a permutation of the outputs. The call syntax is
%   \begin{quote}
%     |network::pure::left_action| \word{permutation} \word{network}
%   \end{quote}
%   and the return value is the result network. The effect is 
%   equivalent to composing the permutation as a network with the 
%   given network, but this is more efficient.
%   
%   \begin{tcl}
proc network::pure::left_action {sigma NW} {
   foreach i $sigma e [lindex $NW 0 0 2] {
      lset NW 1 $e 1 $i
      lset sigma $i $e
   }
   lset NW 0 0 2 $sigma
   return $NW
}
%   \end{tcl}
% \end{proc} 
% 
% \begin{proc}{right_action}
%   This procedure implements the right action of a permutation on a 
%   network, i.e., a permutation of the inputs. The call syntax is
%   \begin{quote}
%     |network::pure::right_action| \word{network} \word{permutation}
%   \end{quote}
%   and the return value is the result network. The effect is 
%   equivalent to composing the given network with the permutation as 
%   a network, but this is more efficient.
%   
%   \begin{tcl}
proc network::pure::right_action {NW sigma} {
   set inL {}
   foreach i $sigma {
      set e [lindex $NW 0 1 1 $i]
      lset NW 1 $e 3 [llength $inL]
      lappend inL $e
   }
   lset NW 0 1 1 $inL
   return $NW
}
%   \end{tcl}
% \end{proc}
% 
% 
% That the networks encode elements of the \emph{free} \PROP\ also 
% gives rise to a substitution map that replaces vertices of 
% specified types by networks.
% 
% \begin{proc}{substitute}
%   This procedure has the call syntax
%   \begin{quote}
%     |network::pure::substitute| \word{network} \word{map}
%   \end{quote}
%   where the \word{map} is a dictionary mapping vertex annotations 
%   to networks (with the same arities and coarities as vertices with 
%   the corresponding annotations). The return value is what the 
%   \word{network} becomes if one replaces every vertex whose 
%   annotation is found in the \word{map} by the corresponding 
%   network.
%   
%   With respect to the vertices, substitution is a fairly 
%   straightforward operation; each vertex gets replaced by a set of 
%   vertices, which are known from start. Edges are trickier, in that 
%   substitution can cause many edges to be fused into one (consider 
%   what happens when one replaces a vertex with a permutation). The 
%   algorithm used below first constructs all the vertices, but does 
%   not update their inputs and outputs. In a second round, the edges 
%   are constructed from head to tail by tracking the inputs of 
%   vertices.
%   
%   Tracking edges is a process on two levels. Sometimes the edge is 
%   in the base \word{network}, other times it is in a network in the 
%   \word{map}. The first part creates two tables to relate the role 
%   of a vertex in the substitution process to its identity in the 
%   result. |NWL| is a list indexed by \word{network} vertex label, 
%   whose entries are empty lists (if this vertex is not being 
%   substituted) or the network that is going to be substituted for 
%   the vertex. |VA| is an array indexed by one- or two-element lists 
%   of labels that give the corresponding vertex label in the result. 
%   Indices that are one-element lists correpond to vertices that 
%   have not been substituted. Indices that are two-element lists 
%   \word{$n$}| |\word{$k$} correspond to vertex $k$ in the network 
%   that was substituted for vertex $n$.
%   
%   \begin{tcl}
proc network::pure::substitute {NW dict} {
   array set Subs $dict
   set V {}
   set NWL {}
   foreach v [lindex $NW 0] {
      if {[llength $NWL]<2 || ![info exists Subs([lindex $v 0])]}\
      then {
         set VA([list [llength $NWL]]) [llength $V]
         lappend V $v
         lappend NWL {}
      } else {
         set NW2 $Subs([lindex $v 0])
         set k 1; foreach u [lrange [lindex $NW2 0] 2 end] {incr k
            set VA([list [llength $NWL] $k]) [llength $V]
            lappend V $u
         }
         lappend NWL $NW2
      }
   }
%   \end{tcl}
%   The second part is a loop over all inputs of all vertices, where 
%   the loop over all vertices is a loop over all elements in |VA|; 
%   this avoids the need for a table that is the inverse of |VA|. In 
%   the loop following the edge, the main variables are |v| (label 
%   of vertex in \word{network}), |u| (label of vertex in a network 
%   being substituted, or the empty string), and |e| (label of edge). 
%   |v| and |u| identify the head vertex of the edge |e|, whereas the 
%   goal is to find the vertex at the tail.
%   \begin{tcl}
   set E {}
   foreach item [array names VA] {
      set i -1; foreach e [lindex $V $VA($item) 2] {incr i
         set edge [list $VA($item) $i]
         lset V $VA($item) 2 $i [llength $E]
         foreach {v u} $item break
         while 1 {
            if {$u ne ""} then {
               if {[lindex $NWL $v 1 $e 2] >= 2} then {
                  set tail $VA([list $v [lindex $NWL $v 1 $e 2]])
                  set tailidx [lindex $NWL $v 1 $e 3]
                  break
               }
               set e [lindex $NW 0 $v 2 [lindex $NWL $v 1 $e 3]]
               set u ""
            } else {
               set v [lindex $NW 1 $e 2]
               if {![llength [lindex $NWL $v]]} then {
                  set tail $VA([list $v])
                  set tailidx [lindex $NW 1 $e 3]
                  break
               }
               set e [lindex $NWL $v 0 0 2 [lindex $NW 1 $e 3]]
               set u 0
            }
         }
         lappend edge $tail $tailidx
         lset V $tail 1 $tailidx [llength $E]
         lappend E $edge
      }
   }
   return [list $V $E]
}
%   \end{tcl}
% \end{proc}
% 
% Rewriting requires more complicated substitutions where several 
% vertices are replaced by some network, but the formal justification 
% for that is quite different. The next section treats these more 
% adventurous modifications.
% 
% 
% \subsection{Surgery on networks}
% \label{Ssec:Regionkirurgi}
% 
% Rewriting and splicing requires that networks are taken apart and new 
% pieces inserted. For that, it is necessary that one can identify 
% specific regions within the network as the parts to detach and 
% replace with new pieces. A \emph{region} in a given network is 
% technically specified as a list with the structure
% \begin{displaysyntax}
%   \word{vertex-list} \word{output-list} \word{input-list}
% \end{displaysyntax}
% where the \word{vertex-list} is the list (in no particular order) 
% of labels of the vertices in the piece, \word{output-list} is the 
% list of labels of output edges, and \word{input-list} is the list 
% of labels of input edges. The vertices are needed because a region 
% may include entire components in the network. The outputs and 
% inputs are needed (i)~because the order of these must be specified 
% and (ii)~because regions may include stray edges that go directly 
% from input to output. The \word{vertex-list} must not include |0| 
% or~|1|.
% 
% A related concept is that of an \emph{embedding} of a network $H$ in 
% another network $G$. This is encoded as a list
% \begin{displaysyntax}
%   \word{vertex-map} \word{edge-map} \word{target-size}
% \end{displaysyntax}
% where the \word{vertex-map} is a list indexed by vertex labels in 
% $H$ giving the label of the corresponding vertex in $G$, the 
% \word{edge-map} is a list indexed by edge labels in $H$ giving the 
% label of the corresponding edge in $G$, and \word{target-size} is 
% the total number of edges in $G$. The first two elements of the 
% \word{vertex-map} are arbitrary; some procedures set them to |x| to 
% signal that it would be an error to use them as indices.
% 
% The practical difference between the two concepts is in the point 
% of view they provide of the subnetwork in question. A region 
% describes the subnetwork from the outside, fixing the boundary so 
% that another network can replace it. An embedding describes the 
% subnetwork from the inside, making it possible to speak about parts 
% of a subnetwork. Embeddings are often computed when a supernetwork 
% is constructed from a known network, and one wants to keep track of 
% features from the original network appearing in the supernetwork. 
% Embeddings and regions are to some extent interchangeable, but 
% conversions back and forth require knowledge about the networks 
% that are involved, so they should not be undertaken without good 
% reason. 
% 
% 
% \paragraph{Edge concatenation}
% 
% More formally, one could say an embedding $b$ describes a semigraph 
% homomorphism \(H \Fpil G\), whereas a region $r$ does the same up 
% to automorphisms of $H$. These homomorphism are injective on 
% vertices and inner edges, \emph{but may concatenate legs}.
% 
% ---
% 
% A more formal definition of a \word{region} as above would be that 
% it is a semigraph monomorphism, embedding one network $H$ as a 
% subnetwork of another network $G$, although that is in two ways an 
% oversimplification. To begin with, it doesn't give a mapping for 
% the edges of $H$\Ldash it only says what the boundary edges are 
% mapped to, and even that only indirectly\Dash but the edge mapping 
% can be computed as long as the domain $H$ and codomain $G$ networks 
% are known. Furthermore (and of greater practical importance), knowing 
% only $G$ still identifies $H$ up to internal isomorphism. The 
% second issue is trickier: the codomain is technically not the 
% network $G$ for which the \word{region} is given, but a subdivision 
% $G'$ of $G$, where edge $e$ of $G$ is subdivided into edges $e$, 
% $e+m$, $e+2m$, etc.~and $m$ is the number of edges in $G$. This 
% contortion is motivated as follows.
% 
% The naive definition of region (i.e., without subdivision) is 
% complicated by the general principle (which AFAICT is a good one) 
% that a splice map should be possible to express using the result of 
% said splice map\Dash that there for all \(H \sqsubseteq G\) 
% and \(\partial K = \partial H\) should exist some \(H' \sqsubseteq 
% (G \div\nobreak H)(K)\) such that \((G \div\nobreak H)(K) \div H' 
% \simeq G \div H\). Consider first a network like
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {|\\
%   |  y \r z \r y \r z \r y \r z \r y|\\
%   |}|
% \end{quote}
% Cutting out the |z|s of this network (which together constitute a 
% network
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {z z z}|
% \end{quote}
% ) and replacing them with identities (collectively a network
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {. . .}|
% \end{quote}
% ) reduces this to
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {|\\
%   |  y \r y \r y \r y|\\
%   |}|
% \end{quote}
% In order to be able to restore the original network, it must 
% therefore be possible to describe regions containing isolated edges. 
% This can be conveniently expressed by listing the same edge label as 
% input and output.
% 
% A second complicating principle, which is quite essential to the 
% whole theory, is that vertex-disjoint parts of a network should 
% be possible to replace independently of each other (this is 
% effectively the idea that $G \div H_1 \div H_2$ at all exists). As 
% it in the above network
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {|\\
%   |  y \r z \r y \r z \r y \r z \r y|\\
%   |}|
% \end{quote}
% is possible to replace the two middle |y|s by |z| and |z \r y| (in 
% terms of the subnetworks,
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {y y}|
% \end{quote}
% by
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {z z \r . y}|
% \end{quote}
% ) to yield
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {|\\
%   |  y \r z \r z \r z \r z \r y \r z \r y|\\
%   |}|
% \end{quote}
% the same thing must be possible in
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {|\\
%   |  y \r y \r y \r y|\\
%   |}|
% \end{quote}
% and result in 
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {|\\
%   |  y \r z \r z \r y \r y|\\
%   |}|
% \end{quote}
% Note that the two |y|s in this case are not adjacent in the 
% subnetwork being replaced, although they are adjacent in the 
% network where the replacement takes place. Regions must thus be 
% able to adress the ends of an edge separately, as well.
% 
% This gets even messier if one insterts an extra stage in which the 
% two |y|s are first replaced by identities (to yield
% \begin{quote}
%   |network::pure::construct {y {1 1} z {1 1}} {y y}|
% \end{quote}
% ) and then these two identities are replaced by |z| and |z \r y| 
% as above, as this should result in the same network as before; the 
% |z| is apparently replacing one part of the middle edge, whereas 
% the |z \r y| is replacing another, subsequent part. Still more 
% tricks can be played, and the outcome is that any edge can be 
% considered a remnant of an arbitrarily long path, in which any 
% subset of vertices must be possible to reinsert. A region can thus 
% contain as separate components (i)~the tail of an edge, (ii)~the 
% head of an edge, and (iii)~any number of disjoint pieces in 
% between. It is furthermore necessary to encode the relative order of 
% the middle pieces, as this is of importance when different things 
% are substituted for them! This requires a slight extension of the 
% \word{output-list} and \word{input-list}.
% 
% The solution used is to make the elements of the \word{output-list} 
% and \word{input-list} be integers on the form $l + mi$, where $m$ 
% is the number of edges in the \word{network} and \(l < m\) is the 
% actual label of the underlying edge. $i$ is an index for the 
% piece in this region of the edge, starting at $0$ for the piece 
% closest to the tail side. An input and an output with the same $i$ 
% value are thus connected (from input to output), whereas there is 
% a cut between output $l+mi$ and input $l+mi+m$. Following these 
% instructions is luckily rather easy when one gets down to it 
% (constructing them may be a different matter).
% 
% \begin{proc}{uncover}
%   The |uncover| procedure returns the subnetwork indicated 
%   by a region specification, as described above. The call syntax is
%   \begin{quote}
%     |network::pure::uncover| \word{network} \word{region} 
%   \end{quote}
%   
%   The algorithm is focuses on the \word{vertices}, which are 
%   processed in the order specified. Edges are appended to the result 
%   vertex when an incident vertex is encountered. The |IA| and |OA| 
%   arrays map \word{network} edge labels to input and output indices 
%   for the corresponding leg in the result. The |IL| and |OL| lists 
%   are the \word{out-edges} of the result input vertex and 
%   \word{in-edges} of the result output vertex, under construction 
%   (with unassigned elements set to negative numbers). The |EA| array 
%   maps \word{network} edge labels to result edge labels; it only has 
%   entries for edges that are going to be internal, as these are the 
%   only ones that need to be handled twice.
%   
%   \begin{tcl}
proc network::pure::uncover {NW region} {
   foreach {X L0 L1} $region break
   set OL {}
   foreach e $L0 {
      set OA($e) [llength $OL] 
      lappend OL -1
      
   }
   set m [llength [lindex $NW 1]]
   set IL {}
   foreach e $L1 {
      set l [expr {$e % $m}]
      if {![info exists IA($l)] || [lindex $IL $IA($l)]+$e >= 0} then {
         set IA($l) [llength $IL]
      }
      lappend IL [expr {-1-$e}]
   }
%   \end{tcl}
%   When initialising |IA|, the $mi$ term that may be present in 
%   the \word{input-list} |L1| must be removed. There is no such 
%   need for |OA|, as a region output attached to a vertex is always 
%   the tail end of its edge and thus has \(i=0\). It is however only 
%   the contribution for the last segment on an edge that should be 
%   found in |IA| (since this is the only one that can touch a 
%   vertex), so the |IL| elements are set to $-1-e$ and an |IA| entry 
%   should only be updated if the new $e$ is greater than the one in 
%   the |IL| element that the |IA| entry points to.
%   
%   \changes{2}{2007/05/20}{Fixed initialisation of \texttt{IA} 
%      array; it is the leg with greatest piece index that should 
%      determine the entry for an edge. (LH)}
%   
%   Main loop over vertices inducing subnetwork:
%   \begin{tcl}
   set V {{"" {} OL} {"" IL {}}}
   set E {}
   foreach x $X {
%   \end{tcl}
%   Copy vertex annotation:
%   \begin{tcl}
      set v [list [lindex $NW 0 $x 0]]
%   \end{tcl}
%   Build out-edges list for vertex:
%   \begin{tcl}
      set L {}
      foreach e [lindex $NW 0 $x 1] {
         if {[info exists OA($e)]} then {
            set m [llength $E]
            lappend E [list 0 $OA($e) [llength $V] [llength $L]]
            lappend L $m
            lset OL $OA($e) $m
         } elseif {[info exists EA($e)]} then {
            lset E $EA($e) 2 [llength $V]
            lset E $EA($e) 3 [llength $L]
            lappend L $EA($e)
         } else {
            set EA($e) [llength $E]
            lappend E [list x i [llength $V] [llength $L]]
            lappend L $EA($e)
         }
      }
      lappend v $L
%   \end{tcl}
%   Build in-edges list for vertex:
%   \begin{tcl}
      set L {}
      foreach e [lindex $NW 0 $x 2] {
         if {[info exists IA($e)]} then {
            set m [llength $E]
            lappend E [list [llength $V] [llength $L] 1 $IA($e)]
            lappend L $m
            lset IL $IA($e) $m
         } elseif {[info exists EA($e)]} then {
            lset E $EA($e) 0 [llength $V]
            lset E $EA($e) 1 [llength $L]
            lappend L $EA($e)
         } else {
            set EA($e) [llength $E]
            lappend E [list [llength $V] [llength $L] x i]
            lappend L $EA($e)
         }
      }
      lappend v $L
      lappend V $v
   }
%   \end{tcl}
%   End of main loop.
%   
%   Attach edges from |1| to |0|, finish up. Here it is used that 
%   |OA| indices are actual elements of |L0|, rather than their 
%   remainders modulo the size of the graph.
%   \begin{tcl}
   set m -1; foreach e $L1 l $IL {incr m
      if {$l < 0} then {
         lset IL $m [llength $E]
         lset OL $OA($e) [llength $E]
         lappend E [list 0 $OA($e) 1 $m]
      }
   }
   lset V 0 2 $OL
   lset V 1 1 $IL
   return [list $V $E]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{detach}
%   The |detach| procedure is complementary to the |uncover| 
%   procedure, in that it returns the subnetwork consisting of all 
%   things that are left over when one removes a region of the network. 
%   The defining invariant is that if an |uncover|ed subnetwork is 
%   |annex|ed to the corresponding |detach|ed network, then the 
%   result should be isomorphic to the original network.
%   The call syntax is
%   \begin{quote}
%     |network::pure::detach| \word{network} \word{region} 
%   \end{quote}
%   
%   Again the algorithm focuses on the vertices, simply copying the 
%   vertices not in the \word{region} to the result network and 
%   attaching edges as necessary. The |XS| array has entries for the 
%   vertices which should not be included, and is used for skipping 
%   these. The |IA| and |OA| arrays map \word{network} edge labels 
%   (which in the case of |IA| may include an edge-piece index term) 
%   to input and output indices for the corresponding leg in the 
%   induced subnetwork. The |IL| and |OL| lists are the 
%   \word{out-edges} of the induced network input vertex and 
%   \word{in-edges} of the induced network output vertex respectively, 
%   under construction (with unassigned elements set to |-1|). |IL| 
%   will in the end be appended to the lists of output legs of the 
%   result and |OL| will in the end be appended to the list of input 
%   legs of the result; this is because an input of the induced 
%   subnetwork corresponds to a new output of the network from which 
%   the induced subnetwork is being detached. The |EA| array maps 
%   \word{network} edge labels to result edge labels; it only has 
%   entries for edges that are going to be internal, as these are the 
%   only ones that need to be handled twice.
%   
%   \begin{tcl}
proc network::pure::detach {NW region} {
   foreach {X L0 L1} $region break
   foreach x $X {set XS($x) ""}
   set m [llength [lindex $NW 1]]
   set OL {}
   foreach e $L0 {
      set l [expr {$e % $m}]
      if {![info exists OA($l)] || [lindex $OL $OA($l)]+$e>=0} then {
         set OA($l) [llength $OL]
      }
      lappend OL [expr {-1-$e}]
      
   }
   set IL {}
   foreach e $L1 {
      set IA($e) [llength $IL]
      lappend IL -1
   }
%   \end{tcl}
%   \changes{2}{2007/05/20}{Fixed initialisation of \texttt{OA} 
%      array; it is the leg with greatest piece index that should 
%      determine the entry for an edge. (LH)}
%   Main loop over vertices. Note that |0| and |1| can be treated as 
%   ordinary vertices here.
%   \begin{tcl}
   set V {}
   set E {}
   set x -1; foreach u [lindex $NW 0] {incr x
      if {[info exists XS($x)]} then {continue}
%   \end{tcl}
%   Copy vertex annotation:
%   \begin{tcl}
      set v [lrange $u 0 0]
%   \end{tcl}
%   Build out-edges list for vertex:
%   \begin{tcl}
      set L {}
      foreach e [lindex $u 1] {
         if {[info exists IA($e)]} then {
            set n [llength $E]
            lappend E [list 0 ? [llength $V] [llength $L]]
            lappend L $n
            lset IL $IA($e) $n
         } elseif {[info exists EA($e)]} then {
            lset E $EA($e) 2 [llength $V]
            lset E $EA($e) 3 [llength $L]
            lappend L $EA($e)
         } else {
            set EA($e) [llength $E]
            lappend E [list x i [llength $V] [llength $L]]
            lappend L $EA($e)
         }
      }
      lappend v $L
%   \end{tcl}
%   Build in-edges list for vertex:
%   \begin{tcl}
      set L {}
      foreach e [lindex $u 2] {
         if {[info exists OA($e)]} then {
            set n [llength $E]
            lappend E [list [llength $V] [llength $L] 1 ?]
            lappend L $n
            lset OL $OA($e) $n
         } elseif {[info exists EA($e)]} then {
            lset E $EA($e) 0 [llength $V]
            lset E $EA($e) 1 [llength $L]
            lappend L $EA($e)
         } else {
            set EA($e) [llength $E]
            lappend E [list [llength $V] [llength $L] x i]
            lappend L $EA($e)
         }
      }
      lappend v $L
      lappend V $v
   }
%   \end{tcl}
%   End of main loop.
%   
%   Create edge-pieces which have a region boundary at both ends.
%   \begin{tcl}
   set n -1; foreach e $L0 l $OL {incr n
      if {$l < 0} then {
         lset OL $n [llength $E]
         set l $IA([expr {$e+$m}])
         lset IL $l [llength $E]
         lappend E [list 0 $l 1 $n]
      }
   }
%   \end{tcl}
%   Complete the lists of result inputs and outputs with those from 
%   |OL| and |IL|, also reset head and tail indices for these edges.
%   \begin{tcl}
   set L [lindex $V 0 2]
   foreach e $IL {
      lset E $e 1 [llength $L]
      lappend L $e
   }
   lset V 0 2 $L
   set L [lindex $V 1 1]
   foreach e $OL {
      lset E $e 3 [llength $L]
      lappend L $e
   }
   lset V 1 1 $L
   return [list $V $E]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{annex}
%   The |annex| procedure connects some outputs of one network to the 
%   inputs of a second, and then the outputs of the second back to some 
%   inputs of the first, resulting in feedback. It is the responsibility 
%   of the caller to ensure that this does not create a loop in the 
%   network, as this procedure does not check for cycles.
%   
%   The call syntax is
%   \begin{quote}
%     |network::pure::annex| \word{network $G$} \word{network $H$}
%   \end{quote}
%   and the result is a combined network $G 
%   \mathbin{\rlap{$\nwarrow$}{\nearrow\mkern-4mu\downarrow\mkern-2mu}} 
%   H$. If $G$ is of type 
%   $(m,n)$ and $H$ is of type $(k,l)$ then the result will be of type 
%   $(m -\nobreak l, n -\nobreak k)$, where the outputs of the result 
%   are the same as the $m-l$ first outputs of $G$ and the inputs of 
%   the result are the same as the $n-k$ first inputs of $G$. Input $i$ 
%   of $H$ is connected to output $m-l+i$ of $G$ and output $j$ of $H$ 
%   is connected to input $n-k+j$ of $G$.
%   
%   The most complicated part of the annexation operation is that the 
%   thing at the end of an edge may be\Ldash another edge (if the 
%   first edge was a leg connected to the other operand)\Dash and the 
%   thing at the other end of that may be yet another edge, etc. (The 
%   extreme situation is to have as $H$ a permutation and as $G$ the 
%   result of detaching all vertices in a long path while cutting the 
%   intermediate edges, which produces a result with exactly one edge 
%   since all of them join up.) Therefore the algorithm is 
%   edge-oriented\Ldash always producing finished edges, whereas the 
%   vertices are created bit by bit\Dash even though the main loop 
%   still is over the vertices. There is a |VA| array with indices of 
%   the form |0,|\meta{label} and |1,|\meta{label} that maps 
%   operand vertex labels to result vertex labels; a vertex has 
%   been created (with all sublists of their final length) if it has 
%   an entry in this array.
%   
%   The main idea in the algorithm is to look at a vertex and follow 
%   all edges out from it to the next vertex. An auxilliary idea is 
%   to split the |0| and |1| vertices of $G$ into two parts, where 
%   what gets left in |0| and |1| keeps track of edges connected to 
%   $H$ (with identical head--tail indices) and two new vertices keep 
%   track of what will become the output and input vertices of the 
%   result.
%   
%   \begin{tcl}
proc network::pure::annex {args} {
   if {[llength $args] != 2} then {
      return -code error "wrong # args: should be \"[
         lreplace [info level 0] 1 end G H
      ]\""
   }
%   \end{tcl}
%   In the main loop, there is no practical difference between $G$ and 
%   $H$. Hence it is convenient to have a list of these two parts and 
%   let a |part| variable containing an index specify the operand 
%   currently considered.
%   
%   The following splits vertices |0| and |1|.
%   \begin{tcl}
   set V [lindex $args 0 0]
   set VA(0,[llength $V]) 0
   set L [lindex $V 0 2]
   set n [expr {[llength $L] - [llength [lindex $args 1 0 1 1]]}]
   set np [expr {$n-1}]
   foreach e [lrange $L 0 $np] {lset args 0 1 $e 0 [llength $V]}
   lappend V [list "" {} [lrange $L 0 $np]]
   lset V 0 2 [lrange $L $n end]
   foreach e [lindex $V 0 2] {
      lset args 0 1 $e 1 [expr {[lindex $args 0 1 $e 1] - $n}]
   }
   set VA(0,[llength $V]) 1
   set L [lindex $V 1 1]
   set n [expr {[llength $L] - [llength [lindex $args 1 0 0 2]]}]
   set np [expr {$n-1}]
   foreach e [lrange $L 0 $np] {lset args 0 1 $e 2 [llength $V]}
   lappend V [list "" [lrange $L 0 $np] {}]
   lset V 1 1 [lrange $L $n end]
   foreach e [lindex $V 1 1] {
      lset args 0 1 $e 3 [expr {[lindex $args 0 1 $e 3] - $n}]
   }
   lset args 0 0 $V
   set V [lrange $V end-1 end]
%   \end{tcl}
%   The last command set up preliminary contents for the result output 
%   and input vertices, to be consistent with the initialisations of 
%   |VA|. Now the main loop will take care of everything!
%   \begin{tcl}
   set E {}
   foreach part {0 1} {
      set n 1; foreach v [lrange [lindex $args $part 0] 2 end] {incr n
         if {![info exists VA($part,$n)]} then {
            set VA($part,$n) [llength $V]
            lappend V $v
         }
         set i -1; foreach l [lindex $v 1] {incr i
%   \end{tcl}
%   The following is the main part of the main loop: follow one 
%   out-edge through to the vertex at the other end (which gets created 
%   if necessary), make the vertices point to the edge, and create it. 
%   The while loop is sure to terminate (unless the networks are 
%   inconsistent) even if the annexing creates a closed loop edge 
%   (which can happen for inappropriate arguments) because the edges 
%   looked at begin in a vertex and must therefore also end in a 
%   vertex. Closed loop edges are silently forgotten.
%   \begin{tcl}
            lset V $VA($part,$n) 1 $i [llength $E]
            set p $part
            while {[
               set e [lindex $args $p 1 $l]
               lindex $e 0
            ] == 0} {
               set p [expr {!$p}]
               set l [lindex $args $p 0 1 1 [lindex $e 1]]
            }
            if {![info exists VA($p,[lindex $e 0])]} then {
               set VA($p,[lindex $e 0]) [llength $V]
               lappend V [lindex $args $p 0 [lindex $e 0]]
            }
            lset V $VA($p,[lindex $e 0]) 2 [lindex $e 1] [llength $E]
            lappend E [list $VA($p,[lindex $e 0]) [lindex $e 1]\
              $VA($part,$n) $i]
         }
      }
   }
   return [list $V $E]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{replace}
%   For completeness, here is a procedure for replacing a region in a 
%   network, thus computing $(G \div\nobreak H)(K)$. The call syntax is
%   \begin{quote}
%     |network::pure::replace| \word{network $G$} \word{region} 
%     \word{network $K$}
%   \end{quote}
%   and the return value is the result network.
%   \begin{tcl}
proc network::pure::replace {G region K} {
   if {[llength [lindex $region 1]] != [llength [lindex $K 0 0 2]]}\ 
   then {
      error "Wrong number of outputs in replacement network"
   }
   if {[llength [lindex $region 2]] != [llength [lindex $K 0 1 1]]}\ 
   then {
      error "Wrong number of inputs in replacement network"
   }
   annex [detach $G $region] $K
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{forward_region}
%   The |forward_region| procedure pushes a region forward over an 
%   embedding, returning the corresponding region in the embedding's 
%   target network. The call syntax is
%   \begin{displaysyntax}
%     |network::pure::forward_region| \word{embedding} \word{region}
%   \end{displaysyntax}
%   
%   This is mostly a matter of translating the \word{region} labels 
%   using the \word{embedding}, but there is a slight complication in 
%   that an edge may be composed from several segments. Therefore the 
%   first step collects pairs `\word{embedding-label} 
%   \word{region-label}' by the real target edge to which they refer 
%   in the |E| array. Then the |P| array, which maps such pairs to 
%   final edge-segment labels, is filled in accordingly.
%   \begin{tcl}
proc network::pure::forward_region {emb reg} {
   set mg [lindex $emb 2]
   set mh [llength [lindex $emb 1]]
   foreach L [list [lindex $reg 1] [lindex $reg 2]] var {p0L p1L} {
      set $var {}
      foreach eh $L {
         set eg [lindex $emb 1 [expr {$eh % $mh}]]
         set p [list $eg $eh]
         lappend E([expr {$eg % $mg}]) $p
         lappend $var $p
      }
   }
   foreach i [array names E] {
      set mj 0
      foreach p [
         lsort -index 0 -integer [lsort -index 1 -integer\
           [lsort -unique $E($i)]]
      ] {
         set P($p) [expr {$i + $mj}]
         incr mj $mg
      }
   }
   set L {}
   foreach v [lindex $reg 0] {lappend L [lindex $emb 0 $v]}
   set res [list $L]
   set L {}
   foreach p $p0L {lappend L $P($p)}
   lappend res $L
   set L {}
   foreach p $p1L {lappend L $P($p)}
   lappend res $L
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{Decomposing networks}
% 
% For some applications, it is important to take networks apart into 
% smaller pieces (while still keeping these pieces natural).
% 
% \begin{proc}{inner_components}
%   This procedure decomposes a network into its components with 
%   respect to internal edges. The call syntax is
%   \begin{quote}
%     |inner_components| \word{network}
%   \end{quote}
%   and the return value is a list
%   \begin{displaysyntax}
%     \word{$\sigma$} \word{components} \word{k} \word{$\tau$}
%   \end{displaysyntax}
%   where $\sigma$ and $\tau$ are permutations, $k$ is an integer, 
%   and \word{components} is a list of networks. These are such that
%   \begin{equation*}
%     \sigma \cdot \left( 
%     \bigotimes_{G \in \text{\word{components}}} G 
%     \otimes \phi(\same{k}) \right) \cdot \tau
%   \end{equation*}
%   is equivalent to the original \word{network}.
%   
%   The components appear in vertex label order, so the first 
%   contains vertex $2$, the second the minimal vertex which is not 
%   in the first, and so on. The permutations $\sigma$ and $\tau$ 
%   does not change the relative order of edges within a component; 
%   this helps to avoid \emph{creating} crossings.
%   
%   The first step is a loop to determine to which component the 
%   various vertices and edges should belong, but one might as well 
%   use it to construct the components since mapping one anyway 
%   requires visiting all its vertices and edges. |CL| is thus the 
%   list of components being constructed, in the form of finished 
%   networks. |V| and |E| are lists of vertices and edges in the 
%   component currently being constructed; these are at first not so 
%   finished. |queue| is a list of items, in one of the forms
%   \begin{quote}
%     |vertex| \word{original-label}\\
%     |edge| \word{original-label}
%   \end{quote}
%   to add to the component. The |Vto| and |Eto| arrays are indexed by 
%   original-label and map this to the pair of component number and 
%   new label; entries are added to these arrays when they have been 
%   added to |V| or |E|. The data in the |base| and |baseL| variables 
%   are used later when constructing $\tau$; it is the offset from 
%   component input indices to full tensor product input indices.
%   \begin{tcl}
proc network::pure::inner_components {NW} {
   array set Vto {0 {x 0} 1 {x 1}}
   set CL {}
   set base 0
   set baseL {}
   set outLL {}
   for {set u 2} {$u < [llength [lindex $NW 0]]} {incr u} {
      if {[info exists Vto($u)]} then {continue}
      set V {x x}
      set E {}
      set queue [list [list vertex $u]]
      for {set n 0} {$n < [llength $queue]} {incr n} {
         foreach {type label} [lindex $queue $n] break
         switch -- $type "vertex" {
            if {[info exists Vto($label)]} then {continue}
            lappend Vto($label) [llength $CL] [llength $V]
            lappend V [lindex $NW 0 $label]
            foreach e [concat [lindex $V end 1] [lindex $V end 2]] {
               lappend queue [list edge $e]
            }
         } "edge" {
            if {[info exists Eto($label)]} then {continue}
            lappend Eto($label) [llength $CL] [llength $E]
            lappend E [lindex $NW 1 $label]
            lappend queue [list vertex [lindex $E end 0]]\
              [list vertex [lindex $E end 2]]
         }
      }
%   \end{tcl}
%   Finishing the vertices means updating the edge labels. In the 
%   case of the external vertices it also means updating head or tail 
%   indices, since these are generally not the same.
%   \begin{tcl}
      set V2 {}
      set Lo {}
      set outL {}
      foreach e [lindex $NW 0 0 2] {
         if {[info exists Eto($e)] &&\
           [lindex $Eto($e) 0]==[llength $CL]} then {
            lset E [lindex $Eto($e) 1] 1 [llength $Lo]
            lappend Lo [lindex $Eto($e) 1]
            lappend outL $e
         }
      }
      lappend outLL $outL
      lappend V2 [list {} {} $Lo]
      set Li {}
      foreach e [lindex $NW 0 1 1] {
         if {[info exists Eto($e)] &&\
           [lindex $Eto($e) 0]==[llength $CL]} then {
            lset E [lindex $Eto($e) 1] 3 [llength $Li]
            lappend Li [lindex $Eto($e) 1]
         }
      }
      lappend V2 [list {} $Li {}]
      lappend baseL $base
      incr base [llength $Li]
      foreach v [lrange $V 2 end] {
         set v2 [lrange $v 0 0]
         set Lo {}
         foreach e [lindex $v 1] {lappend Lo [lindex $Eto($e) 1]}
         lappend v2 $Lo
         set Li {}
         foreach e [lindex $v 2] {lappend Li [lindex $Eto($e) 1]}
         lappend v2 $Li
         lappend V2 $v2
      }
%   \end{tcl}
%   Finishing the edges conversely means updating the vertex labels 
%   of the endpoints. Here it is useful to have |0| and |1| in the 
%   |Vto| array.
%   \begin{tcl}
      set E2 {}
      foreach e $E {
         lappend E2 [list [lindex $Vto([lindex $e 0]) 1] [lindex $e 1]\
           [lindex $Vto([lindex $e 2]) 1] [lindex $e 3]]
      }
      lappend CL [list $V2 $E2]
   }
%   \end{tcl}
%   Next comes the construction of $\tau$. This follows the original 
%   list of network inputs and stores a list of old edge labels for 
%   stray edges in the |E| variable.
%   \begin{tcl}
   set E {}
   set tau {}
   foreach e [lindex $NW 0 1 1] {
      if {[info exists Eto($e)]} then {
         lappend tau [expr {[lindex $baseL [lindex $Eto($e) 0]] +\
           [lindex $CL [lindex $Eto($e) 0] 1 [lindex $Eto($e) 1] 3]}]
      } else {
         lappend tau [expr {$base + [llength $E]}]
         lappend E $e
      }
   }
%   \end{tcl}
%   The sought $k$ is now the length of |E|. Finally there is the 
%   construction of $\sigma$, which employs the per-component list 
%   |outLL| of old-labels of output edges.
%   \begin{tcl}
   lappend outLL $E
   set sigma {}
   foreach outL $outLL {
      foreach e $outL {
         lappend sigma [lindex $NW 1 $e 1]
      }
   }
   return [list $sigma $CL [llength $E] $tau]
}
%   \end{tcl}
% \end{proc}
% 
% 
% The following aims to discover natural blocks in a network which 
% have low connectivity to the rest of it. One important application 
% of this is the evaluation of networks as expressions in some \PROP, 
% since the complexity of the basic operations on elements of a 
% linear \PROP\ tends to grow exponentially with the arities and 
% coarities involved. If natural blocks in the network can be found 
% an exploited as subexpressions then the number of operations on the 
% full width of the network can usually be reduced, and sometimes the 
% maximal width with which one has to deal can be reduced as well.
% 
% The primary concept used is that of a \emph{sparsest cut} in the 
% network: one for which 
% \begin{equation}
%   \Phi(S) = \frac{ 
%     \Bigl\lvert \setOf[\big]{ uv \in \GE(G) }{ u \in S, v \notin S }
%     \Bigr\rvert
%   }{ \min\bigl\{ \lvert S\rvert, \lvert \GV(G) \setminus S \rvert
%     \bigr\rvert
%   }
%   \qquad\text{for \(S \subseteq \GV(G)\)}
% \end{equation}
% (proportion of edges in cut to vertices in the smaller partition 
% created by the cut) attains its minimum. Computing this is NP-hard, 
% but efficient polynomial approximation methods 
% exist~\cite{AroraLeeNaor}, although they involve solving a 
% semidefinite program. At least to start with, a straightforward 
% enumeration will probably suffice.
% 
% 
% \begin{proc}{sparsest_cut}
%   This procedure computes the sparsest nontrivial cut in a network, 
%   and returns it in the form of a region. The call syntax is merely
%   \begin{quote}
%     |sparsest_cut| \word{network}
%   \end{quote}
%   The algorithm is a straightforward enumeration, with a few 
%   restrictions on the regions that are considered:
%   \begin{itemize}
%     \item
%       The region must be connected, since if a nonconnected region 
%       attains the minimum then it must be a union of two regions 
%       which both attain the minimum. In such situations, one would 
%       probably rather want to find one of these components.
%     \item
%       The region must contain at least two vertices, since the 
%       single vertex cuts are often uninteresting and anyway easy to 
%       compute separately, nor may it be the entire network.
%     \item
%       The region contains all intervals between region vertices; no 
%       path in the network may intersect the region more than once. 
%       This ensures that the region can be contracted to a vertex.
%   \end{itemize}
%   If such a region exists then the sparsest such region is returned, 
%   otherwise the result is an empty list is returned. The general 
%   case in which no such region exists is that the network is a 
%   tensor product of networks with at most one component each.
%   
%   When computing the sparsity of a cut, the two external vertices 
%   $0$ and $1$ (which may never be in the region, but matter for 
%   regions of more than half of the network) count as one vertex. 
%   This gives a nice symmetry to the nontriviality condition: the 
%   numerator in the sparsity calculation must be at least $2$.
%   
%   At the outermost level, the algorithm is a loop over the minimal 
%   label $v_0$ of a vertex in the region; this vertex is taken as 
%   the seed from which the region is grown. Within this is the loop 
%   over partial regions containing $v_0$; unprocessed partial 
%   regions are kept in a stack and each processing step decides 
%   whether one vertex adjacent to the partial region should be made 
%   part of it or not. The |stack| elements are lists with the 
%   structure
%   \begin{displaysyntax}
%     \word{vertex-list} \word{vertex-states} \word{out-edges} 
%     \word{in-edges} \word{down-edges} \word{up-edges}
%   \end{displaysyntax}
%   where \word{vertex-list}, \word{out-edges}, and \word{in-edges} 
%   are what will become the region. The \word{vertex-states} is a 
%   list indexed by vertex label, whose entries are |1|, |-1|, or |0| 
%   depending on whether the vertex is in the region, not in the 
%   region, or undecided respectively. The \word{down-edges} and 
%   \word{up-edges} are edges on the out-side or in-side respectively 
%   boundary of the partial region, for which it has not yet been 
%   determined whether they should be in the cut or not.
%   
%   \begin{proc}{sparsest_cut,exclude}
%     The |sparsest_cut,exclude| procedure is a helper of 
%     |sparsest_cut| which updates the \word{vertex-states} list with 
%     the information that something is outside the region. The call 
%     syntax is
%     \begin{quote}
%       |sparsest_cut,exclude| \word{network} \word{vertex-states} 
%       \word{vertex} \word{direction}
%     \end{quote}
%     where the \word{direction} is |down| or |up|, depending on 
%     which direction we're going in. The return value is a modified 
%     \word{vertex-states} list, where some |0| elements can have 
%     been changed to |-1|, or an empty list if there turned out to 
%     be some |1| in the requested direction.
%     \begin{tcl}
proc network::pure::sparsest_cut,exclude {NW vstate v dir} {
   switch -- $dir "down" {
      set vi 1
      set ei 0
   } "up" {
      set vi 2
      set ei 2
   } default {error "Unknown direction: $dir"}
   set queue [list $v]
   for {set n 0} {$n < [llength $queue]} {incr n} {
      set v [lindex $queue $n]
      switch -- [lindex $vstate $v] -1 {
         continue
      } 1 {
         return
      }
      lset vstate $v -1
      foreach e [lindex $NW 0 $v $vi] {
         lappend queue [lindex $NW 1 $e $ei]
      }
   }
   return $vstate
}
%     \end{tcl}
%     It is important that the set of excluded vertices always is the 
%     union of an up-set (filter) and a down-set (ideal), since 
%     detection of violations of the ``region contains its 
%     intervals'' conditions relies on this; the set of vertices to 
%     which the region cannot be extended because of this condition 
%     is simply the set of vertices which are already excluded.
%   \end{proc}
%   
%   \begin{tcl}
proc network::pure::sparsest_cut {NW} {
   set startstate {-1 -1}
   while {[llength $startstate] < [llength [lindex $NW 0]]} {
      lappend startstate 0
   }
   set best_sparse infinity
   for {set v0 2} {$v0 < [llength [lindex $NW 0]]-1} {incr v0} {
      set stack [list [
         list [list $v0] [lreplace $startstate $v0 $v0 1] {} {}\
           [lindex $NW 0 $v0 1] [lindex $NW 0 $v0 2] 
      ]]
      while {[llength $stack]} {
         foreach {vL vstate outL inL downL upL} [lindex $stack end] break
         set stack [lreplace $stack [set stack end] end]
%   \end{tcl}
%   The first step for a partial region is to look at its active 
%   boundary and pick a vertex to make a choice for. Concretely, the 
%   vertex is picked which has the largest number of neighbours 
%   within the region, since this feels like it should be a good 
%   strategy. While examining the active boundary, one may however 
%   discover that some edges are in fact no longer active, so |upL| 
%   and |downL| are rebuilt while we're at it.
%   \begin{tcl}
         set upL2 {}
         set downL2 {}
         array unset next
         foreach e $downL {
            set v [lindex $NW 1 $e 0]
            switch -- [lindex $vstate $v] -1 {
               lappend outL $e
            } 0 {
               lappend downL2 $e
               lappend next($v) $e down
            }
         }
         foreach e $upL {
            set v [lindex $NW 1 $e 2]
            switch -- [lindex $vstate $v] -1 {
               lappend inL $e
            } 0 {
               lappend upL2 $e
               lappend next($v) $e up
            }
         }
         if {![array size next]} then {
%   \end{tcl}
%   We're out of active edges, so apparently the region is complete. 
%   Time to compute its sparsity and compare it to the best so far.
%   \begin{tcl}
            set order [expr {[llength [lindex $NW 0]]\
              - [llength $vL] - 1}]
            if {$order>[llength $vL]} then {set order [llength $vL]}
            if {$order<2} then {continue}
            set s [expr {double([llength $inL] + [llength $outL]) /\
              $order}]
            if {$s < $best_sparse} then {
               set best_region [list $vL $outL $inL]
               set best_sparse $s
            }
            continue
         }
%   \end{tcl}
%   Otherwise it's time to pick a vertex $v_1$ to exclude from the 
%   region or expand the region with.
%   \begin{tcl}
         set maxdeg 0
         foreach {v L} [array get next] {
            if {$maxdeg<[llength $L]} then {
               set maxdeg [llength $L]
               set v1 $v
            }
         }
%   \end{tcl}
%   First the case of excluding $v_1$ (although due to the |stack| 
%   structure, the corresponding branch of the search tree will be 
%   processed last). The stack entry is somewhat dirty in that edges 
%   which are deactivated by this will still show appear in the 
%   active lists, but this gets cleaned up in the processing of that 
%   entry. Besides, it would be difficult to deactivate all edges 
%   explicitly since not all of them need to go to $v_1$.
%   \begin{tcl}
         set L [sparsest_cut,exclude $NW $vstate $v1\
           [lindex $next($v1) 1]]
         if {[llength $L]} then {
            lappend stack [list $vL $L $outL $inL $downL2 $upL2]
         }
%   \end{tcl}
%   Second, the case of including $v_1$. This only happens if 
%   \(v_1>v_0\), since $v_0$ is supposed to be the minimal vertex in 
%   the region.
%   \begin{tcl}
         if {$v1>$v0} then {
            lappend stack [
               list [linsert $vL end $v1]\
                 [lreplace $vstate $v1 $v1 1] $outL $inL\
                 [concat $downL2 [lindex $NW 0 $v1 1]]\
                 [concat $upL2 [lindex $NW 0 $v1 2]]
            ]
         }
      }
   }
   if {[info exists best_region]} then {
      return $best_region
   } else {
      return {}
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{contract_region}
%   This procedure contracts a network region to single vertex. The 
%   call syntax is
%   \begin{quote}
%     |contract_region| \word{network} \word{region} \word{annotation}
%   \end{quote}
%   and the return value is the modified \word{network}. The 
%   \word{region} must not have an in-edge below one of its 
%   out-edges; failing this requirement will create a network with a 
%   cycle.
%   
%   For the moment, this is implemented as an |annex|ation. Most of 
%   the code is just for constructing a single-vertex network.
%   \begin{tcl}
proc network::pure::contract_region {NW region annot} {
   set E {}
   set Li {}
   foreach i [lindex $region 2] {
      set e [llength $E]
      lappend E [list 2 [llength $Li] 1 [llength $Li]]
      lappend Li $e
   }
   set Lo {}
   foreach i [lindex $region 1] {
      set e [llength $E]
      lappend E [list 0 [llength $Lo] 2 [llength $Lo]]
      lappend Lo $e
   }
   set V [list [list "" {} $Lo] [list "" $Li {}] [list $annot $Lo $Li]]
   return [annex [detach $NW $region] [list $V $E]]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{decompose_2NW}
%   This procedure takes a network with two inner vertices and at 
%   least one inner edge as argument. It returns a list with the 
%   structure
%   \begin{displaysyntax}
%     twopart \word{$\rho$} \word{$A$} \word{$k$} \word{$\sigma$} 
%     \word{$B$} \word{$l$} \word{$\tau$}
%   \end{displaysyntax}
%   where $\rho$, $\sigma$, and $\tau$ are permutations, \(k,l \in 
%   \mathbb{N}\), and $A$ and $B$ are the vertex annotations. These 
%   are such that
%   \begin{equation*}
%     \phi(\rho) \circ A \otimes \phi(\same{k}) \circ 
%     \phi(\sigma) \circ B \otimes \phi(\same{l}) \circ \phi(\tau)
%   \end{equation*}
%   is equivalent to the original network.
%   
%   The first step is to sort out which vertex is which. This 
%   involves a loop over the edges, looking for one which has neither 
%   $0$ nor $1$ as endpoint.
%   \begin{tcl}
proc network::pure::decompose_2NW {NW} {
   foreach e [lindex $NW 1] {
      foreach {u "" v} $e break
      if {$u>1 && $v>1} then {break}
   }
%   \end{tcl}
%   Now $A$ will be the annotation of $u$ and $B$ will be the 
%   annotation of $v$.
%   \begin{tcl}
   set A [lindex $NW 0 $u 0]
   set B [lindex $NW 0 $v 0]
   set k [expr {[llength [lindex $NW 0 0 2]] -\
     [llength [lindex $NW 0 $u 1]]}]
   set l [expr {[llength [lindex $NW 0 1 1]] -\
     [llength [lindex $NW 0 $v 2]]}]
%   \end{tcl}
%   The tricky part is to compute the permutations. The idea is to 
%   keep a list of edges (in order) at the top of a level, and 
%   construct the list of edges below that level when looping over 
%   the previous list.
%   \begin{tcl}
   set tau {}
   set L [lindex $NW 0 $v 1]
   set i [llength [lindex $NW 0 $v 2]]
   foreach e [lindex $NW 0 1 1] {
      if {[lindex $NW 1 $e 0] == $v} then {
         lappend tau [lindex $NW 1 $e 1]
      } else {
         lappend tau $i
         lappend L $e
         incr i
      }
   }
   set sigma {}
   set L2 [lindex $NW 0 $u 1]
   set i [llength [lindex $NW 0 $u 2]]
   foreach e $L {
      if {[lindex $NW 1 $e 0] == $u} then {
         lappend sigma [lindex $NW 1 $e 1]
      } else {
         lappend sigma $i
         lappend L2 $e
         incr i
      }
   }
   set rho {}
   foreach e $L2 {
      lappend rho [lindex $NW 1 $e 1]
   }
%   \end{tcl}
%   Finally construct the result.
%   \begin{tcl}
   list twopart $rho $A $k $sigma $B $l $tau
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{blocktree_decompose}
%   This procedure converts a network to a binary tree composed only 
%   of |twopart| joins and annotation leaves. The two node types that 
%   can be had are thus
%   \begin{displaysyntax}
%     twopart \word{permutation} \word{down-child} \word{integer} 
%     \word{permutation} \word{up-child} \word{integer} 
%     \word{permutation}\par
%     atom \word{annotation}
%   \end{displaysyntax}
%   where the |twopart| form is as returned by the |decompose_2NW| 
%   procedure, except that \word{down-child} and \word{up-child} are 
%   again trees of this form, and each vertex of the original tree 
%   gives rise to exactly one |atom| node.
%   
%   The call syntax is
%   \begin{quote}
%     |blocktree_decompose| \word{network}
%   \end{quote}
%   where the \word{network} must be an inner component (connected 
%   after removal of extrenal vertices and edges).
%   
%   The idea is to find a sparsest cut, convert its region through a 
%   recursive call, contract it to a vertex, and repeat until there 
%   is less than three internal vertices left.
%   \begin{tcl}
proc network::pure::blocktree_decompose,recurse {NW} {
   while {[llength [lindex $NW 0]] > 4} {
      set region [sparsest_cut $NW]
      set NW [contract_region $NW $region [
         blocktree_decompose,recurse [uncover $NW $region]
      ]]
   }
   decompose_2NW $NW
}
proc network::pure::blocktree_decompose {NW} {
   set V {}
   foreach v [lindex $NW 0] {
      lappend V [lreplace $v 0 0 [list atom [lindex $v 0]]]
   }
   lset V 0 0 {}
   lset V 1 0 {}
   blocktree_decompose,recurse [lreplace $NW 0 0 $V]
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{Conversions}
% 
% The following procedures convert pure networks from and to the old 
% network format (which did not have explicit input and output 
% vertices, and embedded also a lot of graphical information). To 
% recall, the general structure of the oldstyle networks was as a 
% list
% \begin{quote}
%   \word{vertices} \word{edges} \word{legs} \word{info}
%   \word{other}\regstar
% \end{quote}
% The \word{vertices} here was a list of vertex descriptions and 
% \word{edges} was a list of edge descriptions. The \word{legs} was 
% a list 
% \begin{quote}
%   \word{output-legs} \word{input-legs} \word{other}\regstar
% \end{quote}
% where \word{output-legs} and \word{input-legs} were both lists of 
% indices into the \word{edges} list, specifying which edges are the 
% output and the input legs respectively. \word{info} was a dictionary 
% in which miscellaneous information could be stored (very little 
% actually was). Finally, the network and \word{legs} lists could 
% contain any number of the \word{other} elements, but the meanings of 
% these dependend on the commands that were operating on the network.
% 
% A \word{vertex-description} was a list
% \begin{quote}
%   \word{annotation} \word{incidence} \word{info} \word{other}\regstar
% \end{quote}
% where the \word{annotation} (as now) was a string, \word{incidence} 
% was a list of (indices of) those edges to which the vertex is incident 
% (in the order of the ports for this kind of vertex, without 
% distinction between input and output ports), and \word{info} was a 
% dictionary with miscellaneous information. As with networks as a 
% whole, the \word{other} elements were allowed, not required, and 
% completely unspecified.
% 
% An \word{edge-description} similarly was a list
% \begin{quote}
%   \word{out-vertex} \word{in-vertex} \word{info} \word{other}\regstar
% \end{quote}
% where \word{out-vertex} and \word{in-vertex} were the indices of the 
% vertices to which this edge was incident. In case this edge is input 
% leg $n$ (and its input thus is not attached to any vertex), the 
% \word{in-vertex} will be $-n-1$, and similarly in case this edge is 
% output leg $n$ (and its output thus is not attached to any vertex), 
% the \word{out-vertex} will be $-n-1$. As above, the \word{info} was 
% a dictionary with miscellaneous information and any \word{other} 
% elements were unspecified and not required.
% 
% 
% \begin{proc}{from_old}
%   This procedure converts an oldstyle network to a pure network. The 
%   call syntax is
%   \begin{quote}
%     |network::pure::from_old| \word{oldstyle-network}
%   \end{quote}
%   and the return value is the generated pure network. The conversion 
%   increases all vertex labels by $2$ and preserves the edge labels.
%   
%   The actual conversion is pretty straightforward; one only has to do 
%   a bit of peeking back and forth to determine whether a vertex port 
%   is an input or an output, and to figure out the head and tail 
%   indices of an edge.
%   \begin{tcl}
proc network::pure::from_old {ONW} {
   set V {}
   lappend V [list "" {} [lindex $ONW 2 0]]
   lappend V [list "" [lindex $ONW 2 1] {}]
   set label -1; foreach v [lindex $ONW 0] {incr label
      set N0 {}
      set N1 {}
      foreach i [lindex $v 1] {
         lappend N[expr {[lindex $ONW 1 $i 0] == $label}] $i
      }
      lappend V [list [lindex $v 0] $N0 $N1]
   }
   set E {}
   set label -1; foreach e [lindex $ONW 1] {incr label
      set N {}
      foreach v [lrange $e 0 1] v0 {0 1} i {2 1} {
         if {$v<0} then {
            lappend N $v0 [expr {-$v-1}]
         } else {
            incr v 2
            lappend N $v [lsearch -exact [lindex $V $v $i] $label]
         }
      }
      lappend E $N
   }
   return [list $V $E]
}
namespace eval network::pure {namespace export from_old}
%   \end{tcl}
% \end{proc}
% 
% 
% The opposite conversion is in principle a bit easier (since it is 
% not necessary to look into the list of vertices to convert an edge 
% or vice versa), but the possibility of mixing input and output 
% ports in the list of such means the pure network in itself does not 
% contain enough information to recreate the corresponding oldstyle 
% network; it is in general necessary to also have access to the 
% vertex-type array to know what is what. The entries in that array 
% are lists with the structure
% \begin{quote}
%   \word{I/O-list} \word{graphical information}
%   \word{other}\regstar
% \end{quote}
% The \word{I/O-list} specifies which positions in the 
% \word{incidences} list of this kind of vertex are inputs and which 
% are outputs. It has the same length as an \word{incidences} list, 
% and the elements are either |1| (if it is an input) or |0| (if it 
% is an output).
% 
% \begin{proc}{to_old}
%   The |to_old| procedure converts pure networks to corresponding 
%   oldstyle networks. The call syntax is
%   \begin{quote}
%     |network::pure::to_old| \word{pure network} 
%     \word{type-array}\regopt
%   \end{quote}
%   and the return value is the corresponding oldstyle network (with 
%   minimal contents). If provided, the \word{type-array} argument is 
%   the name in the calling context of the vertex-type array that 
%   should be used with the oldstyle network. If omitted, it is assumed 
%   that all outputs come first and all inputs follow.
%   
%   Complementary to the |from_old| procedure, this one preserves edge 
%   labels and decreases all vertex labels by $2$.
%   
%   \begin{tcl}
proc network::pure::to_old {NW {TAvar ""}} {
   if {$TAvar ne ""} then {
      array set TA [uplevel 1 [list ::array get $TAvar]]
   }
   set V {}
   foreach v [lrange [lindex $NW 0] 2 end] {
      if {![info exists TA([lindex $v 0])]} then {
         set L {}
         foreach i [lindex $v 1] {lappend L 0}
         foreach i [lindex $v 2] {lappend L 1}
         set TA([lindex $v 0]) [list $L {}]
      }
      set L {}
      set n0 0; set n1 0
      foreach i [lindex $TA([lindex $v 0]) 0] {
         if {$i} then {
            lappend L [lindex $v 2 $n1]
            incr n1
         } else {
            lappend L [lindex $v 1 $n0]
            incr n0
         }
      }
      lappend V [list [lindex $v 0] $L {}]
   }
   set E {}
   foreach e [lindex $NW 1] {
      set eold {}
      foreach {v i} $e {
         lappend eold [expr {$v>1 ? $v-2 : -$i-1}]
      }
      lappend E [lappend $eold {}]
   }
   return [list $V $E [list [lindex $NW 0 2] [lindex $NW 1 1]] {}]
}
namespace eval network::pure {namespace export to_old}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Comparing networks}
% 
% 
% \begin{proc}{tree_up_comparison}
%   This procedure implements a classical comparison that is most 
%   natural for trees (coarity $1$ networks) but could also be used 
%   as a helper for more complex orders. In order for it to be a 
%   compatible order, it must consider networks where corresponding 
%   paths are of different lengths as unrelated; were it not for this 
%   it would be total.
%   
%   The call syntax is
%   \begin{displaysyntax}
%     |network::pure::tree_up_comparison| \word{order} 
%       \word{left root} \word{right root} \word{left network} 
%       \word{right network}
%   \end{displaysyntax}
%   where \word{order} is the list of vertex decorations that may 
%   occur in the networks, in order from smallest to largest. 
%   \word{left root} and \word{right root} are the vertex labels for 
%   the roots of the trees to compare.
%   \begin{tcl}
proc network::pure::tree_up_comparison {orderL left_root right_root\
  left right} {
   set ll [lindex $left 0 $left_root 0]
   set lr [lindex $right 0 $right_root 0]
   if {$ll eq $lr} then {
      foreach el [lindex $left 0 $left_root 2]\
        er [lindex $right 0 $right_root 2] {
         set res [tree_up_comparison $orderL\
           [lindex $left 1 $el 2] [lindex $right 1 $er 2]\
           $left $right]
         if {$res ne "="} then {return $res}
      }
      return "="
   } else {
      if {$ll eq "" || $lr eq ""} then {return "incomparable"}
      foreach l $orderL {
         if {$ll eq $l} then {
            return "<"
         } elseif {$lr eq $l} then {
            return ">"
         }
      }
      error "Vertex types '$ll' and '$lr' not in '$orderL'"
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{height_tree_up_comparison}
%   \relax
%   [The correctness of this procedure is uncertain.]
%   
%   
%   This procedure extends |tree_up_comparison| to a more direct 
%   counterpart of deglex order, by first comparing the heights 
%   (measured from input to output, and from constants to outputs) of 
%   the tree before making a lexicographic comparison of the branches.
%   
%   The call syntax is
%   \begin{displaysyntax}
%     |network::pure::height_tree_up_comparison| \word{order} 
%     \word{left} \word{right}
%   \end{displaysyntax}
%   where \word{order} is passed on to |tree_up_comparison|.
%   
%   First comparison is by of number of constants (nullary vertices). 
%   This is a bit beside the point, but a necessary precondition for 
%   the subsequent comparison of heights of constants.
%   \begin{tcl}
proc network::pure::height_tree_up_comparison {orderL left right} {
   set lcL {}; set rcL {}
   foreach NW [list $left $right] Lvar {lcL rcL} {
      set n -1; foreach v [lindex $NW 0] {incr n
         if {$n>1 && ![llength [lindex $v 2]]} then {
            lappend $Lvar $n
         }
      }
   }
   if {[llength $lcL] < [llength $rcL]} then {
      return "<"
   } elseif {[llength $lcL] > [llength $rcL]} then {
      return ">"
   }
%   \end{tcl}
%   Second comparison is of heights of inputs. This is the main thing.
%   \begin{tcl}
   set lhL {}; set rhL {}
   foreach NW [list $left $right] Lvar {lhL rhL} {
      foreach e [lindex $NW 0 1 1] {
         set h 0
         while {[
            set eL [lindex $NW 0 [lindex $NW 1 $e 0] 1]
            llength $eL
         ]} {
            incr h
            set e [lindex $eL 0]
         }
         lappend $Lvar $h
      }
   }
   set res ""
   foreach lh $lhL rh $rhL {
      if {$lh < $rh} then {
         append res "<"
      } elseif {$lh > $rh} then {
         append res ">"
      } else {
         append res "="
      }
   }
   switch -regexp -- $res {^=*$} {
      # All equal; continue
   } {^[<=]*$} {
      return "<"
   } {^[>=]*$} {
      return ">"
   } default {
      return "incomparable 1 $res"
   }
%   \end{tcl}
%   Third comparison is of heights from constants, which is. This is necessary 
%   to preserve 
%   \begin{tcl}
   
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{grouplex_comparison}
%   This procedure is a generic utility for comparing things. The 
%   call syntax is
%   \begin{quote}
%     |network::pure::grouplex_comparison| \word{left} \word{right}
%   \end{quote}
%   where \word{left} and \word{right} are lists of comparison 
%   groups. A \emph{comparison group} is a list of items to be 
%   compared using the |expr| operations |<| and |>|, where 
%   corresponding comparison groups from \word{left} and \word{right} 
%   should have the same length. The return value is |=|, |<|, |>|, 
%   or |incomparable| depending on whether the left thing compares as 
%   equal, less than, greater than, or incomparable with the right 
%   thing.
%   
%   The comparison is lexicographic with respect to the groups\Ldash 
%   if one group has a strict inequality then the subsequent groups 
%   are not even considered\Dash but cartesian within the groups: one 
%   must have \(l_i \geqslant r_i\) for all $i$ within a group if the 
%   comparison is to come out as $\geqslant$ for the group.
%   
%   \begin{tcl}
proc network::pure::grouplex_comparison {left right} {
   set dom_l {}; set dom_r {}
   set groupno 0
   foreach L $left R $right {
      foreach l $L r $R {
         if {$l > $r} then {
            lappend dom_l $l
         } elseif {$l < $r} then {
            lappend dom_r $r
         }
      }
      if {[llength $dom_l]} then {
         if {[llength $dom_r]} then {
            return "incomparable $groupno"
         } else {
            return ">"
         }
      } elseif {[llength $dom_r]} then {
         return "<"
      }
      incr groupno
   }
   return "="
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{grouplex_compare}
%   This is a wrapper for the common task of making a group-lex 
%   comparison of some characteristics of two networks. The call 
%   syntax is
%   \begin{quote}
%     |network::pure::grouplex_compare| \word{cmdPrefix} 
%     \word{left network} \word{right network}
%   \end{quote}
%   where the \word{cmdPrefix} is a command prefix (evaluated in the 
%   calling context) with the syntax that
%   \begin{quote}
%     \meta{cmdPrefix} \word{network}
%   \end{quote}
%   returns a list of comparison groups for the \word{network}. The 
%   return value is the |grouplex_comparison| of what the 
%   \word{cmdPrefix} returns for the two network arguments.
%   \begin{tcl}
proc network::pure::grouplex_compare {cmd left right} {
   grouplex_comparison [
      uplevel 1 [linsert $cmd end $left]
   ] [
      uplevel 1 [linsert $cmd end $right]
   ]
}
%   \end{tcl}
% \end{proc}
% 
% The class of partial orders on networks that generalises the basic 
% length-lexicographic order on words turns out to be based on 
% considering all paths through the network (keeping track of inputs 
% and outputs).
% 
% \begin{proc}{compkey_paths-wdeg-lex}
%   This procedure computes a comparison key (a list of comparison 
%   groups) for a path--weighted-degree--lexicographic order on 
%   networks. The call syntax is
%   \begin{quote}
%     |network::pure::compkey_paths-wdeg-lex| 
%     \begin{regblock}[\regstar] \word{type} \word{annot-dict} 
%     \end{regblock} \word{network}
%   \end{quote}
%   where \word{type} is either |weight| or |deglex| and the 
%   following \word{weight-dict} is a dictionary mapping vertex 
%   annotations to the material it contributes in the specified 
%   comparison. The return value consists of $1+w+2l$ comparison 
%   groups, where $w$ is the number of |weight| \word{type}s and $l$ 
%   is the number of |deglex| \word{type}s.
%   
%   An \word{annot-dict} maps vertex annotations to contributions 
%   from vertices with these annotations to the comparison keys of 
%   paths. Annotations not mentioned in a dict count as giving a 
%   neutral contribution, which in the case of |weight| comparison is 
%   the number $0$ and in the case of |deglex| is an empty string. 
%   The entry of an annotation is a list with the structure 
%   \begin{quote}
%     \word{core} \word{output-list}\regopt\ \word{input-list}\regopt
%   \end{quote}
%   The \word{core} item is the core contribution from vertices with 
%   this annotation. The \word{output-list} and \word{input-list} 
%   are, if present, lists of additional contributions that depend on 
%   the tail and head indices of the edges that the path goes 
%   through. In the case of |deglex| dictionaries, the output 
%   contribution comes first, then the \word{core} contribution, and 
%   finally the input contribution; this corresponds to reading from 
%   the root up.
%   
%   |weight| contributions are simply added together and used as the 
%   element for this path in the corresponding comparison group. The 
%   strings formed for a |deglex| item contribute their length to one 
%   comparison group and themselves to the next group.
%   
%   \begin{tcl}
proc network::pure::compkey_paths-wdeg-lex {args} {
   set NW [lindex $args end]
   set args [lrange $args 0 end-1]
   set PathMat [list_paths_turning $NW]
%   \end{tcl}
%   The paths will within each cell of the path matrix be sorted 
%   after their comparison keys, so that the largest path is compared 
%   to the largest, the second largest path is compared to the second 
%   largest, etc. This would typically be a job for |lsort\
%   -dictionary|, but since that gets negative and fractional numbers 
%   wrong, the list is instead resorted by each element. |sortL| is 
%   the list of |lsort| command prefixes that the cell-level list of 
%   keys should be processed by, in the order they should be processed.
%   \begin{tcl}
   set pos 0
   set sortL {}
   foreach {type dict} $args {
      switch -- $type "weight" {
         set sortL [linsert $sortL 0 [list lsort -real -index $pos]]
         incr pos
      } "deglex" {
         set sortL [linsert $sortL 0\
           [list lsort -index [expr {$pos+1}]]\
           [list lsort -integer -index $pos]]
         incr pos 2
      } default {
         error "Unknown comparison type '$type': must be deglex or\
           weight"
      }
   }
%   \end{tcl}
%   Now the first comparison group is generated. 
%   \begin{tcl}
   [namespace parent]::setconstlist colsumL 0 [lindex $PathMat 0]
   set L {}
   foreach row $PathMat eo [lindex $NW 0 0 2] {
      set rowsum 0
      set colsum2L {}
      foreach cell $row ei [lindex $NW 0 1 1] colsum $colsumL {
         set val [llength $cell]
         lappend colsum2L [expr {$colsum+$val}]
         if {$eo eq ""} then {set val [lindex $colsum2L end]}
         incr rowsum $val
         if {$ei ne ""} then {
            lappend L $val
         } else {
            lappend L $rowsum
         }
      }
      set colsumL $colsum2L
   }
   set res [list $L]
%   \end{tcl}
%   Then the actual sort keys can be generated.
%   \begin{tcl}
   set all_keys {}
   foreach row $PathMat {
      foreach cell $row {
         set cell_keys {}
         foreach path $cell {
            set key {}
            foreach {type dict} $args {
               switch -- $type "weight" {
                  set sum 0
                  foreach {s a g} $path {
                     if {![dict exists $dict $a]} then {continue}
                     set L [dict get $dict $a]
                     if {[llength $L] > 1} then {
                        set sum [expr {$sum + 
                          ($s>=0 ? [lindex $L 1 $s] : 0) +
                          [lindex $L 0] + 
                          ($g>=0 ? [lindex $L 2 $g] : 0)
                        }]
                     } else {
                        set sum [expr {$sum + [lindex $L 0]}]
                     }
                  }
                  lappend key $sum
               } "deglex" {
                  set word ""
                  foreach {s a g} $path {
                     if {![dict exists $dict $a]} then {continue}
                     set L [dict get $dict $a]
                     append word [lindex $L 1 $s] [lindex $L 0]\
                       [lindex $L 2 $g]
                  }
                  lappend key [string length $word] $word
               }
            }
            lappend cell_keys $key
         }
         if {[llength $cell_keys] > 1} then {
            foreach cmd $sortL {
               set cell_keys [eval $cmd [list $cell_keys]]
            }
         }
         eval [list lappend all_keys] $cell_keys
      }
   }
%   \end{tcl}
%   Remaining comparison groups constitute the transposition of 
%   |all_keys|.
%   \begin{tcl}
   for {set n 0} {$n < $pos} {incr n} {
      set L {}
      foreach key $all_keys {lappend L [lindex $key $n]}
      lappend res $L
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{example}
%   The following was once thought to be a good ordering for Hopf 
%   algebra identities:
%\begin{verbatim}
% interp alias {} compare_networks {} network::pure::grouplex_compare {
%    network::pure::compkey_paths-wdeg-lex {
%       S {
%          {0 b} {{0 ""}} {{0 ""}}
%       } 
%       Delta {
%          {0 c} {{0 ""} {1 ""}} {{0 ""}}
%       } 
%       m {
%          {0 a} {{0 ""}} {{0 ""} {1 ""}}
%       }
%       epsilon {
%          {0 ""} {} {{0 ""}}
%       }
%       unit {
%          {0 ""} {{0 ""}} {}
%       }
%    }
% }
%\end{verbatim}
%   It worked fine, until the identity \(S \circ m = m \circ (1\:2) 
%   \circ (S \otimes S)\)\Ldash that $S$ is an antihomomorphism\Dash 
%   was derived. Since the left and right hand sides of this identity 
%   are unrelated by the above partial ordering, the completion 
%   failed.
%   
%   The ordering that was eventually found to work for Hopf 
%   identities turned out to be a bit simpler than the 
%   |compkey_paths-wdeg-lex| orderings, but proving it DCC was rather 
%   tricky.
% \end{example}
% 
% \begin{remark} \label{Anm:Multimangdsordning}
%   The usual method of extending a total order on a set $X$ to 
%   an order on multisets over $X$ is to compare maximal elements. 
%   For multisets $A$ and $B$, this works out as follows:
%   \begin{itemize}
%     \item 
%       If \(A = \varnothing\) and $B$ is not, then \(A < B\), and 
%       vice versa.
%     \item
%       Otherwise, if \(\max A < \max B\) then \(A < B\), and vice 
%       versa.
%     \item
%       Otherwise \(x = \max A = \max B\) and $A$ compares to $B$ as 
%       \(A \setminus \{x\}\) does to \(B \setminus \{x\}\), where 
%       $\setminus$ denotes multiset subtraction.
%   \end{itemize}
%   However, this is \emph{not} the ordering of multisets used in 
%   |compkey_paths-wdeg-lex|, and indeed the two are quite different. 
%   A technical reason for not using the max-element order in that 
%   procedure is that it cannot be handled within the comparison group 
%   mechanism, but needs a more complicated mechanism (with at least 
%   three list levels).
%   
%   A more mathematical reason is that it is slightly less robust 
%   with respect to composition of networks. If the order on the base 
%   set $X$\Ldash on which there must be some sort of composition 
%   operation\Dash is not strictly compatible with composition, but 
%   merely compatible with it, then the max-element multiset order 
%   need not be compatible at all. On the other hand, the ordering 
%   used in |compkey_paths-wdeg-lex| does not have that dependence 
%   since it is defined entirely in terms of non-strict inequalities.
% \end{remark}
% 
% 
% \begin{proc}{list_paths}
%   The |list_path| procedure returns a matrix of lists of paths 
%   between a given output and input in a network. The call syntax is
%   \begin{quote}
%     |network::pure::list_paths| \word{network}
%   \end{quote}
%   The first index of the return value matrix is an output index and 
%   the second index is an input index. The paths are lists of the form
%   \begin{quote}
%     \word{vertex-label} \begin{regblock}[\regstar]\word{edge-label} 
%     \word{vertex-label}\end{regblock}
%   \end{quote}
%   and they appear in no particular order. There is an extra final row 
%   in the result matrix for the paths that end at an inner vertex and 
%   an extra final column in the result matrix for the paths that begin 
%   in an inner vertex.
%   
%   The idea of the algorithm is to for each edge $e$ construct all 
%   paths $P_1 e P_2$ where $P_1$ is a previously existing path 
%   ending in the head of $e$ and $P_2$ is a previously existing path 
%   beginning in the tail of $e$.
%   \begin{tcl}
proc network::pure::list_paths {NW} {
   set sourceL {}
   set sinkL {}
   set n -1; foreach v [lindex $NW 0] {incr n
      set Paths($n,$n) [list [list $n]]
      if {![llength [lindex $v 1]] && $n>1} then {lappend sinkL $n}
      if {![llength [lindex $v 2]] && $n>1} then {lappend sourceL $n}
   }
   set n -1; foreach e [lindex $NW 1] {incr n
      foreach tf1 [array names Paths *,[lindex $e 0]] {
         foreach tf2 [array names Paths [lindex $e 2],*] {
            foreach P1 $Paths($tf1) {
               foreach P2 $Paths($tf2) {
                  lappend Paths([lindex $P1 0],[lindex $P2 end])\
                    [concat $P1 [list $n] $P2]
               }
            }
         }
      }
   }
   set m [llength [lindex $NW 0 0 2]]
   set n [llength [lindex $NW 0 1 1]]
   foreach P [lappend Paths(0,1)] {
      lappend M([lindex $NW 1 [lindex $P 1] 1],[lindex\
        $NW 1 [lindex $P end-1] 3]) $P
   }
   foreach v $sourceL {
      foreach P [lappend Paths(0,$v)] {
         lappend M([lindex $NW 1 [lindex $P 1] 1],$n) $P
      }
   }
   foreach u $sinkL {
      foreach P [lappend Paths($u,1)] {
         lappend M($m,[lindex $NW 1 [lindex $P end-1] 3]) $P
      }
   }
   foreach u $sinkL {
      foreach v $sourceL {
         eval [list lappend M($m,$n)] [lappend Paths($u,$v)]
      }
   }
   set res {}
   for {set i 0} {$i <= $m} {incr i} {
      set L {}
      for {set j 0} {$j <= $n} {incr j} {
         lappend L [lappend M($i,$j)]
      }
      lappend res $L
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{list_paths_turning}
%   This is a variant of |list_paths| that adds some extra 
%   post-processing. The return value is still a matrix of lists of 
%   paths as in |list_paths|, but the format of the paths has changed 
%   to put more focus on the internal vertices on the path and how 
%   the path passes through it. A \emph{path} in the result is a list
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{tail-index} \word{annotation} 
%     \word{head-index}\end{regblock}
%   \end{quote}
%   with one such triplet for each internal vertex the path passes 
%   through, with the first triplet being for the vertex closest to 
%   the output. Paths that have an endpoint in a vertex have the 
%   unused \word{tail-index} or \word{head-index} set to $-1$.
%   
%   The call syntax is
%   \begin{quote}
%     |list_paths_turning| \word{network}
%   \end{quote}
%   
%   \begin{tcl}
proc network::pure::list_paths_turning {NW} {
   set res {}
   foreach row [list_paths $NW] {
      set nrow {}
      foreach cell $row {
         set ncell {}
         foreach path $cell {
            set L {}
            if {[lindex $path 0] >= 2} then {lappend L -1}
            foreach {v e} $path {
               if {$v >= 2} then {lappend L [lindex $NW 0 $v 0]}
               if {$e ne ""} then {
                  foreach {u x} [lindex $NW 1 $e] {
                     if {$u >= 2} then {lappend L $x}
                  }
               }
            }
            if {[lindex $path end] >= 2} then {lappend L -1}
            lappend ncell $L
         }
         lappend nrow $ncell
      }
      lappend res $nrow
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \section{Presentations of networks}
% 
% When preparing a presentation of a network (regardless of whether 
% that presentation is as a diagram or a classical expression), it is 
% useful to have a decomposition of networks into distinct levels, and 
% then also an ordering of items within these levels (as random 
% orderings will typically lead to an excessive amount of crossings). 
% The following routines are about finding and using such orderings.
% 
% The basic format that is used for a piece of a network is a list of 
% pairs
% \begin{quote}
%   |vertex| \word{vertex-label}\\
%   |edge| \word{edge-label}
% \end{quote}
% A \emph{grading} of a network is a list of such pieces, where each 
% piece consists of what is at a vertex level of the network (a 
% grading is thus a decomposition into antichains). Edges between two 
% neighbouring levels are not listed. Edges between two levels at a 
% distance greater than $2$ appear is more than one piece.
% 
% 
% \subsection{Grading networks}
% 
% \begin{proc}{minimal_grading}
%   This procedure computes a grading of a network, in which every 
%   vertex is in the minimal level possible. The call syntax is
%   \begin{quote}
%     |network::pure::minimal_grading| \word{network}
%   \end{quote}
%   and returns the grading. The minimal grading has all vertices 
%   of coarity $0$ at level $0$, so it is not suitable for 
%   presentations, but it suffices for certain internal applications.
%   
%   The algorithm idea is to keep a list of vertices which may be in 
%   the next level and a table (encoded as a list of |0|s and |1|s 
%   indexed by edge label) of whether the edges are available.
%   \begin{tcl}
proc network::pure::minimal_grading {NW} {
   [namespace parent]::setconstlist availL 0 [lindex $NW 1]
   set tryL {}
   set n -1; foreach v [lindex $NW 0] {incr n
      if {[llength [lindex $v 1]] == 0} then {lappend tryL $n}
   }
   set res {}
   while {[llength $tryL]} {
      set level {}
      set next {}
      set nextavailL $availL
      foreach v $tryL {
         set ok 1
         foreach e [lindex $NW 0 $v 1] {
            if {![lindex $availL $e]} then {set ok 0; break}
         }
         if {$ok} then {
            lappend level [list vertex $v]
            foreach e [lindex $NW 0 $v 2] {
               lset nextavailL $e 1
               lappend next [lindex $NW 1 $e 2]
            }
         } else {
            lappend next $v
            foreach e [lindex $NW 0 $v 1] {
               if {[lindex $availL $e]} then {
                  lappend level [list edge $e]
               }
            }
         }
      }
      lappend res $level
      if {[llength $res] > [llength [lindex $NW 0]]} then {
         error "Loop in network: $NW"
      }
      lset tryL [lsort -unique -integer $next]
      set availL $nextavailL
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{vertex_levels}
%   The |vertex_levels| procedure computes a list assigning an integer 
%   level to each vertex, in such a way that the output end of an edge 
%   is always strictly less than the input end. The call syntax is
%   \begin{quote}
%     |network::pure::vertex_levels| \word{network}
%   \end{quote}
%   and the return value is the list, indexed by vertex labels, of the 
%   assigned vertex levels.
%   
%   The lowest level is $0$, whose lone occupant is the output vertex 
%   |0|. Levels are always integers. The output vertex |0| always has 
%   a level less than any other vertex, and the input vertex |1| always 
%   has a level greater than any other vertex.
%   
%   \begin{tcl}
proc network::pure::vertex_levels {NW} {
%   \end{tcl}
%   The first step is to compute the partial ordering of the vertices 
%   that is determined by the network. This is implemented as the 
%   array |P|, where indices are pairs \meta{lower}|,|\meta{upper} 
%   that are present if \(\mathit{lower} \leqslant \mathit{uppper} 
%   \pin{P}\). The entries are minimal allowed distances between the 
%   two enpoints in the pair, i.e., the maximum over all directed 
%   paths between them of the lengths of these paths. Extra 
%   inequalities are inserted to make |0| the lone occupant of the 
%   minimal level and |1| the lone occupant of the maximal level.
%   \begin{tcl}
   array set P {0,0 0 0,1 1 1,1 0}
   for {set n 2} {$n < [llength [lindex $NW 0]]} {incr n} {
      set P($n,$n) 0
      set P(0,$n) 1
      set P($n,1) 1
      set P(0,1) 2
   }
   foreach e [lindex $NW 1] {
      foreach {v0 . v1} $e break
      set L {}
      foreach l [array names P "*,$v0"] {
         lappend L [lindex [split $l ","] 0]
      }
      set U {}
      foreach u [array names P "$v1,*"] {
         lappend U [lindex [split $u ","] 1]
      }
      foreach l $L {
         foreach u $U {
            set diff [expr {$P($l,$v0) + 1 + $P($v1,$u)}]
            if {![info exists P($l,$u)] || $P($l,$u)<$diff} then {
               set P($l,$u) $diff
            }
         }
      }
   }
%   \end{tcl}
%   
%   The second step constructs a list |intL| indexed by vertex 
%   labels, whose elements are the intervals (given as pairs of lower 
%   bound and upper bound) of levels that are allowed for this 
%   vertex. When the lower and upper bounds are equal, then the level 
%   of that vertex has been fixed. The process of shrinking the 
%   intervals starts by increasing a lower bound $1$ to $2$ for all 
%   vertices whose level has not yet been fixed. Then it goes on to 
%   decreasing the upper bounds which are one less than the level of 
%   the input vertex |1|, then goes back from increasing lower bounds 
%   from $2$ to $3$, and so on\Dash alternating between lower and 
%   upper bounds. The result is that vertices whose levels are not 
%   subject to tight inequalities get centered.
%   \begin{tcl}
   set intL {}
   set n -1; foreach v [lindex $NW 0] {incr n
      lappend intL [list $P(0,$n) [expr {$P(0,1) - $P($n,1)}]]
   }
   set lower 0
   set upper $P(0,1)
   while {$lower <= $upper} {
      set n -1; foreach p $intL {incr n
         foreach {i j} $p break
         if {$i==$j || $i>$lower} then {continue}
         set level [expr {$lower+1}]
         foreach p [array names P "$n,*"] {
            set u [lindex [split $p ","] 1]
            set ulevel [expr {$level + $P($p)}]
            if {[lindex $intL $u 0] < $ulevel} then {
               lset intL $u 0 $ulevel
            }
         }
      }
      incr upper -1
      if {$upper < $lower} then {break}
      set n -1; foreach p $intL {incr n
         foreach {i j} $p break
         if {$i==$j || $j<$upper} then {continue}
         set level [expr {$upper-1}]
         foreach p [array names P "*,$n"] {
            set u [lindex [split $p ","] 0]
            set ulevel [expr {$level - $P($p)}]
            if {[lindex $intL $u 1] > $ulevel} then {
               lset intL $u 1 $ulevel
            }
         }
      }
      incr lower
   }
%   \end{tcl}
%   The final result can be constructed from the lower bounds.
%   \begin{tcl}
   set res {}
   foreach p $intL {lappend res [lindex $p 0]}
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{vertex_levels2}
%   The |vertex_levels2| procedure, like the |vertex_levels| 
%   procedure, computes a list assigning an integer level to each 
%   vertex, in such a way that the output end of an edge is always 
%   strictly less than the input end. The call syntax is
%   \begin{quote}
%     |network::pure::vertex_levels2| \word{network}
%   \end{quote}
%   and the return value is the list, indexed by vertex labels, of the 
%   assigned vertex levels.
%   
%   The lowest level is $0$, whose lone occupant is the output vertex 
%   |0|. Levels are always integers. The output vertex |0| always has 
%   a level less than any other vertex, and the input vertex |1| 
%   always has a level greater than any other vertex. The difference 
%   to |vertex_levels| is that this procedure tries to place network 
%   parts with connections to only inputs or only outputs at extreme 
%   levels rather than centered.
%   
%   Most of the work is still carried out by |vertex_levels|; this 
%   procedure really only makes a minor adjustment to the result of 
%   that procedure.
%   \begin{tcl}
proc network::pure::vertex_levels2 {NW} {
   set res [vertex_levels $NW]
%   \end{tcl}
%   
%   The first step of this adjustment is to (again) compute the 
%   partial ordering of the vertices that is determined by the 
%   network, but this time only base its inequalities on the edges. 
%   It is essential for what follows that it is possible to test for 
%   a directed path between |0| or |1| and a vertex $v$ by 
%   |info exists P(0,$v)| or |info exists P($v,1)|.
%   
%   During this first step, there are also computed lists |sourceL| 
%   and |sinkL| of vertices without inputs or outputs respectively. 
%   The elements of these lists are candidates for being moved.
%   \begin{tcl}
   set sourceL {}
   set sinkL {}
   set n -1; foreach v [lindex $NW 0] {incr n
      set P($n,$n) 0
      if {![llength [lindex $v 1]]} then {lappend sinkL $n}
      if {![llength [lindex $v 2]]} then {lappend sourceL $n}
   }
   foreach e [lindex $NW 1] {
      foreach {v0 . v1} $e break
      set L {}
      foreach l [array names P "*,$v0"] {
         lappend L [lindex [split $l ","] 0]
      }
      set U {}
      foreach u [array names P "$v1,*"] {
         lappend U [lindex [split $u ","] 1]
      }
      foreach l $L {
         foreach u $U {
            set diff [expr {$P($l,$v0) + 1 + $P($v1,$u)}]
            if {![info exists P($l,$u)] || $P($l,$u)<$diff} then {
               set P($l,$u) $diff
            }
         }
      }
   }
%   \end{tcl}
%   
%   The level for a vertex $v$ placed at its low extreme is simply 
%   |$P(0,$v)|, and similarly the high extreme is |$P($v,1)| less 
%   than the level of |1|; these always exist for the vertices that 
%   are moved by this procedure. The basic criterium 
%   \begin{tcl}
   foreach v $sourceL {
      if {$v<2 || ![info exists P(0,$v)]} then {continue}
      set L {}
      foreach p [array names P "*,$v"] {
         set u [lindex [split $p ","] 0]
         if {$u<2} then {continue}
         if {[info exists P(0,$u)] && ![info exists P($u,1)]} then {
            lappend L $u
         } else {
            set L {}; break
         }
      }
      foreach u $L {lset res $u $P(0,$u)}
   }
   foreach v $sinkL {
      if {$v<2 || ![info exists P($v,1)]} then {continue}
      set L {}
      foreach p [array names P "$v,*"] {
         set u [lindex [split $p ","] 1]
         if {$u<2} then {continue}
         if {![info exists P(0,$u)] && [info exists P($u,1)]} then {
            lappend L $u
         } else {
            set L {}; break
         }
      }
      foreach u $L {lset res $u [expr {[lindex $res 1] - $P($u,1)}]}
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{fix_level_tongues}
%   This is a helper procedure for Yet Another Variant on the 
%   |vertex_levels| procedure, namely |vertex_levels3|. The call 
%   syntax is
%   \begin{quote}
%     |fix_level_tongues| \word{interval-list-var} \word{network}
%   \end{quote}
%   where \word{interval-list-var} is the name in the calling 
%   context of the variable where the current list (indexed by 
%   vertex label) of intervals is stored. Vertices where the upper 
%   and lower bounds in these intervals are equal are said to be 
%   \emph{frozen}; their final levels have already been determined. 
%   The procedure may change this list by freezing additional 
%   vertices where appropriate. It returns the number of vertices 
%   that still remain unfrozen afterwards.
%   
%   The situation where this procedure does anything is that there is 
%   a component in the subgraph of unfrozen vertices which connects 
%   much tighter to one freezing frontier than to the other. The 
%   typical case that motivated introducing this procedure is that of 
%   a unit or counit vertex attached directly to the output or input 
%   vertex respectively, but there are currently three degrees of 
%   connectivity: no connection (|0|), connected to external vertex 
%   (|1|), or connected to an internal frozen vertex (|2|). When a 
%   component is found to have a higher degree of connectivity to one 
%   side, the whole component is freezed in a single step, by changing 
%   all upper bounds to the equal the lower bound or vice versa.
%   \begin{tcl}
proc network::pure::fix_level_tongues {intLvar NW} {
   upvar 1 $intLvar intL
   set n -1; foreach p $intL {incr n
      if {[lindex $p 0]==[lindex $p 1] || [info exists S($n)]}\
      then {continue}
      set S($n) ""
      set up 0
      set down 0
      set queue [list $n]
      for {set qp 0} {$qp < [llength $queue]} {incr qp} {
         foreach {dir vidx eidx} {down 1 0  up 2 2} {
            foreach e [lindex $NW 0 [lindex $queue $qp] $vidx] {
               set u [lindex $NW 1 $e $eidx]
               if {[lindex $intL $u 0] == [lindex $intL $u 1]} then {
                  if {$u>=2} then {
                     set $dir 2
                  } elseif {![set $dir]} then {
                     set $dir 1
                  }
               } elseif {![info exists S($u)]} then {
                  set S($u) ""
                  lappend queue $u
               }
            }
         }
      }
      if {$up > $down} then {
         foreach v $queue {
            lset intL $v 0 [lindex $intL $v 1]
            unset S($v)
         }
      } elseif {$down > $up} then {
         foreach v $queue {
            lset intL $v 1 [lindex $intL $v 0]
            unset S($v)
         }
      }
   }
   array size S
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{vertex_levels3}
%   The |vertex_levels3| procedure computes a list assigning an integer 
%   level to each vertex, in such a way that the output end of an edge 
%   is always strictly less than the input end. The call syntax is
%   \begin{quote}
%     |network::pure::vertex_levels3| \word{network}
%   \end{quote}
%   and the return value is the list, indexed by vertex labels, of the 
%   assigned vertex levels.
%   
%   The lowest level is $0$, whose lone occupant is the output vertex 
%   |0|. Levels are always integers. The output vertex |0| always has 
%   a level less than any other vertex, and the input vertex |1| always 
%   has a level greater than any other vertex.
%   
%   \begin{tcl}
proc network::pure::vertex_levels3 {NW} {
%   \end{tcl}
%   The first step is to compute the partial ordering of the vertices 
%   that is determined by the network. This is implemented as the 
%   array |P|, where indices are pairs \meta{lower}|,|\meta{upper} 
%   that are present if \(\mathit{lower} \leqslant \mathit{uppper} 
%   \pin{P}\). The entries are minimal allowed distances between the 
%   two enpoints in the pair, i.e., the maximum over all directed 
%   paths between them of the lengths of these paths. Extra 
%   inequalities are inserted to make |0| the lone occupant of the 
%   minimal level and |1| the lone occupant of the maximal level.
%   \begin{tcl}
   array set P {0,0 0 0,1 1 1,1 0}
   for {set n 2} {$n < [llength [lindex $NW 0]]} {incr n} {
      set P($n,$n) 0
      set P(0,$n) 1
      set P($n,1) 1
      set P(0,1) 2
   }
   foreach e [lindex $NW 1] {
      foreach {v0 . v1} $e break
      set L {}
      foreach l [array names P "*,$v0"] {
         lappend L [lindex [split $l ","] 0]
      }
      set U {}
      foreach u [array names P "$v1,*"] {
         lappend U [lindex [split $u ","] 1]
      }
      foreach l $L {
         foreach u $U {
            set diff [expr {$P($l,$v0) + 1 + $P($v1,$u)}]
            if {![info exists P($l,$u)] || $P($l,$u)<$diff} then {
               set P($l,$u) $diff
            }
         }
      }
   }
%   \end{tcl}
%   
%   The second step constructs a list |intL| indexed by vertex 
%   labels, whose elements are the intervals (given as pairs of lower 
%   bound and upper bound) of levels that are allowed for this 
%   vertex. When the lower and upper bounds are equal, then the level 
%   of that vertex has been fixed. The process of shrinking the 
%   intervals starts by increasing a lower bound $1$ to $2$ for all 
%   vertices whose level has not yet been fixed. Then it goes on to 
%   decreasing the upper bounds which are one less than the level of 
%   the input vertex |1|, then goes back from increasing lower bounds 
%   from $2$ to $3$, and so on\Dash alternating between lower and 
%   upper bounds. The result is that vertices whose levels are not 
%   subject to tight inequalities get centered.
%   \begin{tcl}
   set intL {}
   set n -1; foreach v [lindex $NW 0] {incr n
      lappend intL [list $P(0,$n) [expr {$P(0,1) - $P($n,1)}]]
   }
   fix_level_tongues intL $NW
   set lower 0
   set upper $P(0,1)
   while {$lower <= $upper} {
      set n -1; foreach p $intL {incr n
         foreach {i j} $p break
         if {$i==$j || $i>$lower} then {continue}
         set level [expr {$lower+1}]
         foreach p [array names P "$n,*"] {
            set u [lindex [split $p ","] 1]
            set ulevel [expr {$level + $P($p)}]
            if {[lindex $intL $u 0] < $ulevel} then {
               lset intL $u 0 $ulevel
            }
         }
      }
      if {![fix_level_tongues intL $NW]} then {break}
      incr upper -1
      if {$upper < $lower} then {break}
      set n -1; foreach p $intL {incr n
         foreach {i j} $p break
         if {$i==$j || $j<$upper} then {continue}
         set level [expr {$upper-1}]
         foreach p [array names P "*,$n"] {
            set u [lindex [split $p ","] 0]
            set ulevel [expr {$level - $P($p)}]
            if {[lindex $intL $u 1] > $ulevel} then {
               lset intL $u 1 $ulevel
            }
         }
      }
      if {![fix_level_tongues intL $NW]} then {break}
      incr lower
   }
%   \end{tcl}
%   The final result can be constructed from the lower bounds.
%   \begin{tcl}
   set res {}
   foreach p $intL {lappend res [lindex $p 0]}
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \changes{2.2}{2008/12/06}{Linear-programming based method for 
%   assigning vertex levels. (LH)}
% 
% The approach above is adequate, but will occationally put some vertex 
% in a level that leads to more edges in the image than what looks 
% necessary, so perhaps it is time to do it properly by choosing an 
% optimal arragement. What should be minimised is the combined 
% (vertical) lengths of the edges in the network, while respecting 
% the basic restriction that the length of an edge has to be at 
% least $1$. If the variables in the optimisation problem are taken 
% to be the levels assigned to the vertices, then both the objective 
% function and the constraints are linear, so what needs to be solved 
% is really a linear program.
% 
% Recalling the basics of linear programming, we are seeking a vector 
% $\mathbf{x}$ which minimises $\mathbf{c}^{\mathrm{T}} \mathbf{x}$ 
% subject to \(A \mathbf{x} \geqslant \mathbf{b}\) for some matrix 
% $A$ and (column) vectors $\mathbf{b}$ and $\mathbf{c}$. The 
% inequality corresponding to an edge \(e = \overrightarrow{uv}\) is 
% that \(x_u - x_v \geqslant 1\), and \(c_u = d^+(u)-d^-(u)\) since 
% $d^+(u)$ is the number of vertices going down from $u$ and $d^-(u)$ 
% is the number of vertices going up from $u$. In principle, this is 
% all one needs to know in order to find an optimal arrangement.
% 
% In practice, one might want to add a few restrictions to get 
% results comparable to those of the other procedures above. First, 
% it was given that \(x_0 = 0\). Second, all inner vertices must be 
% at levels between those for the external vertices, so \(0 = x_0 < 
% x_u < x_1\) for all \(u \geqslant 2\); this amounts to adding extra 
% edges that have weight $0$ in $\mathbf{c}$. Third, $x_1$ is 
% minimised first and the edge length is only a secondary minimisation 
% objective; this rarely makes a difference for the result, but it 
% helps to avoid large linear programs, since vertices on a longest 
% chain get their level assigned without a need for invoking a linear 
% program solver (although linear programs can be solved in 
% polynomial time, the exponent is not particularly small).
% 
% Now then, what algorithm should be used to solve the linear 
% program? Interior point method? Ellipsoid method? No, just plain 
% old \textsc{simplex}. The main reason for this is that it gets by 
% with simpler arithmetic\Dash after imposing the above restrictions, 
% an inequality in the system has one of the three forms
% \begin{align*}
%   x_1 - x_2 \geqslant{}& 1\text{,} &
%   x_1 \geqslant{}& b\text{,} &
%   -x_1 \geqslant{}& b\text{,}
% \end{align*}
% where the lack of coefficients other than $1$, $0$, and $-1$ means 
% every corner of the polyhedron will have integer coefficients; 
% neither provably polynomial method makes do with integer 
% arithmetic. It also turns out that no matrix elimination or 
% factorisation is required to run simplex here; the relevant systems 
% are already on a form that can be solved through substitution.
% 
% Recall that the main internal state of the simplex method is the 
% \emph{working set} of inequalities; in a system with $n$ variables, 
% one selects a subset \(A' \mathbf{x} \geqslant \mathbf{b}'\) of the 
% inequality system \(A \mathbf{x} \geqslant \mathbf{b}\) such that 
% $A'$ is invertible and defines the current approximation as the 
% solution $\mathbf{x}$ to \(A' \mathbf{x} = \mathbf{b}'\). Consider 
% now the graph $G$ obtained from the network as follows: first add 
% edges to $0$ and $1$ from every internal vertex $u$ to express the 
% second restriction that \(0 = x_0 < x_u < x_1\), then contract all 
% non-variable vertices (those whose values were fixed by the third 
% restriction that $x_1$ is minimal) into one common reference 
% vertex. Each inequality corresponds uniquely to an edge in $G$, 
% and a set of inequalities corresponds to a linearly independent set 
% of rows in $A$ if and only if they do not form a cycle in $G$. 
% Hence a working set is the same thing as a spanning tree in $G$, 
% and every path starting in the reference vertex contains precisely 
% those edges that prescribe the current value for the variable at 
% the other endpoint.
% 
% The data structure used for keeping track of the working set is a 
% doubly-linked tree, with one node for each vertex, sitting in a 
% list indexed by vertex label. The point of using this kind of 
% structure is that it simplifies reversing the parent-child 
% relationship by having all the information available locally; some 
% such reversals typically happen at every step of the simplex 
% algorithm. Each \emph{edge} and \emph{vertex} below is a vertex or 
% edge label. The two forms for elements in the top level list are
% \begin{displaysyntax}
%   \word{parent-edge} \word{orientation} \word{children}\par
%   at \word{height} \word{children}
% \end{displaysyntax}
% where the first form is for variable vertices and the second is for 
% fixed vertices; the \word{height} is then the assigned height for 
% that vertex. The \word{children} is a list\slash dictionary with the 
% structure
% \begin{quote}
%   \begin{regblock}[\regstar] \word{child-edge} 
%   \word{child-vertex} \end{regblock}
% \end{quote}
% enumerating the tree children of this vertex. Fixed vertices other 
% than |0| are not in the tree, and their lists of children are 
% therefore empty.
% 
% The \word{orientation} is the sign of the \word{parent-edge} 
% relative to the tree; it is |1| if the edge points towards the root 
% and |-1| if it points away from it; this is also the coefficient in 
% $A$ of this edge at the node's vertex. The vertex on the parent side 
% of a \word{parent-edge} is 
% \begin{displaysyntax}
%   [lindex \word{network} 1 \word{parent-edge}
%   [expr |{|1-\word{orientation}|}|]]
% \end{displaysyntax}
% which may be fixed, and if so counts as the root when traversing the 
% tree.
% 
% One thing that one generally has to watch out for with 
% \textsc{simplex} is degenerate corners (i.e., points which 
% correspond to several working sets) since steps taken at such 
% points may be of length $0$ (switching from one tree to another, 
% but not actually moving any vertex). This is serious because the 
% basic argument for the termination of \textsc{simplex} is that the 
% objective function decreases at each step; where length $0$ steps 
% occur this argument is no longer valid, and there are indeed 
% examples in the literature where \textsc{simplex} gets stuck in 
% a loop. Degenerate corners are unfortunately rather common in this 
% setting, where all inequalities look pretty much the same.
% 
% One way to avoid this problem is to perturb the inequalities 
% slightly so that no degeneracies occur. In an algebraic setting 
% such as this, the most elegant solution is probably to subtract an 
% infinitesimal amount from the length of every edge, so that the 
% shadow of a perturbed solution is still the optimal solution to the 
% unperturbed solution. Thus, the minimal length of edge $e$ will 
% not be $1$, but $1-\varepsilon^{1+e}$, where $\varepsilon$ is some 
% positive infinitesimal; this moves all sides of the polytope 
% slightly further out, so all admissible points remain admissible. 
% Furthermore no corner of the enlarged polytope can be degenerate, 
% since its coordinates encode the corresponding working set in the 
% orders of infinitesimals that occur. In other words, there will at 
% each step always be a unique inequality which goes sharp, and no 
% step can have length $0$. This puts the matter of finding that edge 
% next on the agenda.
% 
% \begin{proc}{vertex_levels4,ypos}
%   This procedure computes the $y$-position of a vertex with respect 
%   to the current working set. Its call syntax is
%   \begin{displaysyntax}
%     |vertex_levels4,ypos| \word{network} \word{heap} \word{vertex}
%   \end{displaysyntax}
%   where \word{network} is the underlying network, \word{heap} is 
%   the list indexed by vertex label that defines the current tree, 
%   and \word{vertex} is the vertex whose position is to be computed. 
%   The return value is a list\slash dictionary
%   \begin{displaysyntax}
%     finite \word{integer} \begin{regblock}[\regstar] \word{edge} 
%     \word{coefficient} \end{regblock}
%   \end{displaysyntax}
%   that gives not only the finite component \word{integer} of the 
%   $y$-position, but also the infinitesimal \word{coefficients}.
%   
%   \begin{tcl}
proc network::pure::vertex_levels4,ypos {NW heap v} {
   set res {finite 0}
   set finite 0
   while {[lindex $heap $v 0] ne "at"} {
      set orient [lindex $heap $v 1]
      incr finite $orient
      set e [lindex $heap $v 0]
      lappend res $e [expr {-$orient}]
      set v [lindex $NW 1 $e [expr {1-$orient}]]
   }
   incr finite [lindex $heap $v 1]
   lset res 1 $finite
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% The working set is not the only parts of the simplex algorithm that 
% gets a graph-theoretical interpretations in $G$. The descent 
% direction $\mathbf{p}$ to use if dropping the $s$'th inequality is 
% for example in general the solution to \(A' \mathbf{p} = 
% \mathbf{e}_s\), where the right hand side is the unit vector with a 
% $1$ in the $s$'th position\Dash here this $\mathbf{p}$ turns out to 
% be a vector with elements in $\{0,1\}$ or $\{0,-1\}$, and the 
% elements that are nonzero are precisely those whose path to the 
% reference vertex contains the edge corresponding to the $s$'th 
% inequality. What happens graph-theoretically is merely that the 
% tree is cut at this edge, and the branch thus separated from the 
% rest is moving in the direction of lengthening this edge. After 
% moving so far that some other edge has shrunk to its minimum length 
% $1 - \varepsilon^{1+e}$, the branch is then reattached to the base 
% tree at that position instead; a rather elementary observation.
% 
% What the general theory contributes that is not elementary is the 
% optimality (and thus termination) condition, namely that the vector 
% $\mathbf{m}$ of Lagrangian multipliers satisfying 
% \(\mathbf{m}^{\mathrm{T}} A' = \mathbf{c}^{\mathrm{T}}\) is 
% nonnegative. Since the rows of $A'$ correspond to inequalities and 
% the columns to variables, the elements of $\mathbf{c}$ are indexed 
% by vertices and the elements of $\mathbf{m}$ are indexed by edges 
% in the current spanning tree. It doesn't seem these multipliers 
% have an (easy) interpretation in general, but here they do: a 
% multiplier is the difference between the numbers of network edges 
% leaving and coming into the tree branch that would be cut off from 
% the root by the deletion of the corresponding edge, with sign 
% depending on whether the edge is oriented towards or away from the 
% root. For an edge pointing towards the root, the multiplier is the 
% number of outgoing edges minus the number of incoming edges (like a 
% $\mathbf{c}$ element), and for edges pointing away from the root it 
% is the other way around.
% 
% \begin{proc}{vertex_levels4,multipliers}
%   The command used to compute the current multipliers has the call 
%   syntax
%   \begin{displaysyntax}
%     |vertex_levels4,multipliers| \word{network} \word{tree-heap} 
%     \word{node-index}
%   \end{displaysyntax}
%   where \word{network} is the network being considered, 
%   \word{tree-heap} is the list in which the working set spanning 
%   tree is stored, and \word{node-index} is an index into this list. 
%   The call computes the multpliers of all tree edges incident to 
%   vertices in the branch of which \word{node-index} is the root. 
%   The return value is a bit more than just a list of multipliers, 
%   however. Concretely it is a list
%   \begin{displaysyntax}
%     \word{multiplier-list} \word{up-edges} \word{down-edges}
%   \end{displaysyntax}
%   where \word{multiplier-list} is the list of the \emph{negative} 
%   multipliers, where in turn each multiplier is stored as a list
%   \begin{displaysyntax}
%     \word{multiplier} \word{edge} \word{shrink-edges} 
%     \word{orientation}
%   \end{displaysyntax}
%   where \word{multiplier} is the actual element of $\mathbf{m}$, 
%   \word{edge} is the label of the corresponding edge, 
%   \word{shink-edges} is the list of edges which shrink when 
%   \word{edge} is lengthened, and \word{orientation} is the sign of 
%   the \word{edge} relative to the tree; it is |1| if the edge points 
%   towards the root and |-1| if it points away from it; this is also 
%   the coefficient in $A$ of this edge at this vertex. The 
%   \word{up-edges} and \word{down-edges} are lists of all edges 
%   whose heads and tails respectively are in the branch. Edges within 
%   the branch are in both lists.
%   
%   The implementation is pretty straightforward: first recurse over 
%   the children to collect data, then amend with data for the 
%   current node.
%   \begin{tcl}
proc network::pure::vertex_levels4,multipliers {NW heap node} {
   set multiplierL {}
   set upedgeL [lindex $NW 0 $node 2]
   set downedgeL [lindex $NW 0 $node 1]
   foreach {e v} [lindex $heap $node 2] {
      foreach {mL uL dL} [vertex_levels4,multipliers $NW $heap $v]\
        break
      eval [list lappend multiplierL] $mL
      eval [list lappend upedgeL] $uL
      eval [list lappend downedgeL] $dL
   }
%   \end{tcl}
%   In the equation system \(\mathbf{m}^{\mathrm{T}} A' = 
%   \mathbf{c}^{\mathrm{T}}\), every row has at most two nonzero 
%   elements, one which is $1$ and one which is $-1$. Hence the 
%   sequence of elementary column operations (since this equation 
%   system is transposed relative to the standard form) which frees 
%   the \word{multiplier} unknown is simply to add all columns for 
%   vertices in the branch together, and the same holds for the right 
%   hand side. Hence the numerical value of the multiplier is 
%   determined by the lengths of |upedgeL| and |downedgeL| together 
%   with the orientation.
%   \begin{tcl}
   foreach {edge orientation} [lindex $heap $node] break
   set mult [expr {
     ([llength $downedgeL] - [llength $upedgeL]) / $orientation
   }]
   if {$mult<0} then {
      foreach e [
         if {$orientation>0} then {set upedgeL} else {set downedgeL}
      ] {set S($e) {}}
      foreach e [
         if {$orientation<0} then {set upedgeL} else {set downedgeL}
      ] {unset -nocomplain S($e)}
      lappend multiplierL\
        [list $mult $edge [array names S] $orientation]
   }
   list $multiplierL $upedgeL $downedgeL
}
%   \end{tcl}
% \end{proc}
% 
% A valid objection at this point would be that 
% |vertex_levels4,multipliers| makes no distinction between network 
% edges (which contribute to $\mathbf{c}$) and other inequalities 
% (which do not)! How does that work out? Well, if one to every 
% vertex \(v \neq 0,1\) adds one input edge to $1$ and one output 
% edge to $0$ (which precisely cover all extra inequalities as $v$) 
% then the difference between input and output valency stays the 
% same, so one can use a \word{network} augmented with edges for the 
% extra inequalities also as a basis for computing $\mathbf{c}$. If 
% this is not acceptable, then one should probably rewrite that 
% procedure to explicitly require $\mathbf{c}$ as a separate vector.
% 
% \begin{proc}{vertex_levels4,shrink}
%   This procedure computes how much an the length of edge can shrink 
%   from its current value before it reaches the its minimum, and 
%   encodes that in a form that is suitable for use as a sort key. 
%   The call syntax is
%   \begin{displaysyntax}
%     |vertex_levels4,shrink| \word{network} \word{heap} \word{edge}
%   \end{displaysyntax}
%   and the return value is the sort key, which should be compared in 
%   |-dictionary| mode.
%   
%   The basic algorithm is trivial: the shrink is the $y$-position of 
%   the tail of the \word{edge}, minus the $y$-position of the head 
%   of the \word{edge}, minus the minimal length $1-\varepsilon^{1+e}$.
%   \begin{tcl}
proc network::pure::vertex_levels4,shrink {NW heap edge} {
   array set S {finite -1}
   set S($edge) 1
   foreach {v ""} [lindex $NW 1 $edge] sign {-1 1} {
      foreach {e c} [vertex_levels4,ypos $NW $heap $v] {
         set c [expr {$sign*$c}]
         if {[info exists S($e)]}\
         then {incr S($e) $c} else {set S($e) $c}
      }
   }
%   \end{tcl}
%   The encoding as a sort key is not so trivial. In part this is 
%   because it is optimised for sparse polynomials in the 
%   infinitesimal, and omits edges with $0$ coefficients, which 
%   conversely means edge numbers have to appear explicitly in the 
%   encoding. There is also an optimisation based on the observation 
%   that the only coefficients an infinitesimal can have are $1$, 
%   $0$, and $-1$; this is because no edge occurs more than once in 
%   the cycle formed by the tree and the \word{edge}.
%   
%   The idea is that one has to find a sequence of representations 
%   for infinitesimal terms such that $-\varepsilon < 
%   -\varepsilon^2 < \dotsb < -\varepsilon^m < 0 < \varepsilon^m < 
%   \dotsb < \varepsilon^2 < \varepsilon$ in |-dictionary| order. 
%   This is solved by using |a|--|j| as ``negative'' digits and 
%   |q|--|z| as ``positive'' digits; one starts with the digits of 
%   $m$ (padded with zeroes on the left to ensure uniform width) and 
%   maps |0| through |9| to |a| through |j| or |z| through |q| (note 
%   reversal) depending on whether the coefficient is $+1$ or $-1$. 
%   The zero in between may be represented as |o|.
%   
%   Once such a representation is given for individual terms, one may 
%   represent sums of terms simply by concatenating the 
%   representations of the terms, sorted by absolute value. The 
%   |-dictionary| comparison of two concatenations is then determined 
%   by the first position where they differ, i.e., by comparing the 
%   first two terms that are not identical, and the sums then compare 
%   as these terms do. For this to work when one sum is a prefix of 
%   another, it is however necessary to explictly put a ``zero'' term 
%   last.
%   \begin{tcl}
   set fs %0[string length [format %d\
     [expr {[llength [lindex $NW 1]]-1}]]]d
   set res $S(finite)
   unset S(finite)
   foreach e [lsort -integer [array names S]] {
      if {$S($e)>0} then {
         append res [string map {
            0 z 1 y 2 x 3 w 4 v 5 u 6 t 7 s 8 r 9 q
         } [format $fs $e]]
      } elseif {$S($e)<0} then {
         append res [string map {
            0 a 1 b 2 c 3 d 4 e 5 f 6 g 7 h 8 i 9 j
         } [format $fs $e]]
      }
   }
   append res o
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{vertex_levels4,simplex}
%   This procedure runs the \textsc{simplex} algorithm until 
%   termination, and returns the final working tree. The call syntax 
%   is
%   \begin{displaysyntax}
%     |vertex_levels4,simplex| \word{network} \word{heap}
%   \end{displaysyntax}
%   
%   \begin{tcl}
proc network::pure::vertex_levels4,simplex {NW heap} {
   while {[
%   \end{tcl}
%   The first part is to compute all negative multipliers, and among 
%   these choose an edge to cut.
%   \begin{tcl}
      set multL {}
      foreach {e v} [lindex $heap 0 2] {
         eval [list lappend multL]\
           [lindex [vertex_levels4,multipliers $NW $heap $v] 0]
      }
      llength $multL
   ]} {
      foreach {mult cutedge edgeL orient}\
        [lindex [lsort -integer -index 0 $multL] 0] break
%   \end{tcl}
%   The second part is to determine which shrink-edge will reach its 
%   minimum length first.
%   \begin{tcl}
      set L {}
      foreach e $edgeL {
         lappend L [list $e [vertex_levels4,shrink $NW $heap $e]]
      }
      set shrinkedge [lindex [lsort -dictionary -index 1 $L] 0 0]
%   \end{tcl}
%   It is known that there is at least one shrink-edge, since the 
%   multiplier is negative.
%   
%   The third part is to remove the cut-edge from and add the 
%   shrink-edge to the working tree. This is by far the longest, 
%   since the relevant operations are not provided by any helper 
%   prodicedure. So, first remove the cut-edge from the 
%   \word{children} of its parent. A complication here is that the 
%   parent need not be the vertex at the parent end of the edge, but 
%   may be the root instead.
%   \begin{tcl}
      set p [lindex $NW 1 $cutedge [expr {1-$orient}]]
      if {[lindex $heap $p 0] eq "at"} then {set p 0}
      set L {}
      foreach {e v} [lindex $heap $p 2] {
         if {$e != $cutedge} then {lappend L $e $v}
      }
      lset heap $p 2 $L
%   \end{tcl}
%   Next, add the shrink-edge to the tree. The orientation of this 
%   edge will be opposite to that of the cut-edge, since it 
%   vertically attaches to the other side of the brach; if the tail 
%   of the cut-edge was in the branch then it must be the head of the 
%   shrink-edge and vice versa, since one shrinks when the other 
%   grows.
%   \begin{tcl}
      set orient [expr {-$orient}]
      set p [lindex $NW 1 $shrinkedge [expr {1-$orient}]]
      if {[lindex $heap $p 0] eq "at"} then {set p 0}
      set q [lindex $NW 1 $shrinkedge [expr {1+$orient}]]
      lset heap $p 2\
        [linsert [lindex $heap $p 2] end $shrinkedge $q]
%   \end{tcl}
%   Finally flip all edges along the path from the new branch root to 
%   the old one. As above, $p$ is the tree node whose entry is being 
%   modified and $q$ is the next node to modify---incidentally also 
%   the old parent of $p$, but afterwards it will be the other way 
%   round. The |shrinkedge| is what will become the parent edge of 
%   $p$.
%   \begin{tcl}
      set p $q
      foreach {e2 o2 childL} [lindex $heap $p] break
      while {$e2 != $cutedge} {
         set q [lindex $NW 1 $e2 [expr {1-$o2}]]
         set L [list $e2 $q]
         foreach {e v} $childL {
            if {$e != $shrinkedge} then {lappend L $e $v}
         }
         lset heap $p [list $shrinkedge $orient $L]
         set p $q
         set orient [expr {-$o2}]
         set shrinkedge $e2
         foreach {e2 o2 childL} [lindex $heap $p] break
      }
      set L {}
      foreach {e v} $childL {
         if {$e != $shrinkedge} then {lappend L $e $v}
      }
      lset heap $p [list $shrinkedge $orient $L]
   }
   return $heap
}
%   \end{tcl}
% \end{proc}
% 
% Before one can actually use this procedure to find the optimal 
% solution, it is however necessary to construct a valid initial 
% \word{heap}, which is not altogether trivial. The method used by 
% |vertex_levels4| is to put each vertex at its minimal position, 
% considering a vertex only when all its down-neighbours have already 
% been put in the tree.
% 
% 
% \begin{proc}{vertex_levels4}
%   Providing yet another solution to the same problem, the 
%   |vertex_levels4| procedure computes a list assigning an integer 
%   level to each vertex, in such a way that the output end of an edge 
%   is always strictly less than the input end. The call syntax is
%   \begin{quote}
%     |network::pure::vertex_levels4| \word{network}
%   \end{quote}
%   and the return value is the list, indexed by vertex labels, of the 
%   assigned vertex levels.
%   
%   The lowest level is $0$, whose lone occupant is the output vertex 
%   |0|. Levels are always integers. The output vertex |0| always has 
%   a level less than any other vertex, and the input vertex |1| always 
%   has a level greater than any other vertex.
%   
%   The first step is to augment the \word{network} with extra 
%   edges for the non-edge inequalities.
%   \begin{tcl}
proc network::pure::vertex_levels4 {NW} {
%<timing>puts [time {
   set V [lrange [lindex $NW 0] 0 1]
   set E [lindex $NW 1]
   set outL [lindex $NW 0 0 2]
   set inL [lindex $NW 0 1 1]
   set e [list 0 [llength $outL] 1 [llength $inL]]
   lappend outL [llength $E]
   lappend inL [llength $E]
   lappend E $e
   foreach v [lrange [lindex $NW 0] 2 end] {
      foreach {a b c} $v break
      set e [list [llength $V] [llength $c] 1 [llength $inL]]
      lappend inL [llength $E]
      lappend c [llength $E]
      lappend E $e
      set e [list 0 [llength $outL] [llength $V] [llength $b]]
      lappend outL [llength $E]
      lappend b [llength $E]
      lappend E $e
      lappend V [list $a $b $c]
   }
   lset V 0 2 $outL
   lset V 1 1 $inL
%<timing>} 10]
   set NW [list $V $E]
%   \end{tcl}
%   
%   Then comes the task of constructing the initial working tree. 
%   This is done with all vertices put in as low a $y$-position as 
%   possible, only attaching a vertex after all its down-neighbours 
%   have already been attached. This requires identifying the 
%   down-neighbour which puts the strictest bound on the vertex to 
%   attach, which amounts to finding the longest (when infinitesimal 
%   corrections are taken into account) path from the vertex to the 
%   root. Since all infinitesimal terms at this stage are negative, 
%   they can be kept as lists of orders, and it is necessary to keep 
%   track of all terms since the leading ones may well be common for 
%   several paths being compared. On the other hand, it is then not 
%   necessary to separately keep track of the finite part of the path 
%   length, since it is equal to the length of the list of orders. In 
%   the end, the longest path turns out to be the one whose list of 
%   edges is largest in length-lexicographic order.
%   \begin{tcl}
%<timing>puts [time {
   set heap {}
   foreach v $V {
      set Needed([llength $heap]) [llength [lindex $v 1]]
      lappend heap dummy
   }
   lset heap 0 {at 0 {}}
   set Orders(0) {}
   set queue {}
   foreach e [lindex $V 0 2] {
      set u [lindex $E $e 2]
      if {![incr Needed($u) -1]} then {lappend queue $u}
   }
   for {set n 0} {$n < [llength $queue]} {incr n} {
      set v [lindex $queue $n]
      lset heap $v [list at [llength $V] {}]
      set L {}
      foreach e [lindex $V $v 1] {
         set u [lindex $E $e 0]
         lappend L [list $e [llength $Orders($u)] [
            lsort -integer [linsert $Orders($u) end $e]
         ]]
      }
      set L [lsort -index 1 -integer [lsort -index 2 -dictionary $L]]
      set e [lindex $L end 0]
      set Orders($v) [lindex $L end 2]
      lset heap $v [list $e 1 {}]
      set u [lindex $E $e 0]
      lset heap $u 2 [linsert [lindex $heap $u 2] end $e $v]
      foreach e [lindex $V $v 2] {
         set u [lindex $E $e 2]
         if {![incr Needed($u) -1]} then {lappend queue $u}
      }
   }
%   \end{tcl}
%   The above leaves vertex $1$ variable, but it has been claimed 
%   that this vertex should be fixed, so here's how to do that:
%   \begin{tcl}
   set v [lindex $E [lindex $heap 1 0] 0]
   lset heap 1 [list at [llength $Orders(1)] {}]
   lset heap $v 2 {}
%   \end{tcl}
%   Many more vertices may be fixed, to reduce the number of 
%   variables in the \textsc{simplex} phase, but the problem is how 
%   to do that. Fixing all vertices on the tree path from $1$ to $0$ 
%   may seem like the thing to do, but the problem is that this moves 
%   vertices infinitesimally upwards, which in turn may require other 
%   vertices to be reattached.
%   \begin{tcl}
%<timing>} 10]
%   \end{tcl}
%   Running \textsc{simplex} is delegated to a separate procedure 
%   (partly because this might eventually be shared with Yet Another 
%   |vertex_levels|$n$, should \(n=4\) prove too slow or something).
%   \begin{tcl}
%<timing>puts [time {
%<timing>   set heap2 [vertex_levels4,simplex $NW $heap]
%<timing>} 10]
%<-timing>   set heap [vertex_levels4,simplex $NW $heap]
%   \end{tcl}
%   Then there's the matter of constructing the result. This is done 
%   by changing all variable nodes in the tree to fixed nodes.
%   \begin{tcl}
%<timing>puts [time {
%<timing>   set heap $heap2
   set queue {}
   foreach {e v} [lindex $heap 0 2] {
      set u [lindex $E $e [expr {1-[lindex $heap $v 1]}]]
      lappend queue [list $v [lindex $heap $u 1]]
   }
   for {set n 0} {$n < [llength $queue]} {incr n} {
      foreach {v level} [lindex $queue $n] break
      incr level [lindex $heap $v 1]
      foreach {e u} [lindex $heap $v 2] {lappend queue [list $u $level]}
      lset heap $v [list at $level {}]
   }
   set res {}
   foreach p $heap {lappend res [lindex $p 1]}
%<timing>} 10]
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Sequencing of levels}
% 
% The following procedures seek to find a horizontal ordering of 
% vertices within each level.
% 
% 
% \begin{proc}{level_observations}
%   For each level of a component, this procedure compiles a list of 
%   observations of that level, to serve as an aid for ordering the 
%   items in that level. An observation is in this case a list of 
%   items (on the |vertex |\word{label} or |edge |\word{label} form), 
%   listing items from left to right as they might be reached by 
%   different paths from some starting vertex. A weighted list of  
%   observations is a list with the structure
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{observation} 
%     \word{weight}\end{regblock}
%   \end{quote}
%   where the \word{weight} is a real number. The return value is a 
%   list (one element for each level) of weighted lists of 
%   observations.
%   
%   The call syntax is
%   \begin{quote}
%     |level_observations| \word{network} \word{component} 
%     \word{ignore-list} \word{pseudo-outs} \word{pseudo-ins} 
%     \word{weight-base}\regopt
%   \end{quote}
%   where \word{network} is the network to observe and 
%   \word{component} is the component (as a list of levels, where 
%   each level is a list of items) to observe within that network. 
%   Only |vertex| elements in the \word{component} are considered, 
%   but the \word{component} must include all neighbours of vertices 
%   in the \word{component}. |edge|s in the result are generated from 
%   the \word{network}, so there may occur even if they were not 
%   mentioned in the \word{component}.
%   
%   The \word{ignore-list} is a list of vertex labels. Observations 
%   made from these vertices will not be included in the result, but 
%   they may figure in observations. The \word{pseudo-outs} and 
%   \word{pseudo-ins} are lists of lists of edge labels. For each 
%   element of \word{pseduo-outs}, a sequence of observations are 
%   added as if these edges had been the output legs of the network 
%   (except that the listed edges themselves are not observed at any 
%   level, only the vertices at their input ends and up), and 
%   similarly for \word{pseudo-ins} but at the other end. (These 
%   features can be used to discover a good ordering of inputs and 
%   outputs in ambiguities.)
%   
%   The \word{weight-base} defaults to $0.9$. The weight attributed 
%   to an observation is the \word{weight-base} raised to the same 
%   power as the number of levels between the observer and that which 
%   is being observed.
%   
%   The first part of the procedure constructs observations looking 
%   down from a vertex. The idea is that one gets the observations 
%   from a vertex by concatenating the observations from its 
%   down-neighbours, so the processing proceeds from lower levels to 
%   higher levels. A slight complication is that a vertex in 
%   general observes several levels, so an entry of the |Downview| 
%   array is in general a list, where the $i$th element is the 
%   observation of level $i$. All levels are processed in turn for 
%   each vertex.
%   \begin{tcl}
proc network::pure::level_observations {NW component ignoreL\
  pseudoOL pseudoIL {wb 0.9}} {
   set l -1; foreach level $component {incr l
      foreach item $level {
         if {[lindex $item 0] ne "vertex"} then {continue}
         set v [lindex $NW 0 [lindex $item 1]]
         for {set k 0} {$k<$l} {incr k} {
            set L {}
            foreach e [lindex $v 1] {
               set subitem [list vertex [lindex $NW 1 $e 0]]
               if {[llength $Downview($subitem)] <= $k} then {
                  lappend L [list edge $e]
%   \end{tcl}
%   If there are levels missing between that being generated and that 
%   which was available at a down-neighbour, then the intermediate 
%   levels should be padded out with the connecting edge.
%   \begin{tcl}
               } else {
                  eval [list lappend L]\
                    [lindex $Downview($subitem) $k]
               }
            }
            lappend Downview($item) $L
         }
%   \end{tcl}
%   The final step is in forming the observations from a vertex is to 
%   add the vertex itself, at the new level that it is in.
%   \begin{tcl}
         lappend Downview($item) [list $item]
      }
   }
%   \end{tcl}
%   The second part does the same thing for observations looking up.
%   \begin{tcl}
   for {set l 0} {$l < [llength $component]} {incr l} {
      foreach item [lindex $component end-$l] {
         if {[lindex $item 0] ne "vertex"} then {continue}
         set v [lindex $NW 0 [lindex $item 1]]
         for {set k 0} {$k<$l} {incr k} {
            set L {}
            foreach e [lindex $v 2] {
               set subitem [list vertex [lindex $NW 1 $e 2]]
               if {[llength $Upview($subitem)] <= $k} then {
                  lappend L [list edge $e]
               } else {
                  eval [list lappend L]\
                    [lindex $Upview($subitem) $k]
               }
            }
            lappend Upview($item) $L
         }
         lappend Upview($item) [list $item]
      }
   }
%   \end{tcl}
%   The third part constructs observations for the pseudo-inputs and 
%   pseudo-outputs; these are entered into the |Downview| and |Upview| 
%   arrays as elements with numeric names.
%   \begin{tcl}
   set item -1; foreach inL $pseudoIL {incr item
      set k -1; foreach level $component {incr k
         set L {}
         foreach e $inL {
            set subitem [list vertex [lindex $NW 1 $e 0]]
            if {[llength $Downview($subitem)] > $k} then {
               eval [list lappend L] [lindex $Downview($subitem) $k]
            }
         }
         lappend Downview($item) $L
      }
   }
   set item -1; foreach outL $pseudoOL {incr item
      set k -1; foreach level $component {incr k
         set L {}
         foreach e $inL {
            set subitem [list vertex [lindex $NW 1 $e 2]]
            if {[llength $Upview($subitem)] > $k} then {
               eval [list lappend L] [lindex $Upview($subitem) $k]
            }
         }
         lappend Upview($item) $L
      }
   }
%   \end{tcl}
%   The last part is to construct the return value. If the current 
%   level is below the level of an item, then the observation should 
%   be taken from looking down, otherwise the observation is taken 
%   from looking up. Observations of less than two items in a level 
%   are ignored, as they do not contribute any new information. First 
%   the observations from ignored vertices are removed, however.
%   \begin{tcl}
   foreach v $ignoreL {
      unset -nocomplain Downview([list vertex $v])\
        Upview([list vertex $v])
   }
   set we [expr {log($wb)}]
   set res {}
   set l -1; set k [llength $component]
   foreach level $component {
      incr l; incr k -1
      set L {}
      foreach item [array names Downview] {
         set len [llength $Downview($item)]
         set w [expr {exp((abs($len-1-$l)-1)*$we)}]
         if {$l < $len} then {
            if {[llength [lindex $Downview($item) $l]]>1} then {
               lappend L [lindex $Downview($item) $l] $w
            }
         } else {
            if {[llength [lindex $Upview($item) $k]]>1} then {
               lappend L [lindex $Upview($item) $k] $w
            }
         }
      }
      lappend res $L
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsubsection{Sequencing by extending orders}
% 
% The idea of the next procedure is that an extraction of an order from 
% a digraph one should begin by looking for a maximal path 
% in the digraph that one wishes to sequence, as that can then be taken 
% as a chain in the output sequence of all items. If the path happens 
% to be hamiltonian, we're even done.
% 
% Paths should be compared as follows:
% \begin{enumerate}
%   \item
%     By length (longer is better), since using all vertices in a cycle 
%     is better than stopping one short to avoid seeing the back-edge.
%   \item
%     By number of back-edges (fewer is better). This has the effect of 
%     cutting a cycle at its thinnest part.
%   \item
%     By length of the back-edges (shorter is better), lexicographically.
% \end{enumerate}
% It would be fairly easy (although asymptotically rather slow) to 
% compile a list of all paths in a digraph and then sort it to find the 
% best path, but how does one proceed from there? Possibly by discarding 
% those paths that contradict the chosen order and then trying 
% again\Ldash it could even be considered part of one big loop, where 
% paths are incorporated into the sequence as they are found\Dash but 
% how does one integrate paths into a total order? Answer: By putting 
% them into a partial order first! 
% 
% This looks like it could be \emph{real} slow. But let's try it anyway!
% 
% \begin{proc}{order_using_paths}
%   This procedure tries to extract a natural total order for a list 
%   \word{items} of items from a list \word{observations} of 
%   observations of said elements, as described above. The call syntax 
%   is
%   \begin{quote}
%     |network::pure::order_using_paths| 
%     \begin{regblock}[\regopt]|-limit| \word{limit}\end{regblock}
%     \word{items} \word{observations}
%   \end{quote}
%   where the \word{limit} can be used to bail out if it seems the 
%   full ordering will be too expensive: if there are more paths in 
%   total than the \word{limit} value then the procedure just returns 
%   an empty list. Otherwise the return value is the reordered list 
%   of items. The default \word{limit} is $325$ (the number of paths 
%   in a $K_5$).
%   \changes{2}{2007/02/27}{\texttt{-limit} option added. (LH)}
%   
%   \changes{2}{2007/02/27}{Now using weighted comparisons. (LH)}
%   \textbf{Note} that the \word{observations} here is a list
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{observation} 
%     \word{weight}\end{regblock}
%   \end{quote}
%   where \word{weight} is a real number that is a weight to attach 
%   to the preceeding \word{observation}. This weight is taken into 
%   account when comparing the number of back-edges, so that the 
%   multiplicity comparison really is done in two steps:
%   \begin{enumerate}
%     \item[2a]
%       By total weight of back-edges (arithmetic sum), where less 
%       weight is better.
%     \item[2b]
%       By total number of back-edges, where fewer is better.
%   \end{enumerate}
%   The 2b step is necessary for the correctness of the comparison 
%   step on length of back-edges.
%   
%   \begin{tcl}
proc network::pure::order_using_paths {args} {
   if {[llength $args] < 2} then {
      return -code error "Wrong # of arguments"
   }
   set itemL [lindex $args end-1]
   set obsL [lindex $args end]
   array set Opt {-limit 325}
   array set Opt [lrange $args 0 end-2]
   if {[llength $itemL] <= 1} then {return $itemL}
%   \end{tcl}
%   The first step is to combine the \word{observations} into a 
%   digraph with multiplicity. |D| is a list, with the same indices as 
%   |itemL|, and its elements are lists
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{vertex-label} 
%     \word{multiplicity} \word{weight-sum}\end{regblock}
%   \end{quote}
%   where each \word{vertex-label} is the out-neighbour at the other 
%   end and \word{multiplicity} is the number of edges from this 
%   vertex to that vertex. |E| is a temporary array with indices on 
%   the form \meta{from-label}\verb*" "\meta{to-label} and whose 
%   entries are lists with one weight for every edge. |E2| is another 
%   temporary array which is cleared for each observation. The 
%   indices are on the same form as in |E| whereas the entries are 
%   string with one character for every pair in the observation. Only 
%   pairs that occur more often than opposite pairs make it into |E|.
%   \begin{tcl}
   set n -1; foreach item $itemL {incr n
      set itemNum($item) $n
   }
   foreach {obs weight} $obsL {
      set n 0; foreach item $obs {incr n
         if {![info exists itemNum($item)]} then {continue}
         set i $itemNum($item)
         foreach item [lrange $obs $n end] {
            if {[info exists itemNum($item)]} then {
               append "E2($i $itemNum($item))" .
            }
         }
      }
      foreach pair [array names E2] {
         set oppair [list [lindex $pair 1] [lindex $pair 0]]
         if {![info exists E2($oppair)] ||\
           [string length $E2($pair)] > [string length $E2($oppair)]}\
         then {lappend E($pair) $weight}
      }
      array unset E2
   }
   set D {}
   foreach item $itemL {
      set L {}
      foreach pair [array names E "[llength $D] *"] {
         set weight 0.0
         foreach w $E($pair) {set weight [expr {$weight+$w}]}
         lappend L [lindex $pair 1] [llength $E($pair)] $weight
      }
      lappend D $L
   }
   array unset E
%   \end{tcl}
%   A variation that could be made here would be to exclude loops in 
%   the digraph. The effect of including the loops is that vertices 
%   with a lot of loops (which should indicate ambiguity in its 
%   position) are avoided, in the sense that it counts as a 
%   disadvantage for paths to pass them. I expect the effect to be 
%   rather small, however.
%   
%   The second part is the dreaded construction of a list of all 
%   paths. It is a DFS using a |stack|, where the elements are lists 
%   on the form
%   \begin{quote}
%     \word{vertex-list} \word{backedge-lengths} \word{back-weight}
%   \end{quote}
%   The \word{vertex-list} is the list of vertices in the path, in 
%   order from first to last. The \word{backedge-lengths} is the list 
%   (in no particular order) of lengths of backedges in the path, 
%   \emph{not including backedges from the last vertex}. The 
%   \word{back-weight} is the sum of the weights of the edges which 
%   have contributed to the \word{backedge-lengths} list.
%   
%   What is produced by this work is a list of paths |pathL|, whose 
%   elements are lists with the structure
%   \begin{quote}
%     \word{vertex-list} \word{comparison-list}
%   \end{quote}
%   The \word{vertex-list} is the actual path, as in the |stack|. The 
%   \word{comparison-list} is the thing according to which different 
%   paths should be compared. It is a list with the structure
%   \begin{quote}
%     \word{\# vertices left} \word{backedge-weight} 
%     \word{\# backedges} \word{backedge-length}\regstar
%   \end{quote}
%   and will be treated as described above by |lsort -dictionary|. 
%   The \word{backedge-weight} is given with six decimals to ensure 
%   this comparison will give it a sensible interpretation. 
%   (A possible variation could be to use the number of edges in the 
%   path instead of the number of vertices, i.e., to give a bonus to 
%   paths containing multiple edges. I can't see that this change 
%   would be to the better, however.)
%   
%   The stack is initialised with one element for each vertex (the 
%   length $0$ paths). The partial order |P| to construct in the 
%   third part is also initialised with the identity relation.
%   \begin{tcl}
   set stack {}
   foreach item $itemL {
      set "P([llength $stack] [llength $stack])" {}
      lappend stack [list [list [llength $stack]] {} 0.0]
   }
   set pathL {}
   while {[llength $stack]} {
      foreach {path backlenL weight} [lindex $stack end] break
      set stack [lreplace $stack [set stack end] end]
      set L {}
      foreach {v mult w} [lindex $D [lindex $path end]] {
         set n [lsearch -exact -integer $path $v]
         if {$n>=0} then {
            set n [expr {[llength $path] - $n - 1}]
            for {} {$mult>0} {incr mult -1} {lappend backlenL $n}
            set weight [expr {$weight+$w}]
         } else {
            lappend L $v
         }
      }
      lappend pathL [list $path [
         linsert [lsort -integer -decreasing $backlenL] 0\
           [expr {[llength $itemL]-[llength $path]}]\
           [format %f.6 $weight] [llength $backlenL]
      ]]
      if {[llength $pathL] > $Opt(-limit)} then {return}
      foreach v $L {
         lappend stack [list [linsert $path end $v] $backlenL $weight]
      }
   }
%   \end{tcl}
%   
%   The third part is to construct a partial order |P|, by adding to 
%   it all chains implied by the paths that do not contradict the |P| 
%   so far constructed. The |target| is the size |P| would have if it 
%   is a total order on the items; if this is reached then the rest 
%   of the |pathL| can be skipped.
%   \begin{tcl}
   set target [expr {[llength $itemL] * ([llength $itemL]+1) / 2}]
   foreach pair [
      lsort -index 1 -dictionary $pathL
   ] {
      set ok 1
      set n 0; foreach u [lindex $pair 0] {incr n
         foreach v [lrange [lindex $pair 0] $n end] {
            set ok [expr {$ok && ![info exists "P($v $u)"]}]
         }
         if {!$ok} then {break}
      }
      if {!$ok} then {continue}
      set u [lindex $pair 0 0]
      foreach v [lrange [lindex $pair 0] 1 end] {
         if {![info exists "P($u $v)"]} then {
            set L [array names P "* $u"]
            foreach y [array names P "$v *"] {
               foreach x $L {
                  set "P([lindex $x 0] [lindex $y 1])" {}
               }
            }
         }
         set u $v
      }
      if {[array size P] >= $target} then {break}
   }
%   \end{tcl}
%   The fourth and final part turns the partial order |P| into a 
%   permutation of |itemL|. |P| need not be a total ordering at this 
%   point, but since all observations turn up as paths of length $1$, 
%   any two items that have been compared will be related by |P| at 
%   this stage.
%   
%   The method used to extract a total order from the partial order 
%   |P| is to order items by the sizes of their down-sets.
%   \begin{tcl}
   set L {}
   foreach item $itemL {
      lappend L [list $item [llength [array names P "* [llength $L]"]]]
   }
   set res {}
   foreach pair [lsort -index 1 -integer $L] {
      lappend res [lindex $pair 0]
   }
   return $res
}
%   \end{tcl}  
% \end{proc}
% 
% Interestingly enough, |order_using_paths| turns out to do exactly 
% the right thing for all ``difficult'' cases that had previously 
% been constructed for other ordering procedures below. Nor does it 
% seems to be unacceptably slow (even though it is superexponential 
% in both time and memory for complete digraphs), so it should 
% probably be the default choice for ordering by observations.
% 
% \begin{proc}{order_path_Kn}
%   Well, aymptotics that have no impact during development often 
%   surfaces with a vengence once one enters the ``production'' 
%   phase. Hence it may be a good idea to find out how long it takes 
%   before the superexponential behaviour gets noticable; there's a 
%   difference between it becoming dominant for $5$ elements or for 
%   $10$ elements.
%   
%   The following procedure generates observations for a complete 
%   digraph on $n$ vertices. This is useful for |time|ing 
%   |order_using_paths|.
%   \begin{tcl}
%<*test2>
proc network::pure::order_path_Kn {n} {
   set obsL {}
   set itemL {}
   for {set i 0} {$i<$n} {incr i} {
      lappend itemL $i
      for {set j 0} {$j<$n} {incr j} {
         lappend obsL [list $i $j] 1.0
      }
   }
   order_using_paths $itemL $obsL
}
%</test2>
%   \end{tcl}
%   Timing experiments show that the execution time is starting to 
%   get annoying already for \(n=5\), and the superexponential 
%   behaviour is quite noticable.
% \end{proc}
% 
% \begin{proc}{sequence_from_digraph}
%   The |sequence_from_digraph| procedure tries to find an ordering 
%   of the vertices of a multidigraph (given as a weighted adjancecy 
%   matrix) so that the edges mostly go from right to left. The 
%   algorithm used is at best a heuristic, and unfortunately it seems 
%   to have a tendency to get it wrong.
%   
%   The call syntax is
%   \begin{quote}
%     |sequence_from_digraph| \word{matrix}
%   \end{quote}
%   and the return value is a permutation of $\{0,1,\dotsc, n 
%   -\nobreak 1\}$, where \word{matrix} is an $n \times n$ matrix. 
%   The elements of this matrix are numbers (which may be real 
%   and\slash negative, even though natural numbers probably makes 
%   most sense) and the element |lindex |\word{matrix}| $i $j| is 
%   interpreted as the multiplicity (or more generally weight) of the 
%   edge from $j$ to $i$.
%   
%   The algorithm idea is to remove vertices one by one until only 
%   none remain, and then reinsert the vertices one by one in the 
%   position which minimises the number of edges going backwards. 
%   During the vertex removal phase, the weights of edges in the 
%   remaining graph are increased by the number of equivalent paths 
%   passing through the removed vertex, to compensate for the removal 
%   of this vertex. The principles used are that two edges in series 
%   count as the minimum of their weights, while two edges in 
%   parallel count as the sum of their weights. The first principle 
%   has the effect that the strength of a cycle (minimum of the 
%   weights of edges on it\Dash think wakest link of a chain) is 
%   preserved during vertex removal, whereas the second principle 
%   says that parallel paths can support each other. It may seem as 
%   though this is somehow counting edge-disjoint paths from one 
%   vertex to another, but for that the algorithm is imperfect. 
%   Consider the matrix
%   \[
%     \begin{pmatrix}
%       0& 0& 0& 0\\
%       1& 0& 0& 0\\
%       1& 1& 0& 0\\
%       0& 1& 2& 0
%     \end{pmatrix}
%   \]
%   Removing first vertex $1$ and then vertex $2$ will produce 
%   matrices as on the left, whereas removing first vertex $2$ and 
%   then vertex $1$ will produce matrices as on the right:
%   \begin{align*}
%     \begin{pmatrix}
%       0& \cdot& 0& 0\\
%       \cdot& \cdot& \cdot& \cdot\\
%       2& \cdot& 0& 0\\
%       1& \cdot& 2& 0
%     \end{pmatrix} &&&
%     \begin{pmatrix}
%       0& 0& \cdot& 0\\
%       1& 0& \cdot& 0\\
%       \cdot& \cdot& \cdot& \cdot\\
%       1& 2& \cdot& 0
%     \end{pmatrix}
%     \\
%     \begin{pmatrix}
%       0& \cdot& \cdot& 0\\
%       \cdot& \cdot& \cdot& \cdot\\
%       \cdot& \cdot& \cdot& \cdot\\
%       3& \cdot& \cdot& 0
%     \end{pmatrix} &&&
%     \begin{pmatrix}
%       0& \cdot& \cdot& 0\\
%       \cdot& \cdot& \cdot& \cdot\\
%       \cdot& \cdot& \cdot& \cdot\\
%       2& \cdot& \cdot& 0
%     \end{pmatrix}
%   \end{align*}
%   The problem is that the path from $0$ to $2$ via $1$ is counted 
%   as independent of the path from $0$ to $3$ via $1$, which isn't 
%   the case as they both use the same weight $1$ path from $0$ to 
%   $1$. In order to properly count edge-disjoint paths, one would 
%   have to interpret the digraph as a network compute a maximal flow 
%   from one vertex to the other, but it is not clear that this would 
%   necessarily give a better take on the vertex ordering problem 
%   targeted here.
%   
%   In the first algorithmic step, 
%   the vertices are removed in decreasing order, and the weights in 
%   the reduced adjacency matrix are modified as explained above.
%   \begin{tcl}
proc network::pure::sequence_from_digraph {A} {
   for {set n [llength $A]; incr n -1} {$n>0} {incr n -1} {
      for {set i 0} {$i < $n} {incr i} {
         set w2 [lindex $A $i $n]
         for {set j 0} {$j < $n} {incr j} {
            set w0 [lindex $A $i $j]
            set w1 [lindex $A $n $j]
            lset A $i $j [expr {$w1<$w2 ? $w0+$w1 : $w0+$w2}]
         }
      }
   }
%   \end{tcl}
%   In the second algorithmic step, the vertices are reinserted in 
%   the opposite order. The |i| variable holds the insertion position 
%   currently being considered. The |sum| variable is the sum of all 
%   weights of backedges (incident with the vertex to insert) if the 
%   vertex is inserted at position |i|. 
%   \begin{tcl}
   set res {}
   for {set n 0} {$n < [llength $A]} {incr n} {
      set sum 0
      foreach u $res {
         set sum [expr {$sum + [lindex $A $u $n]}]
      }
      set best $sum
      set where 0
      set i 0; foreach u $res {incr i
         set sum [expr {$sum - [lindex $A $u $n] + [lindex $A $n $u]}]
         if {$sum <= $best} then {
            set best $sum ; set where $i
         }
      }
      set res [linsert $res $where $n]
   }
   return $res
}
%   \end{tcl}
%   The experiment |network::pure::sequence_from_digraph\
%   {{0 0 0 1} {1 0 0 0} {1 1 0 0} {0 1 2 0}}| (which returns 
%   |0 3 2 1| rather than the expected |3 2 1 0|) indicates that this 
%   is perhaps not as good an algorithm as it initially seemed. Need 
%   to rethink the matter.
% \end{proc}
% 
% 
% \subsubsection{Ranking by score}
% 
% Ranking is the problem of totally ordering a list of items given 
% some information about how they compare (when no additional 
% comparisons can be obtained). A very common idea for this is to 
% assign a score to each item and then consider the items to compare 
% as their scores. One might imagine that the world of chess should 
% have solved to problem of how to compute good scores for players 
% (since they actually have such a ranking system in operation), but 
% unfortunately the chess ranking is a rather strange system with 
% substantial flaws in its theoretical basis, so we will have to look 
% elsewhere for something usable.
% 
% \begin{proc}{colley_ranking}
%   The Colley ranking~\cite{Colley} is a method (originally deviced 
%   for American college football championships) of ranking a set of 
%   ``teams'' based on the set of matches they have played, even if the 
%   opponents in those matches do not cover a representative subset of 
%   the league as a whole. The idea is that the relative strengths (as 
%   computed by the ranking method itself) of the opponents should be 
%   taken into account when judging what a particular combination of 
%   wins or losses means to the ranking. Practically one ends up 
%   solving a linear equation system.
%   
%   The call syntax is
%   \begin{quote}
%     |colley_ranking| \word{teams} \word{observations} 
%     \word{pre-season}
%   \end{quote}
%   where \word{teams} is the number $n$ of teams (called $0$, $1$, 
%   dots, $n-1$) to rank and \word{observations} is the list of 
%   observations according to which they should be ranked. An 
%   observation is a list of team names, where a pair $(i,j)$ means 
%   `$i$ lost to $j$', a triple $(i,j,k)$ means `$i$ lost to $j$ and 
%   $k$, and $j$ lost to $k$', etc. Teams can occur more than once in 
%   an observation, and in that case subobservations of the form 
%   `$i$ lost to $i$' should be ignored.
%   
%   The \word{pre-season} argument is a special feature to force 
%   breaking ties in a way that does not contradict too many 
%   observation. What it means is that the first \word{pre-season} 
%   matches that can be parsed out of the \word{observations} should 
%   be ignored when ranking; hopefully this will disturb an 
%   equilibrium enough to allow some team to be split away from the 
%   other. \word{pre-season} must be an integer, and the feature is 
%   inactive for non-positive values.
%   
%   The return value is the ranking vector. However, if 
%   \word{pre-season} is greater than or equal to the number of 
%   matches observed then the procedure will return with a |break| 
%   code, to force exit of a surrounding loop.
%   
%   The algorithm is to solve the equation \(C \mathbf{x} = 
%   \mathbf{b}\), where $C$ is the so-called Colley matrix for the 
%   problem. This is defined by
%   \begin{equation*}
%     C_{ij} = \begin{cases}
%       2 + \#(\text{games played by team $i$})& \text{if \(i=j\),}\\
%       -\#(\text{games $i$ against $j$})& \text{otherwise.}
%     \end{cases}
%   \end{equation*}
%   The vector $\mathbf{b}$ has $b_i$ equal to $1$ plus half the 
%   difference between the number of wins for team $i$ and the number 
%   of losses for team $i$. It may be observed that this does not 
%   take into account \emph{against which} teams there were losses or 
%   wins, which may seem a bit surprising, but if the results agree 
%   with a partial ordering of the teams then this partial ordering 
%   can actually be recovered from $C$ and $\mathbf{b}$.
%   
%   The implementation first constructs the augmented matrix for the 
%   equation system, then uses Gaussian elimination and 
%   back-substitution to solve it.
%   \begin{tcl}
proc network::pure::colley_ranking {teams obsL preseason} {
%   \end{tcl}
%   The augmented matrix is first filled in with the data 
%   corresponding to ``no matches played'', so that its entries can 
%   subsequently be freely accessed with |lindex| and |lset|. Note 
%   that all entries are doubles,
%   \begin{tcl}
   set L [string repeat "0.0 " $teams]
   lappend L 1.0
   set Cb {}
   for {set i 0} {$i<$teams} {incr i} {
      lappend Cb $L
      lset Cb $i $i 2.0
   }
%   \end{tcl}
%   Then augmented matrix is updated with the observations.
%   \begin{tcl}
   foreach obs $obsL {
      for {set n 1} {$n < [llength $obs]} {incr n} {
         set j [lindex $obs $n]
         for {set m 0} {$m<$n} {incr m} {
            set i [lindex $obs $m]
            if {$i == $j} then {continue}
            if {[incr preseason -1] >= 0} then {continue}
            lset Cb $i $i [expr {[lindex $Cb $i $i] + 1}]
            lset Cb $i $j [expr {[lindex $Cb $i $j] - 1}]
            lset Cb $j $i [expr {[lindex $Cb $j $i] - 1}]
            lset Cb $j $j [expr {[lindex $Cb $j $j] + 1}]
            lset Cb $i end [expr {[lindex $Cb $i end] - 0.5}]
            lset Cb $j end [expr {[lindex $Cb $j end] + 0.5}]
         }
      }
   }
   if {$preseason>=0} then {return -code break}
%   \end{tcl}
%   If no observations have been registered, then |break| the caller, 
%   as specified.
%   
%   Next step is the Gaussian elimination. It can be carried 
%   out without having to worry about pivoting elements, 
%   thanks to the particular structure of the Colley matrix $C$. 
%   Proof: The matrix starts out with each row having a sum of 
%   $2$ and all off-diagonal elements non-positive (hence all 
%   diagonal elements $\geqslant 2$). After each step 
%   of the elimination, it remains true for the submatrix left to 
%   eliminate that the the row sums are at least $2$ and all 
%   off-diagonal elements are non-positive, because all row multiples 
%   being added are non-negative and hence the only thing ever added 
%   to an off-diagonal element is a non-positive number. At the same 
%   time, the row sums never decrease.
%   
%   For practical reasons, it is more convenient to eliminate 
%   right-to-left, so the result after the elimination step will be a 
%   lower triangular system rather than the traditional upper 
%   triangular system.
%   \begin{tcl}
   for {set n [llength $Cb]; incr n -1} {$n>=0} {incr n -1} {
      for {set i [expr {$n-1}]} {$i>=0} {incr i -1} {
         set mult [expr {-[lindex $Cb $i $n]/[lindex $Cb $n $n]}]
         set L {}
         foreach x [lindex $Cb $i] y [lindex $Cb $n] {
            lappend L [expr {$x + $mult*$y}]
         }
         lset Cb $i $L
      }
   }
%   \end{tcl}
%   Finally, there is the back-substitution step. Since the matrix is 
%   now lower triangular, the result vector can be constructed start 
%   to end.
%   \begin{tcl}
   set res {}
   foreach row $Cb {
      set sum [lindex $row end]
      set j 0
      foreach x $res {
         set sum [expr {$sum - [lindex $row $j]*$x}]
         incr j
      }
      lappend res [expr {$sum / [lindex $row $j]}]
   }
   return $res
}
%   \end{tcl}
%   
%   In the example
%   \begin{quote}
%     |colley_ranking 4 {{0 1 2} {2 3} {1 3} {3 0}} 0|
%   \end{quote}
%   teams |0| and |1| both get the ranking $\frac{5}{12}$, whereas 
%   teams |2| and |3| both get the ranking $\frac{7}{12}$. This is no 
%   accident; all teams play each other team once, and the first two 
%   have one win and two defeats (whereas the last two have two wins 
%   and one defeat), so of course they will get the same ranking by 
%   this method. Computing rankings within the subproblems of only 
%   teams |0| and |1|, or only teams |2| and |3|, would however 
%   distinguish these, so that one gets the order |0<1<2<3|.
%   
%   This will however not work with cycles, as the Colley ranking is 
%   insensitive to reversals of cycles (each team still plays the 
%   exact same set of teams, and it still has the same number of wins 
%   and defeats). Setting \word{pre-season} to |1| will in that case 
%   remove some edge from the cycle, and the rest of it will be 
%   ordered as expected.
%   
%   A case that probably isn't unusual in practice is however that 
%   there simply aren't any (useful) observations. Raising the 
%   \word{pre-season} limit won't do any good in that case, so a 
%   caller that tries to do so should probably take a |break|.
% \end{proc}
% 
% 
% \begin{proc}{rank_by_observations}
%   This procedure takes a list of items (arbitrary strings) and a list 
%   of ``observations'' of relative orderings of those items. It 
%   returns an ordering of the items which is mostly (as much as 
%   possible) consistent with the given observations.
%   The call syntax is
%   \begin{quote}
%     \raggedright
%     |rank_by_observations| \word{rank-procedure}\regopt
%     \ \word{item-list} \word{observation-list}
%   \end{quote}
%   where an observation is a list of strings. Some elements are 
%   expected to be among the given items, and elements that are not are 
%   ignored. The \word{rank-procedure} is a command prefix.
%   
%   The algorithm is based on using the \word{rank-procedure} to 
%   rank the items. This defaults to |colley_ranking|, and a custom 
%   rank procedure should have the same call syntax as |colley_ranking|. 
%   If several items get the same rank, then a recursive call is used 
%   to distinguish between them.
%   \changes{2}{2007/02/27}{Now taking weighted observations as 
%      arguments, but the weights are ignored. (LH)}
%   
%   \begin{tcl}
proc network::pure::rank_by_observations {args} {
   switch -- [llength $args] 2 {
      set rankCmd colley_ranking
      foreach {itemL obsL} $args break
   } 3 {
      foreach {rankCmd itemL obsL} $args break
   } default {
     return -code error "Wrong # args, should be:\
       [lrange [info level 0] 0 0] ?rankCmd? itemL obsL"
   }
   if {[llength $itemL] <= 1} then {return $itemL}
   set n -1; foreach item $itemL {incr n
      set itemNum($item) $n
   }
   set nObsL {}
   foreach {obs weight} $obsL {
      set L {}
      foreach item $obs {
         if {[info exists itemNum($item)]} then {
            lappend L $itemNum($item)
         }
      }
      if {[llength $L] > 1} then {lappend nObsL $L}
   }
   for {set practice 0} 1 {incr practice} {
      set vec [eval [
         linsert $rankCmd end [llength $itemL] $nObsL $practice
      ]]
%   \end{tcl}
%   |colley_ranking| breaks out of the |for| loop when |$practice| 
%   exceeds the number of pairs that can be parsed out of the 
%   observations. That typically only get to happen when |$nObsL| is 
%   empty, however.
%   \begin{tcl}
      array unset A
      foreach item $itemL rank $vec {lappend A($rank) $item}
      if {[array size A] > 1} then {
         set res {}
         foreach rank [lsort -real [array names A]] {
            eval [list lappend res]\
              [rank_by_observations $rankCmd $A($rank) $obsL]
         }
         return $res
      }
   }
   return $itemL
}
%   \end{tcl}
%   A somewhat problematic case is illustrated by the example
%   \begin{quote}
%     \raggedright
%     |rank_by_observations {a b c d e f g h}\
%     {{a b} {b c} {c d} {d e} {e f} {f g} {f h} {h a}}|
%   \end{quote}
%   which returns `|f e h a d b c g|'. An ordering 
%   `|h a b c d e f g|' would probably have been preferable (only one 
%   upset, and the |fg| edge is short), but this result doesn't seem 
%   too outragous, so it may be tried in production.
% \end{proc}
% 
% A lesson that might be learnt from this is that the natural 
% exponent for weighing upsets against each other is probably less 
% than $1$; splitting a distance up on two back-edges is worse than 
% collecting it into one, since \((a +\nobreak b)^p < a^p + b^p\) for 
% \(a,b>0\) implies \(p<1\). Unfortunately the non-metric (triangle 
% inequality violated) nature of such badness measures makes their 
% minimisation a mostly combinatorial problem, and it was only to 
% avoid a combinatorial explosion that something analytic was sought 
% in the first place!
% 
% \subsubsection{Undeveloped sequencing ideas}
% 
% Since the problem of finding an optimal presentation is highly 
% aestethic, it is no surprise that there have been a lot of false 
% starts and half-assed solutions. This subsection collects ideas that 
% haven't even made it into the coding stage yet.
% 
% 
% \paragraph{Other ranking functions}
% 
% One ranking heuristic which could be of interest is to build an 
% electrical network with one node for every item to rank where one 
% insert a \emph{charged} capacitor between two nodes for every 
% comparison. There will be a lot of short-curcuiting going on, but 
% the equilibrium voltages after the entire curcuit has been 
% assembled could be used to rank the nodes. The main problem is how 
% to compute these equilibrium voltages: series- and 
% parallel-reduction theorems exist for capacitors (and can be 
% extended suitably to the current situation), but these do not 
% suffice for analysing arbitrary curcuits. 
% Delta--star-transformations probably exist, but would have to be 
% derived, and they won't suffice for graphs with girth greater than 
% $3$.
% 
% Awkwardly enough, it feels as if there is some set of variables for 
% which the equilibrium would be rather easy to compute, but I can't 
% guess which they are at the moment. [Sigh!]
% 
% An advantage of the capacitor heuristic compared to the the Colley 
% ranking is that it handles the situation of a cycle with one leaf 
% attached by giving all vertices in the cycle the same voltage, 
% whereas Colley gives them unequal ranks, putting the vertex of 
% attachment at the extreme \emph{opposite} to the leaf (which is the 
% opposite of what one would want).
% 
% 
% 
% \paragraph{Full network ordering}
% 
% An alternative to ordering the levels of the network might seem to be 
% to order the entire network in a single step. An advantage of this 
% should be that it might be better at making the levels consistent 
% with each other, but all ranking algorithms deviced so far all fail 
% to produce the expected results for trees; it's very easy that 
% branches become entwined a couple of levels from the root if one 
% only considers local properties. Another disadvantage is that edges 
% loose their natural place in the ordering process.
% 
% An approach which looks promising is to keep the grading of the 
% network, but sequence the levels in parallel. This means the main 
% data structure for a level will be a partial order, which starts 
% out as an antichain. In each step of the process, each level 
% contributes observations of neighbouring levels, based on 
% tail\slash head indices or new orderings within the partial order. 
% The total of all observations of a level (that do not contradict 
% what is already in the partial order) is then judged and new 
% relations are added to the partial order. When no new relations are 
% discovered, the partial orders are linearised as in 
% |order_using_paths| and the full component order can be returned.
% 
% An advantage of this idea is that it avoids a combinatorial 
% explosion in |list_path_observations| that occurs because that 
% procedure effectively expands the input DAG into a tree; if 
% observations are only between neighbouring levels, the total number 
% of observations will be polynomially bounded.
% 
% The tricky issue is how to judge a set of observations. The longest 
% path algorithm of |order_using_observations| is one possibility, 
% but that is superexponential also in this case, so it should be 
% avoided if possible. An advantage of the partial ordering situation 
% is that the judge doesn't have to make a full decision and can 
% instead just rule on an obvious issue and hope that more evidence 
% can help resolve also the rest.
% 
% One interesting possibility is that of a ``$x$ near $y$'' ruling, 
% which could come about if many observations say \(x < y\) and an 
% equal number of observations say \(x > y\). The way this could be 
% realised is that if $x$ and $y$ are ruled as near then they will 
% get the same up- and downsets. However, such rulings go beyond 
% partial orders into the realm of total quasi-orders, and may 
% therefore be inappropriate.
% 
% \begin{algsketch}[Judging]
%   Read all observations, discarding those that directly contradict 
%   the current partial order $P$, and form the reflexive-transitive 
%   hull $Q$ of the these and the current partial order. $Q$ is then 
%   a quasi-order. Add all strict inequalities from $Q$ to $P$, as 
%   they are undisputed.
% \end{algsketch}
%   
% If this really added anything then we're happy, but what if it 
% didn't? Observations don't go away, so the $Q$-equivalence 
% classes can never shrink. Moreover, it can happen that 
% \(x < y \pin{P}\) and \(y \leqslant z \leqslant x \pin{Q}\), 
% which means $Q$-equivalence need not respect $P$-inequalities. 
% Apparently $z$ should be near $x$ or $y$, but it may not be 
% between $x$ and $y$.
% 
% The sensible response to this predicament is probably to fall back 
% on some kind of numerical algorithm for ordering the equivalence 
% classes. It should be observed that doing so will \emph{not} reduce 
% the number of observations of neighbouring levels, as only 
% inequalities in $P$ may generate observations.
% 
% Another point that should be observed is that the existence of $z$ 
% such that \(y \leqslant z \leqslant x \pin{Q}\) where already 
% \(x < y \pin{P}\) should not prevent adding \(x < w < y \pin{P}\) 
% if the only things known about $w$ is its relations to $x$ and $y$. 
% This may seem straightforward, but remember that $P$ does not give 
% any special power to $x$ or $y$\Dash it can only say something 
% about the relation between them.
% 
% 
% 
% 
% \paragraph{Planarity and embeddings}
% 
% Networks have a built-in combinatorial embedding determined by the 
% head and tail indices, which means it is easy to test whether a 
% given network is plane. Since the indices of inputs and outputs are 
% fairly arbitrary, it is also of interest to find an assignment of 
% these that will make the network as near-plane as possible; hopefully 
% this will simplify drawing and presenting the network later on.
% 
% The main tool for exploring embedding issues is the \emph{Euler 
% characteristic}
% \begin{equation*}
%   \#\text{vertices} - \#\text{edges} + \#\text{facets}
% \end{equation*}
% which is $2$ for a plane embedding, and generally $2-2g$ for an 
% embedding into an orientable surface of genus $g$. With respect to 
% non-orientable surfaces, the Euler characteristic is $2$ minus the 
% number of crosscaps one has to put into the surface in order to make 
% the embedding work. The Euler characteristic can thus serve as a 
% measure of how near planarity an embedding is, and since the numbers 
% of vertices and edges respecitively are fixed, the problems boil down 
% to maximising the number of facets. The input and output vertices 
% should be identified (which in many cases is equivalent to connecting 
% them by an extra edge) for purposes of examining this issue.
% 
% When seeking a near-plane embedding, there are two kinds of freedom. 
% The first is the assignment of input and output indices to legs, 
% which is what gives the wanted answer. The other is the assignment of 
% signs to edges, where a negative sign signifies that the edge in 
% question is passing through a crosscap (which twists the edge by half 
% a turn, thus switching the sides). Negative signs are only needed for 
% embedding into non-orientable surfaces, but the example of
% \begin{equation*}
%   a = (m \otimes m) \circ (2\:3) \circ (\Delta \otimes \Delta)
% \end{equation*}
% (one crossing) versus
% \begin{equation*}
%   (1\:2) \circ a \circ (1\:2) = 
%   (m \otimes m) \circ (1\:4) \circ (\Delta \otimes \Delta)
% \end{equation*}
% (five crossings) suggest that non-orientable embeddings should be 
% considered; the simplest orientable surface where both embed is the 
% torus, but $a$ can also be embedded into the projective 
% plane.\footnote{$(1\:2) \circ a \circ (1\:2)$ also has such an 
% embedding, if one connects input and output by an edge rather than 
% identifying them, and accepts giving this edge a negative sign! Doing 
% so does however preserve the idea that the input\&output vertex 
% should be considered the vertex containing the unbounded part of the 
% canvas.}
% 
% 
% \subsubsection{Best practices}
% 
% The best solution found so far seems to be to first try 
% |order_using_paths|, but switch to |rank_by_observations| if the 
% former bails out. It is convenient to have an ordering procedure 
% which implements precisely that.
% 
% \begin{proc}{default_observation_order}
%   This procedure has the call syntax
%   \begin{quote}
%     |network::pure::default_observation_order| 
%     \word{item-list} \word{observations}
%   \end{quote}
%   and returns the \word{item-list} reordered to fit with the given 
%   \word{observations}.
%   \begin{tcl}
proc network::pure::default_observation_order {itemL obsL} {
   set L [order_using_paths $itemL $obsL]
   if {[llength $L]} then {return $L}
   return [rank_by_observations $itemL $obsL]
}
%   \end{tcl}
% \end{proc}
% 
% Is this anything to worry about, though? Sadly, it is. Even in a 
% plane network, it is easy to end up with a situation where every 
% item is observed to the left of every other item, because some 
% vertex observing all of them is itself observed in two different 
% positions by another vertex.
% 
% 
% 
% \subsection{Network components}
% 
% \begin{proc}{components}
%   The |components| procedure breaks a network down into component 
%   pieces. The call syntax is
%   \begin{quote}
%     |components| \word{network}
%   \end{quote}
%   and the return value is the list of component pieces. The first 
%   piece is always the component containing the output and input 
%   vertices (even if it is not connected), but the order of other 
%   components is arbitrary (depends on the vertex labelling).
%   
%   \begin{tcl}
proc network::pure::components {NW} {
   set res {}
   set current {}
   for {set n 0} {$n<[llength [lindex $NW 0]]} {incr n} {
      set item [list vertex $n]
      if {[info exists Seen($item)]} then {continue}
      set Seen($item) ""
      set queue [list $item]
      if {$n>1} then {
         lappend res $current
         set current {}
      }
      for {set qp 0} {$qp < [llength $queue]} {incr qp} {
         lappend current [lindex $queue $qp]
         switch -- [lindex $queue $qp 0] "vertex" {
            set v [lindex $NW 0 [lindex $queue $qp 1]]
            foreach e [concat [lindex $v 1] [lindex $v 2]] {
               set item [list edge $e]
               if {![info exists Seen($item)]} then {
                  set Seen($item) ""
                  lappend queue $item
               }
            }
         } "edge" {
            foreach {v i} [lindex $NW 1 [lindex $queue $qp 1]] {
               set item [list vertex $v]
               if {![info exists Seen($item)]} then {
                  set Seen($item) ""
                  lappend queue $item
               }
            }
         }
      }
   }
   lappend res $current
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{component}
%   The |component| procedure enumerates the vertices and edges in 
%   \emph{one} component of (or a union of components in) a network. 
%   The call syntax is
%   \begin{quote}
%     |component| \word{network} \word{vertices} \word{edges}
%   \end{quote}
%   where \word{vertices} and \word{edges} are lists of labels. The 
%   return value is a pair of lists
%   \begin{quote}
%     \word{vertices} \word{edges}
%   \end{quote}
%   which contain the labels of all vertices and edges respectively 
%   that are in the same component as one given in the argument 
%   \word{vertices} or \word{edges}.
%   \begin{tcl}
proc network::pure::component {NW Vin Ein} {
   [namespace parent]::setconstlist V 0 [lindex $NW 0] \
     E 0 [lindex $NW 1]
   set queue {}
   foreach v $Vin {
      lappend queue [list vertex $v]
      lset V $v 1
   }
   foreach e $Ein {
      lappend queue [list edge $e]
      lset E $e 1
   }
   for {set qp 0} {$qp < [llength $queue]} {incr qp} {
      switch -- [lindex $queue $qp 0] "vertex" {
         set v [lindex $NW 0 [lindex $queue $qp 1]]
         foreach e [concat [lindex $v 1] [lindex $v 2]] {
            if {![lindex $E $e]} then {
               lset E $e 1
               lappend queue [list edge $e]
            }
         }
      } "edge" {
         foreach {v i} [lindex $NW 1 [lindex $queue $qp 1]] {
            if {![lindex $V $v]} then {
               lset V $v 1
               lappend queue [list vertex $v]
            }
         }
      }
   }
   list [lsearch -exact -all $V 1] [lsearch -exact -all $E 1]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{graded_components}
%   This procedure breaks a network down into components and each 
%   component down into levels, but the elements within a level are 
%   not ordered. The return value is thus a list of components, where 
%   a component is a list (indexed by level number) of levels, and a 
%   level is a list of elements of the forms
%   \begin{quote}
%     |vertex| \word{vertex-label}\\
%     |edge| \word{edge-label}
%   \end{quote}
%   |edge| elements occur for edges between two nonadjacent levels, 
%   and the same |edge| element may occur in several levels. 
%   The first component always contains the input and output 
%   vertices, but the order of other components is unspecified.
%   
%   The call syntax is
%   \begin{quote}
%     |graded_components| \word{network} \word{level-list}\regopt
%     \ \word{component-list}\regopt
%   \end{quote}
%   where \word{network} is the network to break down into levels. 
%   The \word{level-list} is a list indexed by vertex label 
%   specifying the levels (nonnegative integers) for the vertices. If 
%   this is not specified, then the procedure will call 
%   |vertex_levels3| to compute it. The \word{component-list} is the 
%   list of components to grade, where a component is a network piece 
%   including both edges and vertices. If this is not specified, then 
%   the procedure will call |components| to compute it.
%   
%   The algorithm idea is: first put the vertices in the proper 
%   levels, then fill in with edges where necesssary. 
%   \begin{tcl}
proc network::pure::graded_components {NW {levelL ""} {compL ""}} {
   if {![llength $levelL]} then {
      set levelL [vertex_levels3 $NW]
   }
   if {![llength $compL]} then {
      set compL [components $NW]
   }
   set res {}
   foreach C $compL {
      array unset Level
      foreach item $C {
         switch -- [lindex $item 0] "vertex" {
            lappend Level([lindex $levelL [lindex $item 1]]) $item
         } "edge" {
            foreach var {down up}\
              {v i} [lindex $NW 1 [lindex $item 1]] {
               set $var [lindex $levelL $v]
            }
            for {set l [expr {$down+1}]} {$l<$up} {incr l} {
               lappend Level($l) $item
            }
            
         }
      }
      set res1 {}
      for {set l 0} {$l <= [lindex $levelL 1]} {incr l} {
         lappend res1 [lappend Level($l)]
      }
      lappend res $res1
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{order_graded_components}
%   This procedure orders the elements of each level in a list of 
%   graded components so that they optimally fit with possible 
%   observations of order from within the network. The call syntax is
%   \begin{quote}
%     |order_graded_components| \begin{regblock}[\regstar]\word{option} 
%     \word{value}\end{regblock} \word{network} \word{component-list}
%   \end{quote}
%   and the return value is the reordered \word{component}. The 
%   \word{component} is a list of pieces, corresponding to levels in 
%   the network, where the first one is closest to the output and the 
%   last closest to the input.
%   
%   The supported \word{option} is
%   \begin{ttdescription}
%     \item[-seqcmd]
%       This option selects the method to use for combining the 
%       observations of a level into an ordering. The value is a 
%       command prefix, to which will be appended two arguments 
%       \word{items} and \word{observations}, and which should then 
%       return a permutation of the \word{items} list. The default 
%       value for this option is |default_observation_order|.
%    \end{ttdescription}
%    
%    The implementation is mostly a matter of combining previous 
%    procedures.
%    \begin{tcl}
proc network::pure::order_graded_components {args} {
   set Opt(-seqcmd) [list default_observation_order]
   array set Opt [lrange $args 0 end-2]
   set NW [lindex $args end-1]
   set compL [lindex $args end]
   set res {}
   foreach comp $compL {
      set L {}
      foreach level $comp obsL [
         level_observations $NW $comp {} {} {}
      ] {
         lappend L [eval [linsert $Opt(-seqcmd) end $level $obsL]]
      }
      lappend res $L
   }
   return $res
}
%    \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{Whole component sequencing}
% \label{Ssec:UtvidgaPartialording}
% 
% In order to overcome the complexity problems that the sequencing 
% from observations suffers from, a whole-component algorithm is in 
% order. The basic idea for this algorithm is that information about 
% what is to the left or right of something else is propagated from 
% each level to the levels above and below, where it is used to 
% extend the current partial order on that level. Observations are 
% inherently local, and it is only when combined with an established 
% order within a level that it extends over a distance.
% 
% The basic data structure for a level is the established partial 
% order on its elements. This starts out as the equality relation and 
% is never reduced, only extended, while being kept transitive-closed 
% and antisymmetric. The first (perhaps overly simplistic) 
% implementation of this idea maintains antisymmetry simply by adding 
% relations (pairs) one by one and rejecting those that are not 
% consistent with the partial order obtained after adding the 
% previous one\Dash this means cycle cutting becomes a bit arbitrary, 
% but probably not disturbingly so.
% 
% \begin{proc}{extend_partial_order}
%   This procedure is a helper that updates a partial order to the 
%   transitive closure of the union of a partial order and an extra 
%   pair. Its call syntax is
%   \begin{quote}
%     |extend_partial_order| \word{name} \word{left} \word{right}
%   \end{quote}
%   and it returns the list of those pairs which were added to the 
%   partial order. This includes the pair 
%   $(\mathit{left},\mathit{right})$\Dash except in the case that 
%   the partial order already had \(\mathit{left} \leqslant 
%   \mathit{right}\) in which case an empty list is returned, but in 
%   those cases it is more efficient to not call this procedure.
%   
%   The data structures for a partial order consists of three arrays 
%   in the calling context: \meta{name}, \meta{name}|L|, and 
%   \meta{name}|R|. \meta{name} is the partial order itself, as a 
%   set of pairs (the indices are pairs, whereas the entries are 
%   ignored and set to the empty string). \meta{name}|L| and 
%   \meta{name}|R| are indexed by individual elements and the 
%   entries contain the lists of all those elements which are 
%   $\leqslant$ and $\geqslant$ respectively the index element. Each 
%   of the three arrays contains enough information to create the 
%   other two, but having the information in many different forms 
%   improves the asymptotic complexity.
%   \begin{tcl}
proc network::pure:::extend_partial_order {name l r} {
   upvar 1 $name P ${name}L Left ${name}R Right
   set res {}
   foreach ll $Left($l) {
      foreach rr $Right($r) {
         set pair [list $ll $rr]
         if {![info exists P($pair)]} then {
            set P($pair) ""
            lappend Left($rr) $ll
            lappend Right($ll) $rr
            lappend res $pair
         }
      }
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{cosequence_levels}
%   This procedure produces a simultaneous sequencing of a number of 
%   levels. The call syntax is
%   \begin{displaysyntax}
%     |cosequence_levels| \word{pre-hints} \word{levels}
%     \word{post-hints}
%   \end{displaysyntax}
%   where the \word{levels} is a list of levels (the first element is 
%   for the lowest level), and each level a list of 
%   item-specifications. An item-specification is a list with the 
%   structure
%   \begin{quote}
%     \word{item name} \word{down-neighbours} \word{up-neighbours}
%   \end{quote}
%   where \word{item name} is the name of this particular item (must 
%   be unique within the \word{level-list}), whereas the 
%   \word{down-neighbours} and \word{up-neighbours} are lists of 
%   names of its neighbours (listed from left to right) in the levels 
%   below and above respectively the current level. It is assumed 
%   that items only have neighbours in neighbouring levels.
%   
%   The return value is a list of levels (in the same order as the 
%   \word{level list}), where each level is the list of items in that 
%   level, in sequence from left to right. The \word{pre-hints} and 
%   \word{post-hints} are lists of pairs of elements, interpreted as 
%   pairs of elements to try to incorporate into the partial order. 
%   The \word{pre-hints} pairs (if there are any) are processed 
%   before pairs deduced from \word{down-neighbours} and 
%   \word{up-neighbours} lists, whereas the \word{post-hints} pairs 
%   are taken into consideration after the first wave of propagations 
%   has died out. The \word{pre-hints} and \word{post-hints} may only 
%   contain pairs where both items are in the same level.
%   
%   \begin{tcl}
proc network::pure::cosequence_levels {prehintL level_list posthintL} {
   set queue $prehintL
   set lvl -1; foreach level $level_list {incr lvl
      foreach itemspec $level {
         foreach {item downL upL} $itemspec break
         set PL($item) [list $item]
         set PR($item) [list $item]
         set P([list $item $item]) ""
         set Down($item) $downL
         set Up($item) $upL
         set n -1; foreach r $downL {incr n
            for {set k 0} {$k<$n} {incr k} {
               lappend queue [list [lindex $downL $k] $r]
            }
         }
         set n -1; foreach r $upL {incr n
            for {set k 0} {$k<$n} {incr k} {
               lappend queue [list [lindex $upL $k] $r]
            }
         }
         set Levelno($item) $lvl
      }
      set Res($lvl) {}
   }
   while 1 {
%   \end{tcl}
%   At this point, it might be an idea to reshuffle the |queue| to 
%   give the higher levels equal chance at specifying the order, but 
%   there's no need to do so unless this bias turns out to be noticable 
%   in the graphical representation.
%   \begin{tcl}
      set newL {}
      foreach pair $queue {
         foreach {l r} $pair break
         if {[info exists P($pair)] || [info exists P([list $r $l])]}\
         then {continue}
         foreach ll $PL($l) {
            foreach rr $PR($r) {
               set pair [list $ll $rr]
               if {![info exists P($pair)]} then {
                  set P($pair) ""
                  lappend PL($rr) $ll
                  lappend PR($ll) $rr
                  lappend newL $pair
               }
            }
         }
      }
      set queue {}
      foreach pair $newL {
         foreach {l r} $pair break
         foreach ll $Up($l) {
            foreach rr $Up($r) {
               lappend queue [list $ll $rr]
            }
         }
         foreach ll $Down($l) {
            foreach rr $Down($r) {
               lappend queue [list $ll $rr]
            }
         }
      }
      if {[llength $queue]} then {continue}
      if {[llength $posthintL]} then {
         set queue $posthintL
         set posthintL {}
         continue
      }
%   \end{tcl}
%   At this point, the wave of propagations has died out; there is no 
%   more information at hand. If the partial order is not total within 
%   each level, this means it is now necessary to make some kind of 
%   choice on how to extend the order. The way this is done is that 
%   the procedure starts appending minimum elements to the relevant 
%   entries in the |Res| array and at the same time removes them from 
%   the |Levelno| array. When an item is encountered which is not 
%   minimum in its level, the pairs missing to make it minimum are 
%   appended to the |queue| and another wave of propagations is 
%   allowed to carry the implications of this choice to all parts of 
%   the component.
%   
%   The arbitrary part of this algorithm is the manner in which 
%   items are ``encountered'' and checked for being minimum in their 
%   level. Each item is assigned a deficiency (for being 
%   minimal)\Ldash which is the number of elements that are missing 
%   from its |PR| entry for the item to be minimal among those in 
%   its level which have not yet been added to the |Res| entry for 
%   this level\Dash and the entries in the |Levelno| array are 
%   inspected in order of increasing deficiency. Since adding an item 
%   in a level to the result causes the current deficiency for all 
%   other items in that level to drop, the deficiency needs to be 
%   recomputed before determining whether it is necessary to make a 
%   choice.
%   \begin{tcl}
      set L {}
      foreach item [array names Levelno] {
         lappend L [list $item [expr {
           [llength [lindex $level_list $Levelno($item)]] -\
           [llength $Res($Levelno($item))] - [llength $PR($item)]
         }]]
      }
      foreach pair [lsort -integer -index 1 $L] {
         set item [lindex $pair 0]
         if {
           [llength [lindex $level_list $Levelno($item)]] ==\
           [llength $Res($Levelno($item))] + [llength $PR($item)]
         } then {
            lappend Res($Levelno($item)) $item
            unset Levelno($item)
         } else {
            foreach spec [lindex $level_list $Levelno($item)] {
               set S([lindex $spec 0]) ""
            }
            foreach item2 [concat $Res($Levelno($item)) $PR($item)] {
               unset S($item2)
            }
            foreach item2 [array names S] {
               lappend queue [list $item $item2]
            }
            array unset S
            break
         }
      }
      if {![llength $queue]} then {break}
   }
%   \end{tcl}
%   If we get here, |Levelno| must be empty and |Res| complete. It 
%   only remains to return it in the specified format.
%   \begin{tcl}
   set res {}
   foreach level $level_list {
      lappend res $Res([llength $res])
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% The full-featured version of this would handle contradicting 
% propagations in a less sequential manner, by forming the transitive 
% closure $Q$ of the union of the old partial order $P$ with the 
% |queue| in a single step. This could make $Q$ a quasi-order with 
% nontrivial equivalence, so the algorithm would have to make 
% decisions on how to linearise equivalence classes as well as 
% extending the partial order. The total collection of ``moves'' for 
% sequencing the level would be:
% \begin{description}
%   \item[Transitive closure]
%     As described above.
%   \item[Neighbour propagation]
%     As in the simple variant.
%   \item[Dividing by equivalence]
%     It is reasonable to decide that elements of an equivalence 
%     class should at least be close in the linear order, or somewhat 
%     stronger that the equivalence classes should be intervals in 
%     the linear order. This corresponds to extracting all 
%     \emph{strict} inequalities from $Q$ and adding them back to 
%     $P$.
%   \item[Cycle cutting]
%     Every nontrivial equivalence class must contain a cycle. By 
%     cutting this cycle at its weakest link, one should obtain a 
%     good linearisation of it. How does one go ahead with that? One 
%     possibility is to compute a maximal circulation in the digraph 
%     of suggested inequalities (letting the multiplicity be the edge 
%     capacity) and then cut at an edge which is saturated.
% \end{description}
% The various moves should probably be tried in precisely that order, 
% since they represent increasing amounts of decision-making (and 
% probably also running time).
% 
% 
% \begin{proc}{component_DU_levels}
%   This procedure computes a list of the levels in a network 
%   component, in the down-\slash up-neighbours format required by 
%   |cosequence_levels|. The call syntax is
%   \begin{quote}
%     |component_DU_levels| \word{network} \word{support} 
%     \word{level-list}\regopt
%   \end{quote}
%   where \word{support} is a pair of lists
%   \begin{quote}
%     \word{vertices} \word{edges}
%   \end{quote}
%   giving the labels of all vertices and edges in the component to 
%   format. \word{level-list} is a list indexed by vertex label that 
%   gives the level of that vertex (if given, otherwise 
%   |vertex_levels3| is called to compute it).
%   
%   The return value is the list of levels. Item names have the forms
%   \begin{displaysyntax}
%     vertex \word{label}\par
%     edge \word{label} \word{level no.}
%   \end{displaysyntax}
%   since the occurrence of an edge at one level needs to be 
%   distinguished from its occurrence at another level.
%   \begin{tcl}
proc network::pure::component_DU_levels {NW support {levelL ""}} {
   if {![llength $levelL]} then {
      set levelL [vertex_levels3 $NW]
   }
   foreach v [lindex $support 0] {
      set item [list vertex $v]
      set A($item) [lreplace [lindex $NW 0 $v] 0 0 $item]
   }
   foreach e [lindex $support 1] {
      foreach {u i v j} [lindex $NW 1 $e] break
      set L [list [list vertex $u] $i]
      for {set n [expr {1+[lindex $levelL $u]}]}\
        {$n<[lindex $levelL $v]} {incr n} {
         set item [list edge $e $n]
         lappend L $item 0 $item 0
         set A($item) [list $item x x]
      }
      lappend L [list vertex $v] $j
      foreach {item1 index1 item2 index2} $L {
         lset A($item1) 2 $index1 $item2
         lset A($item2) 1 $index2 $item1
      }
   }
   foreach item [array names A] {
      switch -- [lindex $item 0] "vertex" {
         lappend Res([lindex $levelL [lindex $item 1]]) $A($item)
      } "edge" {
         lappend Res([lindex $item 2]) $A($item)
      }
   }
   set res {}
   for {set l 0} {$l <= [lindex $levelL 1]} {incr l} {
      lappend res [lappend Res($l)]
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ordered_graded_components}
%   This procedure provides the equivalent of combining 
%   |graded_components| and |order_graded_components|, but uses 
%   |cosequence_levels| internally. The call syntax is
%   \begin{displaysyntax}
%     |ordered_graded_components| \begin{regblock}[\regstar]
%       -levellist \word{list} \regalt
%       -orderchunk \begin{regblock} component \regalt level 
%         \end{regblock} \regalt
%       -prehints \word{item-pair-list} \regalt
%       -posthints \word{item-pair-list}
%     \end{regblock} \word{network}
%   \end{displaysyntax}
%   and the return value is the standard list of (components $=$) 
%   list of (levels $=$) network pieces.
%   
%   The \word{list} of the |-levellist| option is the standard list 
%   indexed by vertex label of the levels for the vertices. If this 
%   is not given, then |vertex_levels4| is called to compute it.
%   \changes{2.2}{2009/02/06}{Switching from 
%     \texttt{vertex\_levels3} to \texttt{vertex\_levels4} for 
%     computing default \texttt{-levellist}. This is slightly slower 
%     (maybe half as fast in common cases) but produces superior 
%     results in a fair number of cases. (LH)}
%   \changes{2.8}{2013/02/04}{Exposing prehints and posthints 
%     features of \texttt{cosequence\_levels}. (LH)}
%   \begin{tcl}
proc network::pure::ordered_graded_components {args} {
   set NW [lindex $args end]
   array set Opt {
      -orderchunk component
      -prehints   {}
      -posthints  {}
   }
   array set Opt [lrange $args 0 end-1]
   if {![info exists Opt(-levellist)]} then {
      set Opt(-levellist) [vertex_levels4 $NW]
   }
   switch -- $Opt(-orderchunk) "component" {
%   \end{tcl}
%   The first part of the procedure constructs a list of components, 
%   in the format needed by |component_DU_levels|.
%   \begin{tcl}
      set n -1; foreach v [lindex $NW 0] {incr n
         set S($n) ""
      }
      set compL [list [component $NW {0 1} {}]]
      foreach n [lindex $compL 0 0] {unset S($n)}
      while {[array size S]} {
         lappend compL [component $NW [lrange [array names S] 0 0] {}]
         foreach n [lindex $compL end 0] {unset S($n)}
      }
%   \end{tcl}
%   Then the result is constructed.
%   \begin{tcl}
      set res {}
      foreach comp $compL {
         set res2 {}
         foreach level [
            cosequence_levels $Opt(-prehints) [
               component_DU_levels $NW $comp $Opt(-levellist)
            ] $Opt(-posthints)
         ] {
            set res3 {}
            foreach item $level {lappend res3 [lrange $item 0 1]}
            lappend res2 $res3
         }
         lappend res $res2
      }
      return $res
   } "level" {
      return [order_graded_components $NW\
        [graded_components $NW $Opt(-levellist)]]
   } default {
      error "Unknown chunktype '$Opt(-orderchunk)'"
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \iffalse
% 
% \subsection{Continuous component sequencing}
% 
% This is a rather wild idea, which has one origin in the problem of 
% finding a \emph{layout} (see Subsection~\ref{Ssec:Layout}) for a 
% network. A layout assigns an $y$-coordinate to each level and an 
% $x$-coordinate to each item within a level. If the widths of 
% individual items are fixed, a sequencing of these items within a 
% level is given, and the items are packed tightly, then the 
% relative positions within a level are uniquely determined, but the 
% absolute positions are not since nothing constrains the horizontal 
% position of the slug that the level items have been fused into. 
% Obviously some principle for positioning levels relative to each 
% other is needed.
% 
% An obvious starting point for such a principle would be to look at 
% the edges\Ldash or rather edge segments, as an edge need not go 
% between two adjacent levels\Rdash between two levels, and a natural 
% quantity to minimise is their combined lengths. When several 
% lengths are to be combined in this kind of stuation, one usually 
% does so by taking the sum of the \emph{squares} of the lengths, as 
% that makes the algebra a lot simpler. In this situation, it for 
% example means that only the $x$-direction distances matter, as the 
% $y$-direction distances are constant. It also has the nice property 
% that the tension is distributed among the edges, since \(a^2 + 0^2 
% > (\frac{a}{2})^2 + (\frac{a}{2})^2\). From an algebraic 
% perspective, one really only does a least squares fitting and can 
% therefore compute the result in one go by making a suitable 
% projection!
% 
% Using this quantity as the one to optimise may not work too well 
% together with the sequencing algorithm of 
% Subsection~\ref{Ssec:UtvidgaPartialording} however, as that has a 
% tendency to sometimes make large jumps\Dash typically in the middle 
% of an edge between two very distant levels. Thus one may see 
% layouts like
% \[
%   \begin{matrix}
%     a& b& c& d\\
%     b& c& d& a\\
%     b& c& d& a\\
%     b& c& d& a
%   \end{matrix}
%   \quad\text{rather than}\quad
%   \begin{matrix}
%     a& b& c& d\\
%     b& a& c& d\\
%     b& c& a& d\\
%     b& c& d& a
%   \end{matrix}
% \]
% which humanly seems more natural; the former will have a long 
% $a$--$a$ edge between the first two levels, and minimising the 
% square-sum rather than e.g. the sum will in this case probably be 
% for the worse. In order to let a square-sum objective show its full 
% potential, it should really be allowed to influence the sequencing 
% of levels as well as the positioning of level slugs! But the 
% sequencing of levels is a very different beast to tame, as the 
% space over which one optimises is discrete rather than continuous.
% 
% A trivial approach to optmising the sequencing would be to consider 
% the graph with all possible sequencings as vertices, where there are 
% edges between two sequencings that differ only by a transposition 
% of two objects; starting at some vertex in this graph, one would look 
% at all neighbours, move to the one with smallest value of the 
% objective function, and repeat until a minimum is found. 
% 
% \fi
% 
% 
% 
% \subsection{Deconstruction}
% 
% Deconstruction of a network is the opposite of construction, i.e., 
% the conversion of a network to some text which might be used to 
% describe it.
% 
% \begin{proc}{lists_to_permutation}
%   This procedure takes two lists, which are assumed to contain the 
%   exact same distinct elements, and computes the permutation which 
%   converts one into the other. The call syntax is
%   \begin{quote}
%     |lists_to_permutation| \word{list B} \word{list A}
%   \end{quote}
%   and the defining property is that the \word{result} is such that 
%   the two commands
%   \begin{quote}
%     |lindex |\word{list B}|[lindex |\word{result}| |\word{index}|]|
%     \\
%     |lindex |\word{list A}| |\word{index}
%   \end{quote}
%   returns the same value for both inputs.
%   
%   In the case of a permutation network, the command
%   \begin{quote}
%     \raggedright
%     |lists_to_permutation [lindex |\word{network}| 0 0 2]\
%     [lindex |\word{network}| 0 1 1]|
%   \end{quote}
%   recovers the underlying permutation.
%   
%   \begin{tcl}
proc network::pure::lists_to_permutation {BL AL} {
   set n -1; foreach x $BL {incr n
      set B($x) $n
   }
   set res {}
   foreach x $AL {lappend res $B($x)}
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{deconstruct_permutation}
%   This procedure expresses a permutation as a combination of |.|s 
%   and \meta{k}|X|\meta{l}s. The call syntax is
%   \begin{quote}
%     |deconstruct_permutation| \word{permutation}
%   \end{quote}
%   and the return value is a list of lists; the network constructed 
%   from the |join| by \verb*" \r " of this result is the network 
%   corresponding to the \word{permutation}.
%   
%   The algorithm decomposes the \word{permutation} from the input 
%   side, for each element of the result recomputing what remains of 
%   the \word{permutation}. A $\cross{k}{l}$ item is begun when an 
%   element is encountered that the current permutation maps to 
%   something larger, and this element will then be the first element 
%   in the $k$ leg of that cross. New elements are appended to the 
%   $k$ leg as long as they should be mapped to something greater 
%   than the first one, then the $l$ leg consists of the following 
%   sequence of elements mapped to something less than the first 
%   element in the $k$ leg. The algorithm terminates because each 
%   decomposition step reduces the number of inversions in the 
%   permutation, by $kl$ for each \meta{$k$}\texttt{X}\meta{$l$} 
%   output.
%   
%   The |line| variable collects an element for the output, whereas 
%   the |new| variable collects the remaining part of the 
%   permutation. |K| is the list of elements currently in the $k$ leg 
%   of a cross and |l| is the number of elements currently in 
%   the $l$ leg.
%   \begin{tcl}
proc network::pure::deconstruct_permutation {target} {
   set res {}
   for {} {[
      set line {}
      set new {}
      set K {}
      set l 0
      set x -1; foreach y $target {incr x
         if {![llength $K]} then {
            if {$y <= $x} then {
               lappend line .
               lappend new $y
            } else {
               lappend K $y
            }
         } elseif {!$l} then {
%   \end{tcl}
%   The |>=| below is a slight safeguard against faulty input: if 
%   the \word{permutation} contains repeated elements then the loop 
%   will not forever try to switch places between them, but instead 
%   leave them as they are. That situation still produces garbage 
%   out, but then there was also garbage in.
%   \begin{tcl}
            if {$y >= [lindex $K 0]} then {
               lappend K $y
            } else {
               lappend new $y
               incr l
            }
         } else {
            if {$y < [lindex $K 0]} then {
               lappend new $y
               incr l
            } else {
               eval [list lappend new] $K
               if {[llength $K] == 1 && $l == 1} then {
                  lappend line X
               } else {
                  lappend line [llength $K]X$l
               }
               set K {}
               set l 0
               if {$y <= $x} then {
                  lappend line .
                  lappend new $y
               } else {
                  lappend K $y
               }
            }
         }
      }
      if {[llength $K]} then {
         eval [list lappend new] $K
         if {[llength $K] == 1 && $l == 1} then {
            lappend line X
         } else {
            lappend line [llength $K]X$l
         }
      }
      string first X $line
   ] >= 0} {set target $new} {lappend res $line}
   return $res
}
%   \end{tcl}
%   The algorithm is decidedly not optimal\Ldash it outputs a linear 
%   number of steps for e.g.~a perfect shuffle permutation, when a 
%   logarithmic number of steps would suffice\Dash but it is good 
%   enough. It may also be observed that it \emph{is} optimal for 
%   those permutations which are juxtapositions of crosses and 
%   identities.
% \end{proc}
% 
% \begin{proc}{piece_boundary}
%   This procedure returns one boundary of a piece of a network, as 
%   the list of edges (as edge labels) in that boundary. The call 
%   syntax is
%   \begin{quote}
%     |piece_boundary| \word{network} \word{piece} \word{side}
%   \end{quote}
%   where the \word{side} is either |1| for the input side or |0| for 
%   the output side. The boundary ordering follows that in the 
%   \word{piece} (which is sort of the point of this procedure).
%   \begin{tcl}
proc network::pure::piece_boundary {NW piece side} {
   incr side
   set res {}
   foreach item $piece {
      switch -- [lindex $item 0] "edge" {
         lappend res [lindex $item 1]
      } "vertex" {
         eval [list lappend res]\
           [lindex $NW 0 [lindex $item 1] $side]
      }
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{deconstruct_graded}
%   This procedure converts a graded network to lists like those in 
%   the second argument of |network::pure::construct|. The call 
%   syntax is
%   \begin{quote}
%     |deconstruct_graded| \word{network} \word{levels-list}
%   \end{quote}
%   and the return value is the list of lists, which if |join|ed by 
%   \verb*" \r " will constitute suitable input to |construct| for 
%   reconstructing the \word{network} (or at least the component of 
%   it that is mentioned in the \word{levels-list}). It is assumed 
%   that the first element of the \word{levels-list} is for the 
%   output level and the last element is for the input level; either 
%   or both may be empty, but they must be present.
%   
%   Some elements of the result correspond directly to elements of 
%   the \word{levels-list} (although in the opposite order), whereas 
%   others are needed to express how intermediate edges connect 
%   different levels. The result is probably shorter if the 
%   \word{levels-list} is an ordered graded component, but any 
%   grading of the \word{network} will work.
%   
%   
%   \begin{tcl}
proc network::pure::deconstruct_graded {NW levelsL} {
   set res {}
   set l [expr {[llength $levelsL]-1}]
   while 1 {
      eval [list lappend res] [
         deconstruct_permutation [lists_to_permutation [
            piece_boundary $NW [lindex $levelsL [expr {$l-1}]] 1
         ] [
            piece_boundary $NW [lindex $levelsL $l] 0
         ]]
      ]
      incr l -1
      if {$l<=0} then {break}
      set line {}
      foreach item [lindex $levelsL $l] {
         switch -- [lindex $item 0] "edge" {
            lappend line .
         } "vertex" {
            lappend line [lindex $NW 0 [lindex $item 1] 0]
         }
      }
      if {[llength $line]} then {lappend res $line}
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{autodeconstruct}
%   This procedure is a conveniency utility for presenting a network 
%   in a pure text context. The call syntax is
%   \begin{quote}
%     |autodeconstruct| \word{network}
%   \end{quote}
%   and the return value is a string (parseable as a list, but 
%   typically not on canonical form) which expresses the network 
%   structure in the style of the second argument of 
%   |network::pure::construct|.
%   
%   For the formatting, |ordered_graded_components| is used. Each 
%   component is deconstructed by |deconstruct_graded| and then the 
%   results are padded with spaces and so on to nicely line up.
%   If it turns out that more control is wanted over the formatting, 
%   this procedure could be extended with option and value arguments 
%   after the \word{network}.
%   
%   \begin{tcl}
proc network::pure::autodeconstruct {NW} {
   set compL [ordered_graded_components $NW]
   set colL {}
   set widthL {}
   set maxheight 0
   foreach comp $compL {
      lappend colL [deconstruct_graded $NW $comp]
      set width 0
      foreach line [lindex $colL end] {
         if {[string length $line] > $width} then {
            set width [string length $line]
         }
      }
      lappend widthL $width
      if {[llength [lindex $colL end]] > $maxheight} then {
         set maxheight [llength [lindex $colL end]]
      }
   }
   set res {}
   for {set n 0} {$n < $maxheight} {incr n} {
      set pos 0
      set line ""
      foreach col $colL width $widthL {
         if {2*$n < $maxheight - [llength $col] ||\
           2*$n >= $maxheight + [llength $col] } then {
            incr pos [expr {$width + 2}]
         } else {
            set line [format {%-*s%-*s  } $pos $line $width [
               lindex $col [expr {$n - $maxheight + [llength $col]}]
            ]]
            set pos [string length $line]
         }
      }
      lappend res $line
   }
   return [join $res "\\r\n"]
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% 
% \section{Networks with feedback}
% 
% The relevant context for substitutions is not networks as such, but 
% networks together with a list of \emph{feedback opportunities}. A 
% \emph{pure network with feedback} is thus a pair
% \begin{quote}
%   \word{network} \word{feedback-list}
% \end{quote}
% where \word{network} is a pure network and \word{feedback-list} is a 
% list of pairs
% \begin{quote}
%   \word{output-index} \word{input-index}
% \end{quote}
% where each pair $(i,j)$ means output $i$ of \word{network} may be fed 
% back into input $j$ of the network. This list of pairs is the 
% complement of the input--output order relation, since it is expected 
% that it will usually be much smaller.
% 
% Procedures operating on networks with feedback are kept in the 
% |network::wfb| namespace.
% \begin{tcl}
namespace eval network::wfb {}
% \end{tcl}
% \setnamespace{network::wfb}
% 
% 
% \begin{proc}{full}
%   The |full| procedure discards the \word{feedback-list} part of a 
%   network with feedback and replaces it with the list of all possible 
%   feedbacks. The call syntax is
%   \begin{quote}
%     |network::wfb::full| \word{network}
%   \end{quote}
%   and the return value is full variant of the same network.
%   
%   The idea of this procedure is to compute the partial order on the 
%   edges of the network, and then list those inputs and outputs which 
%   are not related by this order.
%   \begin{tcl}
proc network::wfb::full {NW} {
   set n -1; foreach e [lindex $NW 0 1] {incr n
      set P($n,$n) ""
   }
   foreach v [lindex $NW 0 0] {
      set aboveL {}
      foreach e [lindex $v 2] {
         foreach pair [array names P $e,*] {
            lappend aboveL [lindex [split $pair ","] 1]
         }
      }
      set belowL {}
      foreach e [lindex $v 1] {
         foreach pair [array names P *,$e] {
            lappend belowL [lindex [split $pair ","] 0]
         }
      }
      set belowL [lsort -integer -unique $belowL]
      foreach i [lsort -integer -unique $aboveL] {
         foreach j $belowL {
            set P($j,$i) ""
         }
      }
   }
   set L {}
   set i -1; foreach ei [lindex $NW 0 0 0 2] {incr i
      set j -1; foreach ej [lindex $NW 0 0 1 1] {incr j
         if {![info exists P($ei,$ej)]} then {
            lappend L [list $i $j]
         }
      }
   }
   return [list [lindex $NW 0] $L]
}
%   \end{tcl}
% \end{proc}
% 
% 
% It is sometimes useful to compute the effects on feedbacks of 
% various operations without having to compute the effect also on 
% some network. For that purpose, there is also a datatype 
% \emph{feedback-sort}, which is a list
% \begin{quote}
%   \word{coarity} \word{arity} \word{feedback-list}
% \end{quote}
% where \word{coarity} and \word{arity} are integers. It should be 
% observed that this sort is sufficient information about the 
% operands of many operations if one wants to determine the sort of 
% the result.
% 
% Procedures operating on feedback-sorts are kept in the 
% |network::fbs| namespace.
% \begin{tcl}
namespace eval network::fbs {}
% \end{tcl}
% 
% \begin{proc}{to_fbs}
%   The |to_fbs| procedure computes the feedback-sort of a network 
%   with feedback. It has the call syntax
%   \begin{quote}
%     |network::wfb::to_fbs| \word{network}
%   \end{quote}
%   and the return value is the feedback-sort.
%   \begin{tcl}
proc network::wfb::to_fbs {NW} {
   list [llength [lindex $NW 0 0 0 2]] [llength [lindex $NW 0 0 1 1]]\
     [lindex $NW 1]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{map_to_fbs}
%   The |map_to_fbs| procedure has the call syntax
%   \begin{quote}
%     |network::wfb::map_to_fbs| \word{prefix} \word{network-list}
%   \end{quote}
%   It behaves mostly as
%   \begin{quote}
%     |namespace eval network::fbs| \word{prefix} \word{network-list}
%   \end{quote}
%   \emph{except} that it converts all elements in the 
%   \word{network-list} to feedback-sorts before making the call. The 
%   idea for this is that the \word{prefix} should be looked up in the 
%   |network::fbs| namespace, so that a feedback-sort operation is 
%   applied to its arguments. This way, code in the |network::wfb| 
%   namespace can call upon an operation from the |network::fbs| 
%   namespace without having to bother about giving its full name.
%   \begin{tcl}
proc network::wfb::map_to_fbs {prefix nwL} {
   foreach nw $nwL {lappend prefix [to_fbs $nw]}
   namespace eval [namespace parent]::fbs $prefix
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{\PROP py operations}
% 
% 
% \begin{proc}{composition}
%   This procedure computes the composition of a list of networks 
%   with feedback, i.e., it places them all in sequence (with the 
%   first on the output side). The syntax is
%   \begin{quote}
%     |network::wfb::composition| \word{network}\regplus
%   \end{quote}
%   and the return value is the resulting network. It is typically 
%   not on canonical form. It is an error if the number of outputs in 
%   one network does not match the number of inputs in the following.
%   
%   The implementation first composes the pure networks, then their 
%   feedback-sorts.
%   \begin{tcl}
proc network::wfb::composition {args} {
   list [
      eval [linsert $args 0 [namespace parent]::pure::composition]
   ] [
      lindex [map_to_fbs composition $args] 2
   ]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}[network::fbs]{composition}
%   This procedure computes the composition of a list of 
%   feedback-sorts for networks, i.e., it places them all in sequence 
%   (with the first on the output side). The syntax is
%   \begin{quote}
%     |network::fbs::composition| \word{feedback-sort}\regplus
%   \end{quote}
%   and the return value is the result feedback-sort.
%   
%   Composing anti-feedbacks is essentially boolean matrix 
%   multiplication\Ldash there's an anti-feedback from input $i$ to 
%   output $k$ in $a \circ b$ if there is some $j$ such that $a$ has 
%   an anti-feedback from $i$ to $j$ and $b$ has an anti-feedback 
%   from $j$ to $k$\Dash so one shouldn't expect that this can done 
%   in subcubic time.\footnote{Unless one starts to play some very 
%   nasty tricks, like Strassen matrix multiplication or striped 
%   matrix multiplication\Dash which would be utterly wasted in this 
%   case.} Under the assumption that the complementary feedbacks are 
%   few, it may however be possible to achieve better average results.
%   
%   Expressed in feedbacks, the composition rule is that there is a 
%   feedback from output $k$ to input $i$ in a composition iff every 
%   point of join $j$ is covered by a feedback from $j$ to $i$ or a 
%   feedback from $k$ to $j$. Hence a natural data structure is that 
%   one for every output $k$ of the left operand and every input $i$ 
%   of the right operand has a list of join indices $j$ which are 
%   covered by feedbacks from $k$, and to $i$, respectively. When 
%   deciding whether to put a feedback from $k$ to $i$, it is then 
%   sufficient to check the two corresponding lists to see if these 
%   cover every join index. The innermost loop can then be put into 
%   a |lsort -unique|.
%   
%   For left operands (partial compositions), the |FBL| variable is a 
%   list indexed by output index $k$, and the elements are those $j$ 
%   values for which there are $k$-to-$j$ feedbacks. The |FBR| 
%   variable is a similar list, which is indexed by input index $i$ 
%   and where the elements are lists of those $j$ values for which 
%   there are $j$-to-$i$ feedbacks.
%   
%   \begin{tcl}
proc network::fbs::composition {left args} {
   foreach pair [lindex $left 2] {
      lappend A([lindex $pair 0]) [lindex $pair 1]
   }
   for {set FBL {}} {[llength $FBL] < [lindex $left 0]} {} {
      lappend FBL [lappend A([llength $FBL])]
   }
%   \end{tcl}
%   The following is to handle the case of just one argument.
%   \begin{tcl}
   set right $left
   foreach right $args {
      array unset A
      foreach pair [lindex $right 2] {
         lappend A([lindex $pair 1]) [lindex $pair 0]
      }
      for {set FBR {}} {[llength $FBR] < [lindex $right 1]} {} {
         lappend FBR [lappend A([llength $FBR])]
      }
      set FBL2 {}
      foreach Ll $FBL {
         set L {}
         set i -1; foreach Lr $FBR {incr i
            if {[
               llength [lsort -unique -integer [concat $Ll $Lr]]
            ] >= [lindex $right 0]} then {lappend L $i}
         }
         lappend FBL2 $L
      }
      set FBL $FBL2
   }
   set L {}
   set k -1; foreach Ll $FBL {incr k
      foreach i $Ll {lappend L [list $k $i]}
   }
   return [list [lindex $left 0] [lindex $right 1] $L]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{left_action}
%   This procedure implements the left action of a permutation on a 
%   network, i.e., a permutation of the outputs. The call syntax is
%   \begin{quote}
%     |network::wfb::left_action| \word{permutation} \word{network}
%   \end{quote}
%   and the return value is the result network. The effect is 
%   equivalent to composing the permutation as a network with the 
%   given network, but this is much more efficient.
%   
%   \begin{tcl}
proc network::wfb::left_action {sigma NW} {
   set outL $sigma
   foreach i $sigma e [lindex $NW 0 0 0 2] {
      lset NW 0 1 $e 1 $i
      lset outL $i $e
   }
   lset NW 0 0 0 2 $outL
   set fbL {}
   foreach fb [lindex $NW 1] {
      lappend fbL [list [lindex $sigma [lindex $fb 0]] [lindex $fb 1]]
   }
   lset NW 1 $fbL
   return $NW
}
%   \end{tcl}
% \end{proc} 
% 
% \begin{proc}{right_action}
%   This procedure implements the right action of a permutation on a 
%   network, i.e., a permutation of the inputs. The call syntax is
%   \begin{quote}
%     |network::wfb::right_action| \word{network} \word{permutation}
%   \end{quote}
%   and the return value is the result network. The effect is 
%   equivalent to composing the given network with the permutation as 
%   a network, but this is much more efficient.
%   
%   \begin{tcl}
proc network::wfb::right_action {NW sigma} {
   set inL {}
   set invsigma $sigma
   foreach i $sigma {
      set e [lindex $NW 0 0 1 1 $i]
      lset NW 0 1 $e 3 [llength $inL]
      lset invsigma $i [llength $inL]
      lappend inL $e
   }
   lset NW 0 0 1 1 $inL
   set fbL {}
   foreach fb [lindex $NW 1] {
      lappend fbL [list [lindex $fb 0]\
        [lindex $invsigma [lindex $fb 1]]]
   }
   lset NW 1 $fbL
   return $NW
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Listing isomorphic subnetworks}
% 
% 
% \begin{proc}{instances}
%   The |instances| procedure determines the instances in which the 
%   network $H$ occurs within the network $G$. The call syntax is
%   \begin{quote}
%     |network::wfb::instances| \word{network $G$} \word{network $H$} 
%     \word{limit}\regopt
%   \end{quote}
%   where the \word{limit} (an non-negative integer) is the maximal 
%   number of instances returned. The return value is a list of those 
%   regions (as defined in Subsection~\ref{Ssec:Regionkirurgi}) which 
%   constitute instances of $H$ (i.e., which would |uncover| a 
%   subnetwork isomorphic to $H$).
%   
%   Note that this operation is applied to networks \emph{with 
%   feedback}; an instance is not accepted if it would require more 
%   feedback opportunities than $H$ provides.
%   
%   
%   In the implementation, the most important data structure is the 
%   \emph{correspondence} 
%   \begin{quote}
%     \word{$f_0$} \word{$f_1$} \word{$f_2$} \word{$f_3$}
%   \end{quote}
%   which is a list whose elements are four maps 
%   \(f_0\colon \GV(H) \Fpil \GV(G) \cup\{-1\}\), \(f_1\colon \GV(G) 
%   \Fpil \GV(H) \cup\{-1\}\), \(f_2\colon \GE(H) \Fpil \GE(G) 
%   \cup\{-1\}\), and \(f_3\colon \GE(G) \Fpil {}\)segmentations; 
%   these maps are encoded as lists indexed by the argument. $f_0$ maps 
%   vertices in $H$ to the corresponding vertices of $G$, and $f_1$ 
%   does it the other way around; unassigned vertices are mapped to 
%   $-1$. $f_2$ maps edges in $H$ to the corresponding edges of $G$, 
%   and $f_3$ specifies the composition with respect to $H$ of an edge 
%   in $G$. A segmentation is a list
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{type} 
%     \word{$H$-edge}\end{regblock}
%   \end{quote}
%   where \word{type} is one of
%   \begin{longtable}{lp{0.7\textwidth}}
%     \texttt{head}& Head part of edge (input leg)\\
%     \texttt{mid}& Middle part of edge (stray edge)\\
%     \texttt{tail}& Tail part of edge (output leg)\\
%     \texttt{all}& Whole edge (internal edge)
%   \end{longtable}
%   
%   \begin{proc}{instances,region}
%     This procedure converts a \word{correspondence} to a 
%     \word{region}. The call syntax is
%     \begin{quote}
%       |instances,region| \word{$H$-network} \word{correspondence}
%     \end{quote}
%     where the \word{$H$-network} is pure.
%     \begin{tcl}
proc network::wfb::instances,region {NW corr} {
   set res [list [lrange [lindex $corr 0] 2 end]]
   foreach legL [list [lindex $NW 0 0 2] [lindex $NW 0 1 1]] {
      set L {}
      foreach leg $legL {
         set eg [lindex $corr 2 $leg]
         foreach {type eh} [lindex $corr 3 $eg] {
            if {$eh == $leg} then {break}
            incr eg [llength [lindex $corr 3]]
         }
         lappend L $eg
      }
      lappend res $L
   }
   return $res
}
%     \end{tcl}
%   \end{proc}
%   
%   
%   \begin{proc}{instances,expand}
%     The |instances,expand| procedure expands a correspondence with 
%     everything that can be deduced from an assignment of one 
%     additional vertex. The call syntax is
%     \begin{quote}
%       |instances,expand| \word{correspondence} 
%       \word{network $G$ (pure)} \word{network $H$ (pure)} 
%       \word{$G$-vertex} \word{$H$-vertex}
%     \end{quote}
%     and the return value is the extended correspondence, or an 
%     empty list if the mapping couldn't be extended as specified. 
%     \word{network $G$} and \word{network $H$} are pure networks, 
%     \word{$G$-vertex} and \word{$H$-vertex} are vertex labels.
%     
%     The implementation employs a straightforward |queue| of 
%     elements on one of the three forms
%     \begin{quote}
%       |vertex| \word{$G$-vertex} \word{$H$-vertex}\\
%       |edgefw| \word{$G$-edge} \word{$H$-edge}\\
%       |edgebw| \word{$G$-edge} \word{$H$-edge}
%     \end{quote}
%     |vertex| items are vertex assignments, just as the one in the 
%     argument. The other two forms are edge assignments. The 
%     processing of a queue element must first check whether the 
%     assignment has already been made (and if so go on to the next 
%     queue element), second check that the correspondence is possible, 
%     and third propage the correspondence by adding queue elements 
%     for assignments of neighbouring edges or vertices. 
%     
%     Propagations along an edge only go to the vertex at the other 
%     end of that edge, but a |vertex| generate assignments for all 
%     edges it is incident with. Most of the time this means at least 
%     one edge already assigned is getting a new assignment, but it 
%     is less work to generate and process this queue element that it 
%     would be to avoid it. Generating a queue element also means it 
%     is checked that the head\slash tail index of the edges match, 
%     which means edge propagation need not explicitly check this. 
%     \begin{tcl}
proc network::wfb::instances,expand {corr NWG NWH vG vH} {
   set queue [list [list vertex $vG $vH]]
   for {set qp 0} {$qp < [llength $queue]} {incr qp} {
      foreach {type g h} [lindex $queue $qp] break
      switch -- $type "vertex" {
         if {[lindex $corr 0 $h] == $g} then {continue}
         if {[lindex $corr 0 $h] != -1 || [lindex $corr 1 $g] != -1}\
         then {return ""}
         if {[lindex $NWG 0 $g 0] ne [lindex $NWH 0 $h 0]}\
         then {return ""}
         lset corr 0 $h $g
         lset corr 1 $g $h
         foreach g1 [lindex $NWG 0 $g 1] h1 [lindex $NWH 0 $h 1] {
            lappend queue [list edgefw $g1 $h1]
         }
         foreach g1 [lindex $NWG 0 $g 2] h1 [lindex $NWH 0 $h 2] {
            lappend queue [list edgebw $g1 $h1]
         }
      } "edgefw" {
         if {[lindex $corr 2 $h] == $g} then {continue}
         if {[lindex $corr 2 $h] != -1} then {return ""}
         if {[lindex $NWH 1 $h 0] == 0} then {
            if {[lindex $corr 3 $g 0] eq "all"} then {return ""}
            lset corr 2 $h $g
            lset corr 3 $g [linsert [lindex $corr 3 $g] 0 tail $h]
         } else {
            if {[llength [lindex $corr 3 $g]]} then {return ""}
            if {[lindex $NWG 1 $g 0] == 0} then {return ""}
            lset corr 2 $h $g
            lset corr 3 $g [list all $h]
            lappend queue [list\
              vertex [lindex $NWG 1 $g 0] [lindex $NWH 1 $h 0]]
         }
      } "edgebw" {
         if {[lindex $corr 2 $h] == $g} then {continue}
         if {[lindex $corr 2 $h] != -1} then {return ""}
         if {[lindex $NWH 1 $h 2] == 1} then {
            if {[lindex $corr 3 $g 0] eq "all"} then {return ""}
            lset corr 2 $h $g
            lset corr 3 $g [linsert [lindex $corr 3 $g] end head $h]
         } else {
            if {[llength [lindex $corr 3 $g]]} then {return ""}
            if {[lindex $NWG 1 $g 2] == 1} then {return ""}
            lset corr 2 $h $g
            lset corr 3 $g [list all $h]
            lappend queue [list\
              vertex [lindex $NWG 1 $g 2] [lindex $NWH 1 $h 2]]
         }
      }
   }
   return $corr
}
%     \end{tcl}
%   \end{proc}
%   
%   A tricky matter is what it means for an feedback opportunity to be 
%   needed. The theoretical foundation lies instead in the complementary 
%   dependence relation from outputs to inputs, in terms of which the 
%   condition is that (i)~if an $H$-input in $G$ has a dependence on an 
%   $H$-output then $H$ must have a feedback allowing this dependence, 
%   and (ii)~the stated dependencies in $H$ must not give rise to any 
%   new dependencies in $G$. The main tool for checking this is the 
%   \emph{$H$-dependency matrix}, which for symmetry with dependency 
%   relations computed by the |edgeorder| procedure is such that
%   \begin{quote}
%     |lindex| \word{matrix} \word{out-index} \word{in-index}
%   \end{quote}
%   is |1| if the $H$-output with index \word{out-index} depends on 
%   the $H$-input with index \word{in-index} and |0| otherwise.
%   
%   
%   \begin{proc}{instances,H-dep}
%     This procedure updates the $H$-dependecy matrix by adding to it 
%     such dependencies that result from a given 
%     \word{correspondence}; it is meant to be used after all 
%     vertices (but none of the stray edges, since it ignores the 
%     exact segmentation of an edge) have been assigned. The return 
%     value is the updated matrix. This procedure may also |return| 
%     with a |-code continue|, which happens in the case that the 
%     \word{correspondence} turned out to be incompatible with the 
%     dependencies in $H$.
%     The call syntax is
%     \begin{quote}
%       \raggedright
%       |instances,H-dep| \word{$H$-dependency-matrix} 
%       \word{$G$-dependecy-arr} \word{correspondence} 
%       \word{$H$-network (with feedback)}  
%     \end{quote}
%     where the \word{$G$-dependecy-arr} is the name in the calling 
%     context of the array encoding the edge-dependency relation of 
%     $G$.
%     
%     More formally, there is a dependence of $H$-output $j$ on 
%     $H$-input $k$ if there is a ``dependency path'' from $j$ to 
%     $k$. A dependency path may go by two types of edge: explicit 
%     dependencies in $G$, as recorded in the 
%     \word{$G$-dependecy-arr}, and potential dependencies in $H$, as 
%     not forbidden by a feedback of $H$. Dependencies corresponding 
%     to a path with one edge of the second type are present in the 
%     input \word{$H$-dependency-matrix}, but dependencies needing to 
%     make use of paths of the first type are probably missing and 
%     have to be added. Since the $H$-dependencies are directed (from 
%     input to output), the $G$-dependencies that are of interest are 
%     those that go the other way (an input depends on an output).
%     
%     An abstract phrasing of the problem is that there is a 
%     bipartite graph with $X_i$ (the input indices) being the set of 
%     vertices on one side and $X_o$ (the output indices) being the 
%     set of vertices on the other. This graph has two kinds of 
%     edges: $H$-edges (corresponding to a dependency of output on 
%     input) and $G$-edges (corresponding to a dependency of input on 
%     output). What needs to be computed is the relation between 
%     inputs and outputs that there exists an alternating path 
%     (starting and ending with $H$-edges) from the input to the 
%     output, and the method used is a loop over the $G$-edges, where 
%     at each step new $H$-edges are inserted for every length $3$ 
%     alternating path with the $G$-edge as middle edge. At the same 
%     time, it is necessary to detect alternating cycles, since these 
%     are direct acyclicity violations. It is however sufficient to 
%     check for such cycles of length $2$, since chords are being 
%     inserted into longer cycles as part of the processing of 
%     altnernating paths.
%     
%     As a first step, lists of $H$-inputs and $H$-outputs are 
%     prepared, in the forms of $G$-edge-labels (|Li| and |Lo|) and 
%     $H$-in/out-indices (|Xi| and |Xo|). Once this is done, neither 
%     the \word{correspondence} nor the \word{$H$-network} are needed 
%     anymore.
%     \begin{tcl}
proc network::wfb::instances,H-dep {H_mat A_name corr NWH} {
   upvar 1 $A_name A
   set Li {}; set Xi {}
   foreach ei [lindex $NWH 0 0 1 1] {
      lappend Li [lindex $corr 2 $ei]
      lappend Xi [llength $Xi]
   }
   set Lo {}; set Xo {}
   foreach eo [lindex $NWH 0 0 0 2] {
      lappend Lo [lindex $corr 2 $eo]
      lappend Xo [llength $Xo]
   }
%     \end{tcl}
%     The second step is the loop over $G$-edges, in the form of the 
%     two outer |foreach| loops. The two inner |foreach| loops are 
%     looking for endpoints of a $HGH$-path. The |H_mat| is 
%     explicitly indexed to keep its refcount down.
%     \begin{tcl}
   foreach eo $Lo xo $Xo {
      if {$eo == -1} then {continue}
      foreach ei $Li xi $Xi {
         if {[info exists "A($ei $eo)"]} then {
            if {[lindex $H_mat $xo $xi]} then {
               return -code continue
            }
            foreach j $Xo {
               if {![lindex $H_mat $j $xi]} then {continue}
               foreach k $Xi {
                  if {[lindex $H_mat $xo $k]} then {lset H_mat $j $k 1}
               }
            }
         }
      }
   }
   return $H_mat
}
%     \end{tcl}
%   \end{proc}
%   
%   The main loop in |instances| is a depth first search through the 
%   tree of possible vertex and edge assignments. For this search, 
%   there is a |stack| whose elements are lists of one of the forms
%   \begin{quote}
%     \word{correspondence} \word{$H$-dependencies} |vertex| 
%       \word{vHL-index}\\
%     \word{correspondence} \word{$H$-dependencies} |edge| 
%       \word{$H$-input-index}
%   \end{quote}
%   where the |vertex| form represent that the next step is to 
%   assign a vertex (if any remain), and the |edge| form represent 
%   that the next step is to assign a stray edge (if any remain). The 
%   two index items are the indices (in the |vHL| list and as 
%   $H$-input, respectively) of the next vertex or edge that is not 
%   necessarily already assigned\Dash these indices should be 
%   incremented until an unassigned item is found or no more items of 
%   this type remain.
%   
%   \begin{proc}{instances,edgechoices}
%     For the assignment of stray edges, dependencies are taken into 
%     account from the start: an assignment doesn't make it to the 
%     |stack| if it leads to dependency cycles. As the basic 
%     principles of edge segmentation (an |all| edge is completely used 
%     up, a |tail| segment must be first, and a |head| segment must be 
%     last) are not particularly restrictive, the dependencies are 
%     significant factors in reducing the valency of the search tree.
%     
%     The call syntax of this procedure is
%     \begin{quote}
%       \raggedright
%       |instances,edgechoices| \word{$H$-edge} \word{correspondence} 
%       \word{$H$-network (pure)} \word{$H$-matrix} 
%       \word{$G$-dependecy-arr}
%     \end{quote}
%     and the return value the list of all assignments (in the form 
%     of elements to push onto the stack) of the $H$-edge that 
%     satisfy the segmentation and $H$-dependency restrictions.
%     
%     The main task in this procedure is to compute the $H$-matrix 
%     for each assignment returned. New dependencies may arise 
%     (i)~because of a $G$-dependency of the input or (ii)~because of 
%     a $G$-dependency on the output, but it is not necessary to 
%     consider combinations (an $HGHGH$-path), since a $GHG$-path 
%     with an assignment of the edge for the $H$ part is already 
%     present in the $G$-dependency relation; hence it is (as before) 
%     sufficient to look for $HGH$-dependency paths, where one 
%     endpoint of the $G$ part is one end of the \word{$H$-edge} 
%     being added. Most things need to be done once for the output 
%     end and another time for the input end, but that's the way it is.
%     
%     The main loop in this procedure is over the edges of $G$, where 
%     |n| is the label of the $G$-edge to which an assignment is 
%     currently being considered. |ni| and |no| are the $H$-input and 
%     $H$-output indices of the |edge| being assigned.
%     \begin{tcl}
proc network::wfb::instances,edgechoices\
  {edge corr NW H_mat Gdepname} {
   upvar 1 $Gdepname G_dep
   set ni [lindex $NW 1 $edge 3]
   set no [lindex $NW 1 $edge 1]
%     \end{tcl}
%     First lists |Li| and |Lo| of all involved $G$-edge labels 
%     corresponding to $H$-inputs and $H$-outputs, and matching lists 
%     |Xi| and |Xo| of their indices are construced. Two sublists 
%     |Yi| and |Yo| of the indices of $H$-legs of which the edge to 
%     assign has a dependence: |Yo| lists the outputs $H$-dependent 
%     on input |ni|, whereas |Yi| lists the inputs on which |no| is 
%     $H$-dependent.
%     \begin{tcl}
   set Li {}; set Xi {}; set Yi {}
   foreach ei [lindex $NW 0 1 1] d [lindex $H_mat $no] {
      lappend Li [lindex $corr 2 $ei]
      lappend Xi [llength $Xi]
      if {$d} then {lappend Yi [lindex $Xi end]}
   }
   set Lo {}; set Xo {}; set Yo {}
   foreach eo [lindex $NW 0 0 2] row $H_mat {
      lappend Lo [lindex $corr 2 $eo]
      lappend Xo [llength $Xo]
      if {[lindex $row $ni]} then {lappend Yo [lindex $Xo end]}
   }
   set nextindex [expr {$ni + 1}]
%     \end{tcl}
%     Now comes the main loop. There will often be quite a number of 
%     iterations of it, but at least those edges which already have 
%     been wholly assigned can be skipped quickly.
%     \begin{tcl}
   set res {}
   set n -1; foreach segL [lindex $corr 3] {incr n
      if {[lindex $segL 0] eq "all"} then {continue}
%     \end{tcl}
%     The next step is to list (in |Zo|) those $H$-outputs on which 
%     there is a $G$-dependence in edge |n| and (in |Zi|) those 
%     $H$-inputs which $G$-depend on edge |n|. The |Yi| and |Zi| 
%     lists are disjoint, as are the |Yo| and |Zo| lists, unless 
%     there is a dependency loop. Inputs and outputs which themselves 
%     have been assigned to |n| are not included in |Zi| and |Zo|, 
%     since their statuses typically depend on the exact position 
%     within the edge; that is handled in an inner loop over |segL|.
%     \begin{tcl}
      set ok 1
      set Zo {}
      foreach leg $Lo xo $Xo {
         if {$leg == $n || $leg == -1} then {continue}
         if {[info exists "G_dep($n $leg)"]} then {
            if {[lindex $H_mat $xo $ni]} then {set ok 0; break}
            lappend Zo $xo
         }
      }
      if {!$ok} then {continue}
      set Zi {}
      foreach leg $Li xi $Xi {
         if {$leg == $n || $leg == -1} then {continue}
         if {[info exists "G_dep($leg $n)"]} then {
            if {[lindex $H_mat $no $xi]} then {set ok 0; break}
            lappend Zi $xi
         }
      }
      if {!$ok} then {continue}
%     \end{tcl}
%     
%     The $H$-dependency matrices to put in the results are 
%     constructed by setting some positions in |H_mat| to |1|\Dash 
%     the trucky part is how to efficiently determine which, 
%     especially since different positions in |segL| may lead to 
%     different patterns. One factor in this are the |Yo| and |Yi| 
%     lists, since if some |$no $xi| or |$xo $ni| entry should be set 
%     to |1|, then the same should hold for |$no| or |$ni| replaced 
%     by any other element of |$Yo| or |$Yi|; what varies between 
%     different assignments are the |xi| and |xo| indices to set. 
%     This is instead kept track of using two additional lists |Mi| 
%     and |Mo|, which have the same number of elements as |Xi| and 
%     |Xo| respectively. The element with index |$xi| in |Mi| is 
%     positive if input |$ni| has a dependence on input |$xi|, 
%     similarly the element with index |$xo| in |Mo| is positive if 
%     output |$xo| has a dependence on output |$no|.
%     
%     As a first step, the segmentation-independent dependencies are 
%     entered into this list.
%     \begin{tcl}
      set Mo {}
      foreach xo $Xo {
         lappend Mo 0
         foreach xi $Zi {
            if {[lindex $H_mat $xo $xi]} then {
               lset Mo end 1; break
            }
         }
      }
      set Mi {}
      foreach xi $Xi {
         lappend Mi 0
         foreach xo $Zo {
            if {[lindex $H_mat $xo $xi]} then {
               lset Mi end 1; break
            }
         }
      }
%     \end{tcl}
%     When checking dependencies within an edge, the exact segment 
%     position matters. The idea is to let |ok| be $1$ minus the number 
%     of dependency conditions violated at the current position, so 
%     that one doesn't have to recheck each condition for each 
%     position. The |Mi| and |Mo| lists are similarly incremented by 
%     the number of dependencies that are relevant at the current 
%     position, to allow for simple updates.
%     
%     First walk through the |segL| to compute the state at the tail 
%     end of the edge, then walk through it again to actually 
%     produce assignments for each position. The |Mi| list already 
%     has the correct value for this position, but the |Mo| list 
%     rather has the correct value for the head end of the edge, and 
%     needs to be updated.
%     \begin{tcl}
      foreach {type leg} $segL {
         set xi [lindex $NW 1 $leg 3]
         if {$type eq "tail" || [lindex $H_mat $no $xi]}\
         then {incr ok -1}
         set M {}
         foreach m $Mo xo $Xo {
            lappend M [expr {$m + [lindex $H_mat $xo $xi]}]
         }
         set Mo $M
      }
%     \end{tcl}
%     In the loop over positions, a |dummy| final segment is added 
%     to make the loop cover also the position after the last 
%     previous item.
%     \begin{tcl}
      set p -2; foreach {type leg} [linsert $segL end dummy] {incr p 2
%     \end{tcl}
%     If this position is |ok| with all dependencies, then build the 
%     corresponding |stack| element.
%     \begin{tcl}
         if {$ok>0} then {
            set corr2 $corr
            lset corr2 2 $edge $n
            lset corr2 3 $n [linsert $segL $p mid $edge]
            set H_mat2 $H_mat
            foreach xi $Xi m $Mi {
               if {$m>0} then {
                  foreach xo $Yo {lset H_mat2 $xo $xi 1}
               }
            }
            foreach xo $Xo m $Mo {
               if {$m>0} then {
                  foreach xi $Yi {lset H_mat2 $xo $xi 1}
               }
            }
            lappend res [list $corr2 $H_mat2 edge [expr {$ni+1}]]
         }
%     \end{tcl}
%     Then update |ok|, |Mi|, and |Mo| for the next position.
%     \begin{tcl}
         if {$type eq "dummy"} then {break}
         set xi [lindex $NW 1 $leg 3]
         if {$type eq "tail" || [lindex $H_mat $no $xi]} then {incr ok}
         set M {}
         foreach m $Mo xo $Xo {
            lappend M [expr {$m - [lindex $H_mat $xo $xi]}]
         }
         set Mo $M
         set xo [lindex $NW 1 $leg 1]
         if {$type eq "head" || [lindex $H_mat $xo $ni]}\
         then {incr ok -1}
         set M {}
         foreach m $Mi xi $Xi {
            lappend M [expr {$m + [lindex $H_mat $xo $xi]}]
         }
         set Mi $M
%     \end{tcl}
%     End the loop over positions in the edge, and then the loop over 
%     edges.
%     \begin{tcl}
      }
   }
   return $res
}
%     \end{tcl}
%   \end{proc}
%   
%   As for the condition that the dependencies in $H$ must not create 
%   any new $G$-dependencies, this is done as a very last check, 
%   after the correspondence is complete.
%   
%   \begin{proc}{instances,matgeqprod}
%     This is a helper for the |instances| procedure. It has the call 
%     syntax
%     \begin{quote}
%       |instances,matgeqprod| \word{$A$} \word{$B_1$} \word{$B_2$}
%       \word{$B_3$}
%     \end{quote}
%     and it checks whether \(A \geqslant B_1 B_2 B_3\), returning 
%     |0| or |1| depending on whether this condition fails or not. All 
%     arguments are boolean matrices, the products in the 
%     right hand side are for boolean matrix arithmetic, and the 
%     $\geqslant$ is an element-wise matrix comparison. For technical 
%     reasons, matrices $A$, $B_1$, and $B_2$ should be lists of rows, 
%     whereas matrix $B_3$ should be a list of columns.
%     \begin{tcl}
proc network::wfb::instances,matgeqprod {A B1 B2 B3} {
   set B2B3 {}
   foreach col $B3 {
      set newcol {}
      foreach row $B2 {
         set prod 0
         foreach x $row y $col {set prod [expr {$prod || $x&&$y}]}
         lappend newcol $prod
      }
      lappend B2B3 $newcol
   }
   foreach rowA $A rowB $B1 {
      foreach z $rowA col $B2B3 {
         if {$z} then {continue}
         foreach x $rowB y $col {
            if {$x&&$y} then {return 0}
         }
      }
   }
   return 1
}
%     \end{tcl}
%   \end{proc}
%   
%   The first part of the |instances| procedure compiles a list |vHL| 
%   of $H$-vertex labels in an order that should speed up the search. 
%   The idea is to first process vertices of a type that is rare in $G$, 
%   to reduce the number of possibilities that needs to be tried. There 
%   is also a subordinate ordering that types are tried first which are 
%   more common in $H$; the rationale for this is that subsequent 
%   vertices of this type have fewer possibilities available.
%   \begin{tcl}
proc network::wfb::instances {NWG NWH {limit infinity}} {
   set n -1; foreach v [lindex $NWG 0 0] {incr n
      if {$n<2} then {continue}
      lappend TypeG([lindex $v 0]) $n
   }
   set n -1; foreach v [lindex $NWH 0 0] {incr n
      if {$n<2} then {continue}
      lappend TypeH([lindex $v 0]) $n
   }
   set L {}
   foreach type [array names TypeH] {
      if {![info exists TypeG($type)]} then {return ""}
      lappend L [list $type [llength $TypeG($type)]\
        [llength $TypeH($type)]]
      if {[lindex $L end 1] < [lindex $L end 2]} then {return ""}
   }
   set vHL {}
   foreach type [
      lsort -integer -index 1 [lsort -integer -decreasing -index 2 $L]
   ] {
      eval [list lappend vHL] $TypeH([lindex $type 0])
   }
%   \end{tcl}
%   The second part stores the dependency order on the edges of $G$ 
%   into the array |G_dep|. It also computes the matrices |H_mat| and 
%   |G_mat| of declared $H$- and $G$-dependencies. |G_mat| will 
%   eventually figure as $A$ in the call to |instances,matgeqprod|, 
%   whereas |H_mat| (after some updates) ends up as $B_2$ in that 
%   call. $B_1$ and $B_3$ are computed from |G_dep|, but only when 
%   there is a complete correspondence to test. Finally it constructs 
%   an empty correspondence and places the root of the search tree on 
%   the |stack|.
%   \begin{tcl}
   [namespace parent]::pure::edgeorder [lindex $NWG 0] G_dep 
   [namespace parent]::setconstlist\
     H_mat 1 [lindex $NWH 0 0 1 1] \
     G_mat 1 [lindex $NWG 0 0 1 1]
   [namespace parent]::setconstlist\
     H_mat $H_mat [lindex $NWH 0 0 0 2] \
     G_mat $G_mat [lindex $NWG 0 0 0 2]
   foreach fb [lindex $NWH 1] {lset H_mat $fb 0}
   foreach fb [lindex $NWG 1] {lset G_mat $fb 0}
   [namespace parent]::setconstlist L0 -1 [lindex $NWH 0 0] \
     L1 -1 [lindex $NWG 0 0]  L2 -1 [lindex $NWH 0 1] \
     L3 {} [lindex $NWG 0 1]
   set stack [list [list [list $L0 $L1 $L2 $L3] $H_mat vertex 0]]
%   \end{tcl}
%   The main loop continues until the |limit| has been reached or the 
%   stack is empty. The first part of it pops an element off the 
%   stack and brances according to its type.
%   \begin{tcl}
   set res {}
   while {[llength $res] < $limit && [llength $stack]} {
      foreach {corr H_mat type index} [lindex $stack end] break
      set stack [lreplace $stack [set stack end] end]
      switch -- $type "vertex" {
%   \end{tcl}
%   When the search is in the |vertex| phase, it quickly scans ahead 
%   for the first unassigned vertex and expands all assignments of 
%   that vertex, pushing those that succeed onto the stack. (Note: 
%   If assignment expansion is slow, then this could slow down the 
%   procedure unnecessarily in the case that a |limit| is provided.) 
%   \begin{tcl}
         foreach v [lrange $vHL $index end] {
            if {[lindex $corr 0 $v] == -1} then {
               foreach u $TypeG([lindex $NWH 0 0 $v 0]) {
                  if {[lindex $corr 1 $u] == -1} then {
                     set corr2 [
                        instances,expand $corr [lindex $NWG 0]\
                          [lindex $NWH 0] $u $v
                     ]
                     if {[llength $corr2]} then {
                        lappend stack\
                          [list $corr2 $H_mat vertex [expr {$index+1}]]
                     }
                  }
               }
               break
            }
            incr index
         }
%   \end{tcl}
%   If all vertices were already assigned, then check whether 
%   dependencies so far are OK and proceed to assign stray edges. 
%   Remember that |instances,H-dep| will issue a |continue| when the 
%   dependencies are not OK.
%   \begin{tcl}
         if {$index >= [llength $vHL]} then {
            lappend stack [list $corr [
               instances,H-dep $H_mat G_dep $corr $NWH
            ] edge 0]
         }
      } "edge" {
%   \end{tcl}
%   The |edge| phase of the search has a similar overall 
%   structure\Ldash there is an outer loop over the object that may 
%   need to be assigned, and an inner loop over the possibilities 
%   there are for assigning it\Dash but here the inner loop is part 
%   of the helper procedure |instances,edgechoices|.
%   \begin{tcl}
         foreach e [lrange [lindex $NWH 0 0 1 1] $index end] {
            if {[lindex $corr 2 $e] == -1} then {
               eval [list lappend stack] [
                  instances,edgechoices $e $corr [lindex $NWH 0]\
                    $H_mat G_dep
               ]
               break
            }
            incr index
         }
%   \end{tcl}
%   In the case that all legs have been successfully assigned, it is 
%   known that $H$ has enough feedbacks to cover the dependencies in 
%   $G$, but it still remains to determine whether $H$ can also cope 
%   with $G$'s feedbacks. Thus it is time to start constructing the 
%   $B_1$ and $B_3$ matrices for |instances,matgeqprod|.
%   \begin{tcl}
         if {$index >= [llength [lindex $NWH 0 0 1 1]]} then {
            set B1 {}
            foreach n [lindex $NWG 0 0 0 2] {
               set L {}
               foreach e [lindex $NWH 0 0 0 2] {
                  lappend L\
                    [info exists "G_dep($n [lindex $corr 2 $e])"]
               }
               lappend B1 $L
            }
            set B3 {}
            foreach n [lindex $NWG 0 0 1 1] {
               set L {}
               foreach e [lindex $NWH 0 0 1 1] {
                  lappend L\
                    [info exists "G_dep([lindex $corr 2 $e] $n)"]
               }
               lappend B3 $L
            }
            if {[instances,matgeqprod $G_mat $B1 $H_mat $B3]} then {
               lappend res [instances,region [lindex $NWH 0] $corr]
            }
         }
      }
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% Since all the above is rather complicated, the now follows a couple of 
% tests for the code, which also serves as tests for the various 
% network surgery routines.
% 
% \begin{proc}[]{verify_instances}
%   This is a helper for some of the tests, which checks that the 
%   results are really the expected ones. The call syntax is
%   \begin{displaysyntax}
%     |verify_instances| \word{network $G$} \word{network $H$} 
%     \word{\#unspecified} \begin{regblock}[\regstar]
%     \word{network $G \div H$} \word{count} \end{regblock}
%   \end{displaysyntax}
%   where \word{network $G$} and \word{network $H$} are as for 
%   |instances| itself. The remaining arguments are indirect 
%   specifications of the instances expected to be found: each 
%   \word{network $G \div H$} should be a pure network obtained by 
%   |detach|ing some instance of $H$ from $G$, and the following 
%   \word{count} is the number of such instances there should be. The 
%   \word{\#unspecified} is the number of instances for which $G \div 
%   H$ had not been computed; it can be equal to one of the 
%   \word{network $G \div H$}, but it is more likely that it is not. 
%   In all cases, it is checked that the regions found are isomorphic 
%   to $H$ and that |annex|ing $H$ to any $G \div H$ produces a 
%   network isomorphic to $G$.
%   
%   The return value is a report on discrepancies encountered. When 
%   all is well, that report is empty.
%   
%   \changes{2}{2007/05/20}{Procedure added, mostly because of the 
%      bug discovered in \texttt{detach}. (LH)}
%   
%   \begin{tcl}
%<*test>
proc verify_instances {NWG NWH unspec args} {
   foreach {NW count} $args {
      set C([network::pure::canonise $NW]) $count
   }
   set Gcan [network::pure::canonise [lindex $NWG 0]]
   set Hcan [network::pure::canonise [lindex $NWH 0]]
   set res ""
   set unspecL {}
   foreach region [network::wfb::instances $NWG $NWH] {
      set NW [network::pure::canonise [
         network::pure::uncover [lindex $NWG 0] $region
      ]]
      if {$NW ne $Hcan} then {
         append res "Network in region not H: $region" \n
         append res "Network H:" \n\
           [network::pure::autodeconstruct $Hcan] \n
         append res "Network in region:" \n 
           [network::pure::autodeconstruct $NW] \n
         append res "Ignoring region." \n \n
         continue
      }
      set GdivH [network::pure::canonise [
         network::pure::detach [lindex $NWG 0] $region
      ]]
      if {[info exists C($GdivH)] && $C($GdivH) > 0} then {
         incr C($GdivH) -1
      } else {
         lappend unspecL $GdivH
      }
      set NW [network::pure::canonise\
        [network::pure::annex $GdivH [lindex $NWH 0]]]
      if {$NW ne $Gcan} then {
         append res "Reannexation mismatch for region: $region" \n
         append res "Network (G div H) annex H:" \n\
           [network::pure::autodeconstruct $NW] \n \n
      }
   }
   foreach NW [array names C] {
      if {$C($NW) != 0} then {
         append res "Mismatch ($C($NW)) in count of detachment:" \n
         append res [network::pure::autodeconstruct $NW] \n \n
      }
   }
   if {$unspec != [llength $unspecL]} then {
      append res "Mismatch ($unspec - [llength $unspecL]) in count\
        of unspecified detachments." \n
      set n 0; foreach NW $unspecL {incr n
         append res "Detachment $n:" \n\
           [network::pure::autodeconstruct $NW] \n
      }
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% The first batch is to see that the kind of subnetworks the 
% old |network::searchsub| could do (networks spanned by their 
% vertices, without feedbacks to worry about) is handled correctly.
% \begin{tcl}
tcltest::test instances-1.1 "Single vertex H, count results" -body {
   set H [network::pure::construct {Delta {1 2}} Delta]
   set G [network::pure::construct {Delta {1 2}} {Delta Delta}]
   verify_instances [list $G {}] [list $H {}] 2
} -result 2
% \end{tcl}
% With the introduction of |verify_instances|, what used to be test 
% \texttt{instances-1.2} became a special case of 
% \texttt{instances-1.1}.
% \begin{tcl}
tcltest::test instances-1.3 "Composite H, one vertex type, 1" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta \r . Delta}]
   set G [network::pure::construct {Delta {1 2}} {Delta Delta}]
   verify_instances [list $G {}] [list $H {}] 0
}
tcltest::test instances-1.4 "Composite H, one vertex type, 2" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta \r . Delta}]
   set G [network::pure::construct {Delta {1 2}} {
     Delta \r . Delta \r . . Delta
   }]
   verify_instances [list $G {}] [list $H {}] 2
}
tcltest::test instances-1.5 "Composite H, one vertex type, 3" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta \r . Delta}]
   set G [network::pure::construct {Delta {1 2}} {
     Delta \r Delta . \r Delta . .
   }]
   verify_instances [list $G {}] [list $H {}] 0
}
tcltest::test instances-1.6 "Composite H, two vertex types" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     m \r Delta
   }]
   set G [network::pure::construct {Delta {1 2} m {2 1}} {
     Delta \r m \r Delta \r m
   }]
   verify_instances [list $G {}] [list $H {}] 1
}
tcltest::test instances-1.7 "Disconnected H" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta Delta}]
   verify_instances [list $H {}] [list $H {}] 2
}
tcltest::test instances-1.8 "Disconnected H with choices" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta Delta}]
   set G [network::pure::construct {Delta {1 2}} {Delta Delta Delta}]
   verify_instances [list $G {}] [list $H {}] 6
}
% \end{tcl}
% 
% The second test batch considers dependency problems.
% \begin{tcl}
tcltest::test instances-2.1 "Frobenius dependency" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     Delta . \r . m
   }]
   set G [network::pure::construct {Delta {1 2} m {2 1}} {
     Delta \r X \r m
   }]
   verify_instances [list $G {}] [list $H {}] 0
}
tcltest::test instances-2.2 "Minimal dependency" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     Delta . \r . m
   }]
   set G [network::pure::construct {Delta {1 2} m {2 1}} {
     Delta \r X \r m
   }]
   verify_instances [list $G {}] [list $H {{0 1}}] 1
}
tcltest::test instances-2.3 "G-feedback" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     Delta . \r . m
   }]
   verify_instances [list $H {{0 1}}] [list $H {}] 0
}
tcltest::test instances-2.4 "Hopf-rule with(out) feedback" -body {
   set Hopf {Delta {1 2} m {2 1} S {1 1}}
   set H [network::pure::construct $Hopf {
     . Delta \r 
     . Delta . \r
     X . S \r
     . m . \r
     . m
   }]
   set G [network::pure::construct $Hopf {
     Delta \r 
     Delta . \r
     Delta . S \r
     . m . \r
     . m
   }]
   list [
      verify_instances [list $G {}] [list $H {}] 0
   ] [
      verify_instances [list $G {}] [list $H {{0 0}}] 1
   ]
} -result {{} {}}
tcltest::test instances-2.5\
  "Disconnected H constrained by dependency" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta Delta}]
   set G [network::pure::construct {Delta {1 2}} {
     Delta Delta \r
     . . . Delta
   }]
   verify_instances [list $G {}] [list $H {}] 4
}
tcltest::test instances-2.6\
  "Disconnected H constrained by dependency 2" -body {
   set H [network::pure::construct {Delta {1 2}} {Delta Delta}]
   set G [network::pure::construct {Delta {1 2}} {
     Delta Delta \r
     . . . Delta
   }]
   verify_instances [list $G {}] [list $H {{1 1}}] 5
}
tcltest::test instances-2.7 "Disconnected H, two vertex types" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     m Delta
   }]
   set G [network::pure::construct {Delta {1 2} m {2 1}} {
     m \r Delta \r m \r Delta
   }]
   verify_instances [list $G {}] [list $H {{0 2}}] 3
}
% \end{tcl}
% 
% The third test batch is about stray edges.
% \begin{tcl}
tcltest::test instances-3.1 "Choose one edge of three" -body {
   set H [network::pure::construct {} {.}]
   set G [network::pure::construct {} {. . .}]
   verify_instances [list $G {}] [list $H {}] 3
}
tcltest::test instances-3.2 "Choose two edges of three" -body {
   set H [network::pure::construct {} {. .}]
   set G [network::pure::construct {} {. . .}]
   verify_instances [list $G {}] [list $H {}] 6
}
tcltest::test instances-3.3 "Choose three edges of two" -body {
   set H [network::pure::construct {} {. . .}]
   set G [network::pure::construct {} {. .}]
   verify_instances [list $G {}] [list $H {}] 0
}
tcltest::test instances-3.4 "Choose two edges w/fb of one" -body {
   set H [network::pure::construct {} {. .}]
   set G [network::pure::construct {} {.}]
   verify_instances [list $G {}] [list $H {{0 1} {1 0}}] 2
}
tcltest::test instances-3.5\
  "Choose three edges of one, with partial feedback" -body {
   set H [network::pure::construct {} {. . .}]
   set G [network::pure::construct {} {.}]
   verify_instances [list $G {}] [list $H {
     {0 1} {0 2} {1 0} {1 2} {2 0}
   }] 3
}
% \end{tcl}
% 
% The fourth and final test batch combines vertices with stray edges. 
% This is where the special status of |head| and |tail| segments 
% becomes important.
% \begin{tcl}
tcltest::test instances-4.1 "Vertex+edge, no feedback" -body {
   set H [network::pure::construct {Delta {1 2}} {. Delta}]
   set G [network::pure::construct {Delta {1 2}} {Delta Delta}]
   verify_instances [list $G {}] [list $H {}] 6
}
tcltest::test instances-4.2 "Vertex+edge, full feedback" -body {
   set H [network::pure::construct {Delta {1 2}} {. Delta}]
   set G [network::pure::construct {Delta {1 2}} {Delta Delta}]
   verify_instances [list $G {}] [list $H {{0 1} {1 0} {2 0}}] 12
}
tcltest::test instances-4.3 "Vertex+edge, partial feedback" -body {
   set H [network::pure::construct {Delta {1 2}} {. Delta}]
   set G [network::pure::construct {Delta {1 2}} {Delta Delta}]
   verify_instances [list $G {}] [list $H {{0 1} {2 0}}] 10
}
tcltest::test instances-4.4 "Vertex+2edges, full feedback" -body {
   set H [network::pure::construct {Delta {1 2}} {. Delta .}]
   set G [network::pure::construct {Delta {1 2}} {Delta}]
   verify_instances [list $G {}] [list $H {
     {0 1} {0 2} {1 0} {1 2} {2 0} {2 2} {3 0} {3 1}
   }] 12
}
tcltest::test instances-4.5 "2vertices+edge, partial feedback" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     m Delta .
   }]
   set Hwfb [list $H {
     {0 2} {0 3} {1 3} {2 3} {3 0} {3 1}
   }]
   set G [network::pure::construct {Delta {1 2} m {2 1}} {
     m \r Delta \r m \r Delta
   }]
   verify_instances [list $G {}] $Hwfb 9
}
tcltest::test instances-4.6\
  "2vertices+edge, non-transitive dependence" -body {
   set H [network::pure::construct {Delta {1 2} m {2 1}} {
     m Delta .
   }]
   set Hwfb [list $H {
     {0 2} {1 3} {2 3} {3 0} {3 1}
   }]
   set G [network::pure::construct {Delta {1 2} m {2 1}} {
     m \r Delta \r m \r Delta
   }]
   verify_instances [list $G {}] $Hwfb 0
}
% \end{tcl}
% Strange as it may seem with all these tests, some errors escaped 
% detection. The following was found in the wild, but turned out to 
% be an error in |network::pure::detach|; however, its discovery 
% prompted the creation of |verify_instances| and the switch to using 
% it for testing. The tricky thing about it is that $H$ has a stray 
% edge with plenty of feedback opportunities.
% \begin{tcl}
tcltest::test instances-5.1 "Bug 2007-05-20" -body {
   set Gwfb [list [network::pure::construct {
      m {2 1}  Delta {1 2}  twist {2 2}  unit {0 1}  S {1 1}
   } {
      m . . Delta .  \r
      . . . . twist  \r
      . . . m .      \r
      . . twist .    \r
      . X . .        \r
      m m .          \r
      . m            \r
      . unit S       
   }] {{1 1} {2 1} {1 0} {2 0} {0 2}}]
   set Hwfb [list [network::pure::construct {
      m {2 1}  Delta {1 2}  twist {2 2}  unit {0 1}  S {1 1}
   } {
      . . . Delta . .  \r
      . . . . twist .  \r
      . . . m . .      \r
      . . twist . .    \r
      . X . . .        \r
      m m . .          \r
      . m .            \r
      . S .            
   }] {{0 1} {1 0} {0 5} {1 5} {2 0}}]
   verify_instances $Gwfb $Hwfb 0 [
% \end{tcl}
% This $G \div H$ corresponds to putting the stray edge on output $2$ 
% of $G$.
% \begin{tcl}
      network::pure::construct {m {2 1}  unit {0 1}} {
        m . . . .   . X \r
        5X2 . \r
        . unit .    . . . . . .
      }
   ] 1 [
% \end{tcl}
% This $G \div H$ corresponds to putting the stray edge on output 
% $1$ of $G$.
% \begin{tcl}
      network::pure::construct {m {2 1}  unit {0 1}} {
        m . . . .   . X \r
        5X3 unit
      }
   ] 1
% \end{tcl}
% It might seem as if there should also be an opportunity to put the 
% stray edge after the |m| of inputs $0$ and $1$ of $G$, but that 
% fails because since the output of the stray edge has a hidden 
% dependency on input $1$, and output $0$ of $G$ is not allowed to 
% depend on input $2$ (which corresponds to input $1$ of $H$).
% \begin{tcl}
}
%</test>
% \end{tcl}
% 
% 
% \subsection{Ambiguities}
% 
% The mechanism driving a rewriting system completion procedure is the 
% construction of a critical set of ambiguities from a pair of rewrite 
% rules. For the networks considered here, a suitable format is that an 
% ambiguity is a list
% \begin{quote}
%   \word{site} \word{region 1} \word{region 2}
% \end{quote}
% where \word{site} is the network with feedback at which the ambiguity 
% is to be found, and \word{region 1} and \word{region 2} are the 
% regions within this network which would be replaced by the two rules 
% from which the ambiguity is formed.
% 
% \begin{proc}{ambiguities}
%   The |ambiguities| procedure computes the list of all ambiguities 
%   that can be formed by overlapping two networks. The call syntax is
%   \begin{quote}
%     |network::wfb::ambiguities| \word{network 1} \word{network 2}
%   \end{quote}
%   where the arguments are networks with feedback. The return value is 
%   a list of ambiguities as above, where \word{network 1} corresponds 
%   to \word{region 1} and \word{network 2} to \word{region 2}. 
%   
%   The algorithm is again a depth-first search through the tree of 
%   possible identifications of vertices of one network with vertices 
%   of the other. For each node of the search tree, there is a partial 
%   \word{site} network containing \word{network 1}, and the search 
%   proceeds by extending it with vertices from \word{network 2}, one 
%   at a time, or by joining up legs, also one at a time. 
%   
%   The data structure for a partial \word{site} is a list with ten 
%   elements
%   \begin{quote}
%     \raggedright
%     \word{vertices} \word{edges} \word{output-list} \word{input-list} 
%     \word{feedbacks} \word{correspondence} \word{2-output-list} 
%     \word{2-input-list} \word{out-dependence table} 
%     \word{in-dependence table}
%   \end{quote}
%   The \word{vertices} and \word{edges} together make up something 
%   which mostly conforms to the definition of a pure network, but there 
%   are some deviations. In the \word{vertices}, elements $0$ and $1$ 
%   are not updated; instead the \word{output-list} and 
%   \word{input-list} record outputs and inputs respectively of the 
%   network under construction. Elements of these lists are edge labels 
%   or $-1-e$ for an edge label $e$, where the latter case means $e$ 
%   used to be an output or input leg but has since been joined up with 
%   some other leg and is now an internal edge; input and output indices 
%   are not recycled when the site is being constructed. In the 
%   \word{edges}, elements are either normal edges (lists of length 
%   four) or lists of length one; in the latter case this element is a 
%   placeholder for a former input leg which have been joined up with 
%   some output leg to form an internal edge. The element in such a 
%   one-element list is the label of the edge with which the former 
%   edge was joined.
%   
%   The \word{feedbacks} is an ordinary list of feedbacks, where the 
%   indices in each feedback are indices into the \word{output-list} 
%   and \word{input-list}. 
%   The \word{correspondence} is a pair of lists, where the first is 
%   indexed by \word{network 2} vertex labels and has as element the 
%   corresponding label of a vertex in the \word{network} (or |-1| if 
%   there is none), and the second list conversely is indexed by 
%   \word{network} vertex labels and has as element the corresponding 
%   label of a vertex in \word{network 2} (or |-1| if there is none). 
%   The \word{2-output-list} and \word{2-input-list} are lists of the 
%   \word{site} network edge labels that correspond to outputs and 
%   inputs of \word{network 2}; elements corresponding to legs that 
%   have not yet been placed are set to |-1|. The \word{out-dependence 
%   table} is a matrix where the first index is an index into 
%   \word{output-list}, the second index is and index into 
%   \word{2-output-list}, and an entry is |1| iff the current 
%   correspondence would make the site-output dependent on the 
%   \word{network 2} output. The \word{in-dependence table} is 
%   similarly a matrix where the first index is an index into 
%   \word{input-list}, the second index is and index into 
%   \word{2-input-list}, and an entry is |1| iff the current 
%   correspondence would make the \word{network 2} input dependent on 
%   the site-input.
%   
%   \begin{proc}{ambiguities,connect}
%     The |connect| helper to |ambiguities| connects two legs of a 
%     \word{site} and updates its feedbacks accordingly. The call 
%     syntax is
%     \begin{quote}
%       |ambiguities,connect| \word{site} \word{network-2-edge}
%     \end{quote}
%     and the return value is the modified \word{site}, or an empty 
%     list if the legs could not be connected. The 
%     \word{network-2-edge} is the list
%     \begin{quote}
%       \word{head-vertex} \word{head-index} \word{tail-vertex} 
%       \word{tail-index}
%     \end{quote}
%     defining an edge in \word{network 2}.
%     
%     The first step is to check that the assingment (hasn't been 
%     made already and) is possible. Apart from that the legs still 
%     have to be legs, this requires going through the feedbacks to 
%     see if there is one from the out-leg to the in-leg. At the 
%     same time, lists are constructed of inputs on which the 
%     out-leg does not depend and outputs which do not depend 
%     on the in-leg.
%     \begin{tcl}
proc network::wfb::ambiguities,connect {site edge2} {
   foreach {head hi tail ti} $edge2 break
   set outleg [lindex $site 0 [lindex $site 5 0 $tail] 1 $ti]
   set inleg [lindex $site 0 [lindex $site 5 0 $head] 2 $hi]
   if {$outleg == $inleg} then {return $site}
   if {[lindex $site 1 $outleg 0] != 0 ||\
       [lindex $site 1 $inleg 2] != 1} then {return ""}
   set outx [lindex $site 1 $outleg 1]
   set inx [lindex $site 1 $inleg 3]
   set ok 0
   set indep_iL {}
   set indep_oL {}
   foreach fb [lindex $site 4] {
      if {[lindex $fb 0] == $outx} then {
         lappend indep_iL [lindex $fb 1]
      }
      if {[lindex $fb 1] == $inx} then {
         lappend indep_oL [lindex $fb 0]
      }
      set ok [expr {$ok ||\
        ([lindex $fb 0]==$outx && [lindex $fb 1]==$inx)}]
   }
   if {!$ok} then {return ""}
%     \end{tcl}
%     The second part modifies the network, input, and output parts 
%     of the \word{site}.
%     \begin{tcl}
   lset site 1 $outleg 0 [lindex $site 1 $inleg 0]
   lset site 1 $outleg 1 [lindex $site 1 $inleg 1]
   lset site 1 $inleg [list $outleg]
   lset site 0 [lindex $site 1 $outleg 0] 2\
     [lindex $site 1 $outleg 1] $outleg
   lset site 2 $outx [expr {-1 - $outleg}]
   lset site 3 $inx [expr {-1 - $inleg}]
%     \end{tcl}
%     The third part rebuilds the feedback list to remove those which 
%     are no longer possible. |state_iL| and |state_oL| are lists 
%     detailing the status of inputs and outputs: an entry is |1| if 
%     the leg has a dependency relation with the newly-joined edge 
%     and |0| otherwise. Feedbacks must be removed not only if they 
%     go to the newly-joined edge, but also if they form a cycle 
%     through it.
%     \begin{tcl}
   [namespace parent]::setconstlist state_iL 1 [lindex $site 3] \
     state_oL 1 [lindex $site 2]
   foreach x $indep_iL {lset state_iL $x 0}
   foreach x $indep_oL {lset state_oL $x 0}
   set L {}
   foreach fb [lindex $site 4] {
      if {[lindex $fb 0] != $outx && [lindex $fb 1] != $inx && !(
         [lindex $state_oL [lindex $fb 0]] &&\
         [lindex $state_iL [lindex $fb 1]]
      )} then {lappend L $fb}
   }
   lset site 4 $L
%<*debug>
   foreach fb $L {
      if {[lindex $site 2 [lindex $fb 0]] < 0 ||\
          [lindex $site 3 [lindex $fb 1]] < 0 } then {
         error "Bad feedback $fb in\n$site"
      }
   }
%</debug>
%     \end{tcl}
%     The fourth part adds dependencies to the in- and 
%     out-dependency tables. This effectively adds a given row to all 
%     rows with a |1| entry in the state vector.
%     \begin{tcl}
   set i -1; foreach x $state_iL {incr i
      if {!$x} then {continue}
      set j -1; foreach y [lindex $site 9 $inx] {incr j
         if {$y} then {lset site 9 $i $j 1}
      }
   }
   set i -1; foreach x $state_oL {incr i
      if {!$x} then {continue}
      set j -1; foreach y [lindex $site 8 $outx] {incr j
         if {$y} then {lset site 8 $i $j 1}
      }
   }
   return $site
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{ambiguities,extend}
%     The |extend| helper to |ambiguities| adds a loose vertex to a 
%     \word{site}. The call syntax is
%     \begin{quote}
%       |ambiguities,extend| \word{site} \word{vertex}
%     \end{quote}
%     where \word{vertex} has the form of the entry for an individual 
%     vertex in a network; the only information used is the annotation, 
%     the number of outputs, and the number of inputs. The label of the 
%     new vertex equals the number of vertices in the \word{site}.
%     
%     The main complication in this procedure is that feedbacks must 
%     be added between legs of the new vertex and legs of the 
%     previous network. 
%     \changes{2}{2007/02/26}{Bugfix: Feedbacks should only be added 
%       to legs that still exist (as opposed to having been joined up 
%       into an internal edge). (LH)}
%     \begin{tcl}
proc network::wfb::ambiguities,extend {site vertex} {
   foreach {V E outL inL fbL corr out2L in2L outTab inTab} $site break
   set newvertex [lrange $vertex 0 0]
   [namespace parent]::setconstlist N 0 $out2L
   set L {}; set xoL {}
   foreach leg [lindex $vertex 1] {
      set e [llength $E]
      lappend E [list 0 [llength $outL] [llength $V] [llength $L]]
      lappend L $e
      lappend xoL [llength $outL]
      lappend outL $e
      lappend outTab $N
   }
   lappend newvertex $L
   [namespace parent]::setconstlist N 0 $in2L
   set L {}; set xiL {}
   foreach leg [lindex $vertex 2] {
      set e [llength $E]
      lappend E [list [llength $V] [llength $L] 1 [llength $inL]]
      lappend L $e
      lappend xiL [llength $inL]
      lappend inL $e
      lappend inTab $N
   }
   lappend newvertex $L
   lappend V $newvertex
   set i -1; foreach leg [lindex $site 2] {incr i
      if {$leg<0} then {continue}
      foreach j $xiL {lappend fbL [list $i $j]}
   }
   set j -1; foreach leg [lindex $site 3] {incr j
      if {$leg<0} then {continue}
      foreach i $xoL {lappend fbL [list $i $j]}
   }
   lset site 0 $V
   lset site 1 $E
   lset site 2 $outL
   lset site 3 $inL
   lset site 4 $fbL
   lset site 5 1 [linsert [lindex $site 5 1] end -1]
   lset site 8 $outTab
   lset site 9 $inTab
   return $site
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{ambiguities,expand}
%     The |expand| helper of |ambiguities| is in charge of actually 
%     establishing the \word{correspondence} part of a site, by 
%     starting from a pair of vertices that should correspond to each 
%     other. It also handles removal of feedbacks that would 
%     contradict dependencies of \word{network 2} and listing legs 
%     where the site needs to be |extend|ed.
%     
%     The call syntax is
%     \begin{quote}
%       \raggedright
%       |ambiguities,expand| \word{queue-var} \word{site} 
%       \word{network 2 (pure)} \word{dependency matrix} 
%       \word{site-vertex} \word{2-vertex}
%     \end{quote}
%     and the return value is the \word{site} updated with an extended 
%     correspondence, or an empty list if the given assignment is 
%     inconsistent with the \word{site} and \word{network 2}. 
%     \word{2-vertex} is the label of a vertex in \word{network 2}, 
%     whereas \word{site-vertex} is the label in the \word{site} to 
%     which it should be assigned. The \word{dependency matrix} has 
%     as first index a \word{network 2} output index, as second index 
%     a \word{network 2} input index, and the entries are |1| if 
%     there is a dependency between these items and |0| otherwise.
%     
%     The \word{queue-var} is the name of a variable in the calling 
%     context, where edges in \word{network 2} which go outside the 
%     current \word{site} are collected. An item in this queue is a 
%     list
%     \begin{quote}
%       \word{edge} \word{vertex} \word{side}
%     \end{quote}
%     where \word{edge} is the label of the edge in \word{network 2}. 
%     The \word{vertex} is the label of the vertex in \word{network 
%     2} which must be assigned to something before the expansion can 
%     continue, and \word{side} is |0| or |1| depending on which side 
%     of the \word{side} this assignment must happen: |0| means the 
%     output side and |1| means the input side. Elements that had 
%     been added to the \word{queue-var} are not removed even if an 
%     empty list is returned.
%     
%     The |ambiguities,expand| procedure itself also uses a |queue|, 
%     but here there can be three types of elements
%     \begin{quote}
%       |vertex| \word{site vertex} \word{2-vertex}\\
%       |inleg| \word{site edge} \word{2-input-index}\\
%       |outleg| \word{site edge} \word{2-output-index}
%     \end{quote}
%     |vertex| elements are for searches within the part of the site 
%     for which a correspondence is being established, whereas 
%     |inleg| and |outleg| elements are generated when a boundary of 
%     \word{network 2} is reached. These are used to check that the 
%     site and its correspondence are consistent with the 
%     dependencies allowed in \word{network 2}.
%     
%     For the purpose of checking dependencies, array mappings |IN| 
%     and |OUT| from edge label to leg index are set up for the 
%     edges known to correspond to inputs and outputs of 
%     \word{network 2}. |IN| and |OUT| get more entries when 
%     additional \word{network 2}-legs are found.
%     \begin{tcl}
proc network::wfb::ambiguities,expand {eq_var site NW depM v v2} {
   upvar 1 $eq_var ext_queue
   set i -1; foreach e [lindex $site 6] {incr i
      set OUT($e) $i
   }
   set i -1; foreach e [lindex $site 7] {incr i
      set IN($e) $i
   }
%     \end{tcl}
%     The main loop.
%     \begin{tcl}
   set queue [list [list vertex $v $v2]]
   for {set qp 0} {$qp < [llength $queue]} {incr qp} {
      foreach {type g h} [lindex $queue $qp] break
      switch -- $type "vertex" {
%     \end{tcl}
%     Searches within \word{network 2} propagate from vertex to 
%     vertex. When a vertex is being assigned, one element is added 
%     to a queue (either |queue| or |ext_queue|) for every edge 
%     incident with the vertex. This means the process will try to 
%     assign vertices more than once, but it is less work to generate 
%     and process a queue element than it would be to avoid doing so. 
%     The backwash does not fulfill any function, however.
%     \begin{tcl}
         if {[lindex $site 5 0 $h] == $g} then {continue}
         if {[lindex $site 5 0 $h] != -1 ||\
             [lindex $site 5 1 $g] != -1 ||\
             [lindex $site 0 $g 0] ne [lindex $NW 0 $h 0]}\
         then {return ""}
         lset site 5 0 $h $g
         lset site 5 1 $g $h
         foreach g1 [lindex $site 0 $g 1] h1 [lindex $NW 0 $h 1] {
            set g2 [lindex $site 1 $g1 0]
            set h2 [lindex $NW 1 $h1 0]
            if {$h2 == 0} then {
               lappend queue [list outleg $g1 [
                  set OUT($g1) [lindex $NW 1 $h1 1]
               ]]
               lset site 6 [lindex $NW 1 $h1 1] $g1
            } elseif {$g2 == 0} then {
               lappend ext_queue [list $h1 $h2 1]
            } else {
               if {[lindex $site 1 $g1 1] != [lindex $NW 1 $h1 1]}\
               then {return ""}
               lappend queue [list vertex $g2 $h2]
            }
         }
         foreach g1 [lindex $site 0 $g 2] h1 [lindex $NW 0 $h 2] {
            set g2 [lindex $site 1 $g1 2]
            set h2 [lindex $NW 1 $h1 2]
            if {$h2 == 1} then {
               lappend queue [list inleg $g1 [
                  set IN($g1) [lindex $NW 1 $h1 3]
               ]]
               lset site 7 [lindex $NW 1 $h1 3] $g1
            } elseif {$g2 == 1} then {
               lappend ext_queue [list $h1 $h2 0]
            } else {
               if {[lindex $site 1 $g1 3] != [lindex $NW 1 $h1 3]}\
               then {return ""}
               lappend queue [list vertex $g2 $h2]
            }
         }
%     \end{tcl}
%     When a search has reached a network-2-leg, it will continue in 
%     the same direction along the edges, until it reaches the 
%     corresponding boundary of the site network. Warning: Since the 
%     same edge can be processed many times, this algorithm can be 
%     exponential (if the path searched along branches and rejoins 
%     repeatedly). The whole procedure could be made strictly 
%     polynomial if the |queue| is repeatedly checked so that items 
%     already present in it are not added again, but for practical 
%     cases it is probably faster to not do that.
%     \begin{tcl}
      } "outleg" {
         if {[info exists IN($g)] && [lindex $depM $h $IN($g)]}\
         then {return ""}
         if {[lindex $site 1 $g 0] == 0} then {
            lset site 8 [lindex $site 1 $g 1] $h 1
         } else {
            foreach e [lindex $site 0 [lindex $site 1 $g 0] 1] {
               lappend queue [list outleg $e $h]
            }
         }
      } "inleg" {
         if {[info exists OUT($g)] && [lindex $depM $OUT($g) $h]}\
         then {return ""}
         if {[lindex $site 1 $g 2] == 1} then {
            lset site 9 [lindex $site 1 $g 3] $h 1
         } else {
            foreach e [lindex $site 0 [lindex $site 1 $g 2] 2] {
               lappend queue [list inleg $e $h]
            }
         }
      }
   }
%     \end{tcl}
%     After the main loop has ended, it remains to remove those 
%     feedbacks which in view of the newfound correspondence would 
%     lead to loops. Since the expected case is that there are few 
%     feedbacks, this should be pretty fast.
%     \begin{tcl}
   set L {}
   foreach fb [lindex $site 4] {
      set ok 1
      foreach x [lindex $site 8 [lindex $fb 0]] row $depM {
         if {!$x} then {continue}
         foreach y $row z [lindex $site 9 [lindex $fb 1]] {
            if {$y && $z} then {set ok 0; break}
         }
         if {!$ok} then {break}
      }
      if {$ok} then {lappend L $fb}
   }
   lset site 4 $L
   return $site
}
%     \end{tcl}
%   \end{proc}
%   
%   The main |ambiguities| procedure is quite similar to the main 
%   |instances| procedure in that there is a |stack| of possibilities 
%   not explored yet and a variable |res| that collects all good 
%   results that have been found. A complication is however that there 
%   in this case also is a queue of edges to continue beyond the 
%   current boundary, and that processing queue elements may involve 
%   making choices. The solution used is that each stack element 
%   contains a queue, and that in each iteration of the main loop one 
%   element in the queue of one stack element is processed. The stack 
%   elements therefore have the form
%   \begin{quote}
%     \word{next-vertex} \word{queue} \word{site}
%   \end{quote}
%   where the \word{next-vertex} is the label of the next vertex in 
%   \word{network 2} to seek an assignment for, if the \word{queue} is 
%   empty. The \word{queue} contains |edgefw| and |edgebw| elements as 
%   generated by |ambiguities,expand|.
%   
%   An easy step to start with is to compute the \word{dependency 
%   matrix} for the |expand| helper.
%   \begin{tcl}
proc network::wfb::ambiguities {NW1 NW2} {
   set L {}
   foreach i [lindex $NW2 0 0 1 1] {lappend L 1}
   set depM {}
   foreach i [lindex $NW2 0 0 0 2] {lappend depM $L}
   foreach fb [lindex $NW2 1] {lset depM $fb 0}
%   \end{tcl}
%   The initial state for the \word{site} is \word{network 1}.
%   \begin{tcl}
   set V [lindex $NW1 0 0]
   set E [lindex $NW1 0 1]
   set outL [lindex $NW1 0 0 0 2]
   set inL [lindex $NW1 0 0 1 1]
   set fbL [lindex $NW1 1]
   set out2L {}; set oN {}
   foreach i [lindex $NW2 0 0 0 2] {
      lappend out2L -1 ; lappend oN 0
   }
   set outTab {}
   foreach i $outL {lappend outTab $oN}
   set in2L {}; set iN {}
   foreach i [lindex $NW2 0 0 1 1] {
      lappend in2L -1  ; lappend iN 0
   }
   set inTab {}
   foreach i $inL {lappend inTab $iN}
%   \end{tcl}
%   A simplification compared to the |instances| procedure is that the 
%   stray edges do not need any special attention, as they do not have 
%   to overlap at all. It is perfectly possible to just add the stray 
%   edges from \word{network 2} to the initial site as completely new 
%   edges. |iL| and |oL| are lists of indices of \word{network 1} 
%   inputs and outputs, which are used when adding feedbacks between 
%   these and the stray \word{network 2} edges. |i2L| and |o2L| are 
%   lists with the structure
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{site-index} 
%     \word{NW2-index}\end{regblock}
%   \end{quote}
%   that are used when adding feedbacks within the stray edges.
%   \begin{tcl}
   set iL {}; foreach e $inL {lappend iL [llength $iL]}
   set oL {}; foreach e $outL {lappend oL [llength $oL]}
   set i2L {}; set o2L {}
   foreach e [lindex $NW2 0 0 1 1] {
      if {[lindex $NW2 0 1 $e 0] != 0} then {continue}
      set edge [list 0 [llength $outL] 1 [llength $inL]]
      set xi [lindex $NW2 0 1 $e 3]
      set xo [lindex $NW2 0 1 $e 1]
      lappend i2L [lindex $edge 3] $xi
      lappend o2L [lindex $edge 1] $xo
      foreach i $oL {lappend fbL [list $i [lindex $edge 3]]}
      foreach i $iL {lappend fbL [list [lindex $edge 1] $i]}
      lappend outL [llength $E]
      lappend inL [llength $E]
      lset out2L $xo [llength $E]
      lset in2L $xi [llength $E]
      lappend outTab [lreplace $oN $xo $xo 1]
      lappend inTab [lreplace $iN $xi $xi 1]
      lappend E $edge
   }
   foreach {i i2} $o2L {
      foreach {j j2} $i2L {
         if {![lindex $depM $i2 $j2]} then {
            lappend fbL [list $i $j]
         }
      }
   }
%   \end{tcl}
%   The root \word{site} start out with information as above, and an 
%   no match correspondence. 
%   \begin{tcl}
   [namespace parent]::setconstlist c0 -1 [lindex $NW2 0 0]  c1 -1 $V
   set stack [list [
      list 2 {} [list $V $E $outL $inL $fbL [list $c0 $c1]\
        $out2L $in2L $outTab $inTab]
   ]]
   set res {}
   while {[llength $stack]} {
%<*debug1>
      foreach item $stack {
         puts [lrange $item 0 1]
      }
      puts " ----"
%</debug1>
      foreach {nextvertex queue site} [lindex $stack end] break
      set stack [lreplace $stack [set stack end] end]
      if {[llength $queue]} then {
%   \end{tcl}
%   Queues are traditionally processed in a FIFO order, but it is 
%   instructive to pause a moment and consider also the alterantive 
%   of processing |queue| in a LIFO order\Dash what difference would 
%   that make? The choice is primarily one between exploring the part 
%   of \word{network 2} not overlapping with \word{network 1} in a 
%   breadth-first or depth-first order, which corresponds to working 
%   with sites of high or low connectivity; breadth-first is never 
%   at a distance more than two from a fully connected site, whereas 
%   depth-first may follow a hamiltonian path to end without ever 
%   worrying about chords on that path. Since the overall process is 
%   a search through a space with many choices and many dead ends, it 
%   is important to quickly discover when things aren't working out. 
%   Low connectivity would also being about a large number of 
%   feedbacks, which affects many helpers negatively.
%   
%   When there is a queue element to process, one should thus pick 
%   the first element and remove it from the queue. If the 
%   \word{vertex} of that queue element is already assigned then a 
%   connection attempt can be made immediately, but otherwise it 
%   becomes necessary to also choose an assignment for the vertex.
%   \begin{tcl}
         foreach {edge vertex side} [lindex $queue 0] break
         set queue [lrange $queue 1 end]
         if {[lindex $site 5 0 $vertex] >= 0} then {
            set site [
               ambiguities,connect $site [lindex $NW2 0 1 $edge]
            ]
            if {[llength $site]} then {
               lappend stack [list $nextvertex $queue $site]
            }
         } else {
%   \end{tcl}
%   Assignment of edges is pretty similar whether it is done on the 
%   input or the output \word{side}; there are only a few list 
%   indices that differ in the initial checks of the prospective 
%   target vertex. Hence the two \word{side} cases are integrated. A 
%   second connection attempt is made immedaitely after an assignment 
%   expansion has turned out to be successful.
%   \begin{tcl}
            if {$side} then {
               set eL [lindex $site 3]
               set eidxpos 1
               set evpos 0
            } else {
               set eL [lindex $site 2]
               set eidxpos 3
               set evpos 2
            }
            foreach e $eL {
               if {$e<0} then {continue}
               if {[lindex $site 1 $e $eidxpos] !=\
                 [lindex $NW2 0 1 $edge $eidxpos]} then {continue}
               set v [lindex $site 1 $e $evpos]
               if {[lindex $site 5 1 $v] != -1 ||\
                 [lindex $site 0 $v 0] ne\
                 [lindex $NW2 0 0 $vertex 0]} then {continue}
               set queue2 $queue
               set site2 [
                  ambiguities,expand queue2 $site [lindex $NW2 0]\
                    $depM $v $vertex
               ]
               if {![llength $site2]} then {continue}
               set site2 [
                  ambiguities,connect $site2 [lindex $NW2 0 1 $edge]
               ]
               if {![llength $site2]} then {continue}
               lappend stack [list $nextvertex $queue2 $site2]
            }
%   \end{tcl}
%   There is also the important possibility that the vertex to assign 
%   does not correspond to anything in the \word{site}. In that case, 
%   the \word{site} must first be |extend|ed with a fresh new vertex 
%   before an assignment can be tried.
%   \begin{tcl}
            set queue2 $queue
            set site2 [
               ambiguities,expand queue2 [
                  ambiguities,extend $site [lindex $NW2 0 0 $vertex]
               ] [lindex $NW2 0] $depM [llength [lindex $site 0]]\
                 $vertex
            ]
            if {[llength $site2]} then {
               set site2 [
                  ambiguities,connect $site2 [lindex $NW2 0 1 $edge]
               ]
               if {[llength $site2]} then {
                  lappend stack [list $nextvertex $queue2 $site2]
               }
            }
         }
         continue
      }
%   \end{tcl}
%   There is a possibility for speeding up the above by not in 
%   |extend| generating a lot of feedbacks that will disappear again 
%   in the |connect| is made. This would however require separate 
%   versions of |extend| for different \word{side}s (and the 
%   undirected version would still be needed below), so the code is 
%   more compact this way.
%   
%   When the |queue| is empty, one must look at the |nextvertex|. 
%   The case most similar to the above is that a \word{network 2} 
%   vertex is found which is not yet assigned because it is in a 
%   different component than anything which had previously been 
%   assigned.
%   \begin{tcl}
      for {} {[lindex $site 5 0 $nextvertex] >= 0} {
         incr nextvertex
      } {}
      if {$nextvertex < [llength [lindex $site 5 0]]} then {
         set v 1; foreach v2 [lrange [lindex $site 5 1] 2 end] {
            incr v
            if {$v2 >= 0 || [lindex $site 0 $v 0] ne\
              [lindex $NW2 0 0 $nextvertex 0]} then {continue}
            set queue2 {}
            set site2 [
               ambiguities,expand queue2 $site [lindex $NW2 0]\
                 $depM $v $nextvertex
            ]
            if {[llength $site2]} then {
               lappend stack [list [expr {$nextvertex+1}]\
                 $queue2 $site2]
            }
         }
         set queue2 {}
         set site2 [
            ambiguities,expand queue2 [
               ambiguities,extend $site [lindex $NW2 0 0 $nextvertex]
            ] [lindex $NW2 0] $depM [llength [lindex $site 0]]\
              $nextvertex
         ]
         if {[llength $site2]} then {
            lappend stack [list [expr {$nextvertex+1}] $queue2 $site2]
         }
         continue
      }
%   \end{tcl}
%   But when there isn't another vertex, then the assignment is 
%   complete; all that remains is to extract the \word{ambiguity} 
%   from the \word{site}. The case that there isn't any overlap 
%   between the two networks may however be skipped, as that is 
%   just a montage ambiguity. 
%   \begin{tcl}
      if {[llength [lindex $site 0]] >= [llength [lindex $NW1 0 0]] +\
        [llength [lindex $NW2 0 0]] - 2} then {continue}
%   \end{tcl}
%   The network with feedback part of an ambiguity is apparent in the 
%   \word{site}, but unused elements must be removed from the 
%   \word{edges}, \word{output-list}, and \word{input-list} parts. 
%   These are rebuilt as |E|, |outL|, and |inL|, while lists |Emap|, 
%   |outLmap|, and |inLmap| which map indices in these lists to their 
%   final values are constructed. For unused edge labels |Emap| 
%   temporarily maps to |-1|, but the final value is given for these 
%   as well (it can't be looked up immediately since the other half 
%   of the edge may have a larger label, and it is sufficient with 
%   one extra round since a leg can only be |connect|ed once).
%   \begin{tcl}
%<debug2>  puts [join $site \n]
      set E {}; set Emap {}
      set L {}
      foreach e [lindex $site 1] {
         if {[llength $e] == 4} then {
            lappend Emap [llength $E]
            lappend E $e
         } else {
            lappend L [llength $Emap]
            lappend Emap -1
         }
      }
      foreach e $L {
         lset Emap $e [lindex $Emap [lindex $site 1 $e 0]]
      }
      set outL {}; set outLmap {}
      foreach e [lindex $site 2] {
         if {$e >= 0} then {
            lappend outLmap [llength $outL]
            lset E [lindex $Emap $e] 1 [llength $outL]
            lappend outL $e
         } else {
            lappend outLmap -1
         }
      }
      lset site 0 0 2 $outL
      set inL {}; set inLmap {}
      foreach e [lindex $site 3] {
         if {$e >= 0} then {
            lappend inLmap [llength $inL]
            lset E [lindex $Emap $e] 3 [llength $inL]
            lappend inL $e
         } else {
            lappend inLmap -1
         }
      }
      lset site 0 1 1 $inL
      set fbL {}
      foreach fb [lindex $site 4] {
         lappend fbL [list [lindex $outLmap [lindex $fb 0]]\
           [lindex $inLmap [lindex $fb 1]]]
      }
      set V {}
      foreach v [lindex $site 0] {
         set L {}
         foreach e [lindex $v 1] {lappend L [lindex $Emap $e]}
         lset v 1 $L
         set L {}
         foreach e [lindex $v 2] {lappend L [lindex $Emap $e]}
         lset v 2 $L
         lappend V $v
      }
      set amb [list [list [list $V $E] $fbL]]
%   \end{tcl}
%   The \word{region 1} part of the ambiguity is implicit in the 
%   initial value for the \word{site}, so one mostly just has to 
%   translate old labels to new ones. The only complication is that 
%   inputs must be checked for being the second segment on an edge, 
%   and this test is done by looking at the label of the vertex at 
%   the other end of the edge.
%   \begin{tcl}
      set L {}
      foreach v [lindex $NW1 0 0] {lappend L [llength $L]}
      lappend amb [list [lrange $L 2 end] {} {}]
      set L {}
      foreach e [lindex $NW1 0 0 0 2] {lappend L [lindex $Emap $e]}
      lset amb 1 1 $L
      set L {}
      foreach e [lindex $NW1 0 0 1 1] {
         set e [lindex $Emap $e]
         if {[lindex $E $e 2] < [llength [lindex $NW1 0 0]] &&\
           [lindex $E $e 2] > 1} then {
              incr e [llength $E]
         }
         lappend L $e
      }
      lset amb 1 2 $L
%   \end{tcl}
%   The \word{region 2} part of the ambiguity is more explicit in the 
%   \word{site} data, but the predicament concerning input edges 
%   remains.
%   \begin{tcl}
      lappend amb [list [lrange [lindex $site 5 0] 2 end] {} {}]
      set L {}
      foreach e [lindex $site 6] {lappend L [lindex $Emap $e]}
      lset amb 2 1 $L
      set L {}
      foreach e [lindex $site 7] {
         set e [lindex $Emap $e]
         if {[lindex $site 5 1 [lindex $E $e 2]] != -1} then {
            incr e [llength $E]
         }
         lappend L $e
      }
      lset amb 2 2 $L
%   \end{tcl}
%   Finally the main loop in |ambiguities| ends, with appending the 
%   ambiguity to the result.
%   \begin{tcl}
      lappend res $amb
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{groomed_ambiguities}
%   This procedure has the same call syntax and semantics as the 
%   |ambiguities| procedure, i.e.,
%   \begin{quote}
%     |network::wfb::groomed_ambiguities| \word{network 1} 
%     \word{network 2}
%   \end{quote}
%   The main difference is that this procedure post-processes the 
%   networks returned to make them tidier in the sense hopefully not 
%   requiring as many crossings. What is altered is the order of 
%   intputs and outputs.
%   
%   A second difference is that this procedure makes sure to call 
%   |ambiguities| with the larger network as the first one, since this 
%   will probably make it run faster.
%   
%   \begin{tcl}
proc network::wfb::groomed_ambiguities {NW1 NW2} {
   set nspure [namespace parent]::pure
   set res {}
   foreach amb [
      if {[llength [lindex $NW1 0 0]] >= [llength [lindex $NW2 0 0]]}\
      then {
         set idx1 1
         set idx2 2
         ambiguities $NW1 $NW2
      } else {
         set idx1 2
         set idx2 1
         ambiguities $NW2 $NW1
      }
   ] {
%<*debug>
      puts $amb
      puts [network::pure::autodeconstruct [lindex $amb 0 0]]
%</debug>
%   \end{tcl}
%   The grooming algorithm uses the same basic mechanisms as 
%   |order_graded_components|, but it doesn't bother about making the 
%   grading aestethically pleasing; all that sought is an ordering 
%   of the legs. 
%   
%   A technical complication is that there has to be something to 
%   order between vertices |0| and |1| in order to get the input leg 
%   ordering consistent with the output leg ordering. This is only 
%   a problem in the degenerate case that the input and output 
%   vertices are adjacent and at levels $1$ and $0$, but it 
%   nonetheless needs to be delt with. The chosen method is to insert 
%   an artificial level $1$ which is all edges. The |l| variable holds 
%   the index of the level below the input vertex.
%   \begin{tcl}
      set grading [${nspure}::minimal_grading [lindex $amb 0 0]]
      set l [lsearch -glob $grading {*{vertex 1}*}]
      if {$l < 2} then {
         set L {}
         foreach e [
            ${nspure}::piece_boundary [lindex $amb 0 0]\
              [lindex $grading 0] 1
         ] {lappend L [list edge $e]}
         set grading [linsert $grading [set grading 1] $L]
      } else {
         incr l -1
      }
%   \end{tcl}
%   The orderings of legs from the argument networks are provided as 
%   hints of what may be appropriate; it is necessary to make sure 
%   segment offsets are removed from the edge labels. Observations 
%   are generated of all levels, but only those of level $1$ matter.
%   \begin{tcl}
      set m [llength [lindex $amb 0 0 1]]
      set psOL {}
      set L {}
      foreach e [lindex $amb 1 1] {lappend L [expr {$e%$m}]}
      lappend psOL $L
      set L {}
      foreach e [lindex $amb 2 1] {lappend L [expr {$e%$m}]}
      lappend psOL $L
      set psIL {}
      set L {}
      foreach e [lindex $amb 1 2] {lappend L [expr {$e%$m}]}
      lappend psIL $L
      set L {}
      foreach e [lindex $amb 2 2] {lappend L [expr {$e%$m}]}
      lappend psIL $L
      set obsL [${nspure}::level_observations [lindex $amb 0 0]\
        $grading {0 1} $psOL $psIL]
      set outL {}
      foreach e [
         ${nspure}::piece_boundary [lindex $amb 0 0] [
            ${nspure}::default_observation_order [lindex $grading 1]\
              [lindex $obsL 1]
         ] 0
      ] {
         if {[lindex $amb 0 0 1 $e 0] == 0} then {lappend outL $e}
      }
      set sigma [${nspure}::lists_to_permutation $outL\
        [lindex $amb 0 0 0 0 2]]
%   \end{tcl}
%   For the ordering of input legs, the new ordering of output legs 
%   is added as an extra hint. Again observations are generated of 
%   all levels, but only those of level $l$ matter.
%   \begin{tcl}
      lappend psOL $outL
      set obsL [${nspure}::level_observations [lindex $amb 0 0]\
        $grading {0 1} $psOL $psIL]
      set tau {}
      foreach e [
         ${nspure}::piece_boundary [lindex $amb 0 0] [
            ${nspure}::default_observation_order [lindex $grading $l]\
              [lindex $obsL $l]
         ] 1
      ] {
         if {[lindex $amb 0 0 1 $e 2] == 1} then {
            lappend tau [lindex $amb 0 0 1 $e 3]
         }
      }
%   \end{tcl}
%   Once the two permutations have been computed, all that remains is 
%   to let them act on the ambiguity network. The two regions need 
%   not be changed, but they must be put in the right order.
%   \begin{tcl}
      lappend res [list [
         left_action $sigma [right_action [lindex $amb 0] $tau]
      ] [lindex $amb $idx1] [lindex $amb $idx2]]
   }
   return $res
}
%   \end{tcl}
%   
%   Here's a second implementation, using 
%   |network::pure::cosequence_levels|.
%   
%   \begin{tcl}
proc network::wfb::groomed_ambiguities {NW1 NW2} {
   set nspure [namespace parent]::pure
   set res {}
   foreach amb [
      if {[llength [lindex $NW1 0 0]] >= [llength [lindex $NW2 0 0]]}\
      then {
         set idx1 1
         set idx2 2
         ambiguities $NW1 $NW2
      } else {
         set idx1 2
         set idx2 1
         ambiguities $NW2 $NW1
      }
   ] {
%<*debug>
      puts $amb
      puts [network::pure::autodeconstruct [lindex $amb 0 0]]
%</debug>
%   \end{tcl}
%   Mapping out the first component is trivial. The list of its 
%   levels in down-\slash up-neighbours format needs to be trimmed of 
%   its top and bottom levels, however.
%   \begin{tcl}
      set c0 [${nspure}::component [lindex $amb 0 0] {0 1} {}]
      set duL [lrange [
         ${nspure}::component_DU_levels [lindex $amb 0 0] $c0
      ] 1 end-1]
      if {[llength $duL] < 3} then {
         # There are no inputs or outputs, hence no need to sequence 
         # anything. Use the raw ambiguity and continue.
         lappend res [list [lindex $amb 0] [lindex $amb $idx1]\
           [lindex $amb $idx2]]
         continue
      }
      set L {}
      foreach item [lindex $duL 0] {
         lappend L [lreplace $item 1 1 {}]
      }
      lset duL 0 $L
      set L {}
      foreach item [lindex $duL end] {
         lappend L [lreplace $item 2 2 {}]
      }
      lset duL end $L
%   \end{tcl}
%   If the ordering of the region networks |NW1| and |NW2| should be 
%   used to guide the ordering in the ambiguity, then this is where 
%   the corresponding hints should be computed.
%   \begin{tcl}
      set ordered [${nspure}::cosequence_levels {} $duL {}]
%   \end{tcl}
%   \begin{tcl}
      set outL [${nspure}::piece_boundary [lindex $amb 0 0]\
        [lindex $ordered 0] 0]
      set inL [${nspure}::piece_boundary [lindex $amb 0 0]\
        [lindex $ordered end] 1]
      set sigma [${nspure}::lists_to_permutation $outL\
        [lindex $amb 0 0 0 0 2]]
      set tau [${nspure}::lists_to_permutation\
        [lindex $amb 0 0 0 1 1] $inL]
%   \end{tcl}
%   Once the two permutations have been computed, all that remains is 
%   to let them act on the ambiguity network. The two regions need 
%   not be changed, but they must be put in the right order.
%   \begin{tcl}
      lappend res [list [
         left_action $sigma [right_action [lindex $amb 0] $tau]
      ] [lindex $amb $idx1] [lindex $amb $idx2]]
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}[]{verified_ambiguities}
%   This procedure is a helper for testing 
%   |network::wfb::ambiguities| and its |groomed_| persona. 
%   It has the same syntax as that main procedure and calls it, but 
%   then it checks the returned ambiguities to make sure that the two 
%   specified regions really are isomorphic to the given arguments and 
%   that the regions are instances of these networks. If a descripancy 
%   is found, then a detailed description is written to |stdout|, but 
%   no error is thrown.
%   
%   The call syntax is
%   \begin{quote}
%     |verified_ambiguities| \word{network 1} \word{network 2} 
%     |-signatures|\regopt
%   \end{quote}
%   Without the |-signatures| option, the result is the actual list of 
%   ambiguities. With the |-signatures| option, the result is instead 
%   a sorted dictionary of the signatures of the ambiguities, where a 
%   signature is a list
%   \begin{quote}
%     \word{\# vertices} \word{\# edges} \word{\# outputs}
%     \word{\# inputs} \word{\# feedbacks} \word{\# cuts in 1}
%     \word{\# cuts in 2}
%   \end{quote}
%   and the dictionary maps signatures to counts of that signature.
%   The list of signatures is sorted using |lsort -dictionary|. The 
%   ``\# of cuts'' refers to edges in the ambiguity which are cut up 
%   into pieces by the corresponding region.
%   
%   \begin{variable}{ambiguities_to_verify}
%     The procedure can verify either |ambiguities| or 
%     |groomed_ambiguities|, depending on how the 
%     |ambiguities_to_verify| variable is set.
%     \begin{tcl}
%<*test>
if {![info exists ::ambiguities_to_verify]} then {
   set ::ambiguities_to_verify network::wfb::ambiguities
}
%     \end{tcl}
%   \end{variable}
%   
%   \begin{tcl}
proc verified_ambiguities {NW1 NW2 args} {
   global ambiguities_to_verify
   set ambL [$ambiguities_to_verify $NW1 $NW2]
   set NW1c [network::pure::canonise [lindex $NW1 0]]
   set NW2c [network::pure::canonise [lindex $NW2 0]]
   set signL {}
   foreach amb $ambL {
      set NW0c [network::pure::canonise [lindex $amb 0 0]]
      set report ""
      set NW1b [network::pure::canonise [
         network::pure::uncover [lindex $amb 0 0] [lindex $amb 1]
      ]]
      if {$NW1b ne $NW1c} then {
         append report \n "* NW1 not equal." \n "Should be: " $NW1c\
           \n "Was: " $NW1b
      }
      set NW2b [network::pure::canonise [
         network::pure::uncover [lindex $amb 0 0] [lindex $amb 2]
      ]]
      if {$NW2b ne $NW2c} then {
         append report \n "* NW2 not equal." \n "Should be: " $NW2c\
           \n "Was: " $NW2b
      }
      set NW1a [network::pure::canonise [
         network::pure::replace [lindex $amb 0 0] [lindex $amb 1]\
           $NW1c
      ]]
      if {$NW1a ne $NW0c} then {
         append report \n "* Rebuild 1 not equal." \n\
           "Should be: " $NW0c \n "Was: " $NW1a
      }
      set NW2a [network::pure::canonise [
         network::pure::replace [lindex $amb 0 0] [lindex $amb 2]\
           $NW2c
      ]]
      if {$NW2a ne $NW0c} then {
         append report \n "* Rebuild 2 not equal." \n\
           "Should be: " $NW0c \n "Was: " $NW1a
      }
      set ok 0
      set n 0
      foreach region [
         network::wfb::instances [lindex $amb 0] $NW1
      ] {
         incr n
         if {[lsort -integer [lindex $region 0]] ne\
             [lsort -integer [lindex $amb 1 0]]} then {continue}
         if {[lindex $region 1] eq [lindex $amb 1 1] &&\
           [lindex $region 2] eq [lindex $amb 1 2]} then {
            set ok 1
            break
         }
      }
      if {!$ok} then {
         append report \n "* NW1 not found, $n instances checked."
      }
      set ok 0
      set n 0
      foreach region [
         network::wfb::instances [lindex $amb 0] $NW2
      ] {
         incr n
         if {[lsort -integer [lindex $region 0]] ne\
             [lsort -integer [lindex $amb 2 0]]} then {continue}
         if {[lindex $region 1] eq [lindex $amb 2 1] &&\
           [lindex $region 2] eq [lindex $amb 2 2]} then {
            set ok 1
            break
         }
      }
      if {!$ok} then {
         append report \n "* NW2 not found, $n instances checked."
      }
      if {$report ne ""} then {
         puts "Problem with ambiguity: $amb$report"
      }
      foreach var {c1 c2} idx {1 2} {
         set $var 0
         foreach e [lindex $amb $idx 2] {
            if {$e >= [llength [lindex $amb 0 0 1]]} then {incr $var}
         }
      }
      lappend signL [list [llength [lindex $amb 0 0 0]]\
        [llength [lindex $amb 0 0 1]]\
        [llength [lindex $amb 0 0 0 0 2]]\
        [llength [lindex $amb 0 0 0 1 1]]\
        [llength [lindex $amb 0 1]] $c1 $c2]
   }
   if {$args eq "-signatures"} then {
      foreach sign $signL {
         if {[info exists S($sign)]} then {
            incr S($sign)
         } else {
            set S($sign) 1
         }
      }
      set signL {}
      foreach sign [lsort -dictionary [array names S]] {
         lappend signL $sign $S($sign)
      }
      return $signL
   } else {
      return $ambL
   }
}
%   \end{tcl}
% \end{proc}
% 
% The minimal tests of |ambiguities| keeps expansions down to the 
% vertices where they start by restricting \word{network 2} to cases 
% where there are no internal edges.
% \begin{tcl}
tcltest::test ambiguities-1.1 "Isolated vertex both" -body {
   set NW [network::pure::construct {m {2 1}} {m}]
   verified_ambiguities [list $NW {}] [list $NW {}] -signatures
} -result {{3 3 1 2 0 0 0} 1} -output ""
tcltest::test ambiguities-1.2 "Isolated vertex nomatch" -body {
   set NW1 [network::pure::construct {m {2 1}} {m}]
   set NW2 [network::pure::construct {notm {2 1}} {notm}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {} -output ""
tcltest::test ambiguities-1.3 "Isolated vertex choice" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S}]
   set NW2 [network::pure::construct {S {1 1}} {S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{4 4 2 2 0 0 0} 2} -output ""
tcltest::test ambiguities-1.4 "Two vertices two choices" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S}]
   set NW2 [network::pure::construct {S {1 1}} {S S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{4 4 2 2 0 0 0} 2 {5 6 3 3 2 0 0} 4} -output ""
tcltest::test ambiguities-1.5 "Two vertices 2x2 choices" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S \r S S}]
   set NW2 [network::pure::construct {S {1 1}} {S S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{6 6 2 2 0 0 0} 8 {7 8 3 3 2 0 0} 8} -output ""
tcltest::test ambiguities-1.6 "Two vertices 1fb 2x2 choices" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S \r S S}]
   set NW2 [network::pure::construct {S {1 1}} {S S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {{0 1}}] -signatures
} -result {{6 6 2 2 0 0 0} 8 {6 6 2 2 0 0 1} 2 {7 8 3 3 3 0 0} 8}\
  -output ""
tcltest::test ambiguities-1.7 "Two vertices 1+1fb 2x2 choices" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S \r S S}]
   set NW2 [network::pure::construct {S {1 1}} {S S}]
   verified_ambiguities [list $NW1 {{0 1}}] [list $NW2 {{0 1}}]\
     -signatures
} -result {{6 6 2 2 0 0 0} 4 {6 6 2 2 1 0 0} 4 {6 6 2 2 1 0 1} 2\
  {7 8 3 3 4 0 0} 8} -output ""
tcltest::test ambiguities-1.8 "Isolated vertex choice + edges" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S .}]
   set NW2 [network::pure::construct {S {1 1}} {S .}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{4 6 4 4 4 0 0} 2} -output ""
% \end{tcl}
% The following case was during tests of a higher level procedure 
% thought to trigger a bug in |ambiguities|, but it turned out the 
% problem was really that an edge in one of the ambiguities was cut.
% \begin{tcl}
tcltest::test ambiguities-1.9 "Bug case" -body {
   set Hopf {Delta {1 2} m {2 1} S {1 1}}
   set NW1 [network::pure::construct $Hopf {
      . Delta    \r
      . Delta .  \r
      X . .      \r
      . m S      \r
      . m        
   }]
   set NW2 [network::pure::construct $Hopf {m Delta}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {
     {0 2} {1 0} {1 1} {2 0} {2 1}
   }] -signatures
} -result {{7 9 2 2 0 0 0} 3 {7 9 2 2 0 0 1} 1\
  {8 12 3 4 6 0 0} 2 {8 12 4 3 6 0 0} 2} -output ""
% \end{tcl}
% 
% The interesting cases are however those where expansion over edges 
% is interesting, as these are what should mostly happen in 
% applications. In the first of these, propagations from vertex to 
% vertex are still avoided, by picking as \word{network 1} a tensor 
% product of elementary networks.
% \begin{tcl}
tcltest::test ambiguities-2.1 "Path on isolated vertex" -body {
   set NW1 [network::pure::construct {S {1 1}} {S}]
   set NW2 [network::pure::construct {S {1 1}} {S \r S \r S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{5 4 1 1 0 0 0} 3} -output ""
tcltest::test ambiguities-2.2 "Path on 2 isolated vertices" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S}]
   set NW2 [network::pure::construct {S {1 1}} {S \r S \r S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{6 6 2 2 0 0 0} 6} -output ""
tcltest::test ambiguities-2.3 "Path on 2 isolated vertices 1fb" -body {
   set NW1 [network::pure::construct {S {1 1}} {S S}]
   set NW2 [network::pure::construct {S {1 1}} {S \r S \r S}]
   verified_ambiguities [list $NW1 {{1 0}}] [list $NW2 {}] -signatures
} -result {{5 4 1 1 0 0 0} 1 {5 4 1 1 0 1 0} 2 {6 6 2 2 1 0 0} 6}\
  -output ""
tcltest::test ambiguities-2.4 "Tree on isolated vertex" -body {
   set NW1 [network::pure::construct {m {2 1}} {m}]
   set NW2 [network::pure::construct {m {2 1}} {m m \r m}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{5 7 1 4 0 0 0} 3} -output ""
% \end{tcl}
% If this group of tests should be extended, it should probably be 
% with similar tests where the labelling of vertices is different, as 
% that the order is important for whether things are done going up or 
% going down.
% 
% The next group focuses on vertex--vertex propagations in the 
% |expand| helper.
% \begin{tcl}
tcltest::test ambiguities-3.1 "Path inclusion" -body {
   set NW1 [network::pure::construct {S {1 1} h {1 1} t {1 1}} {
     t \r S \r S \r S \r h
   }]
   set NW2 [network::pure::construct {S {1 1} h {1 1} t {1 1}} {
     S \r S
   }]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{7 6 1 1 0 0 0} 2} -output ""
tcltest::test ambiguities-3.2 "Path overlap&incl" -body {
   set NW1 [network::pure::construct {S {1 1}} {
     S \r S \r S
   }]
   set NW2 [network::pure::construct {S {1 1}} {S \r S}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{5 4 1 1 0 0 0} 2 {6 5 1 1 0 0 0} 2} -output ""
tcltest::test ambiguities-3.3 "Left-right-ass." -body {
   set NW1 [network::pure::construct {m {2 1}} {m . \r m}]
   set NW2 [network::pure::construct {m {2 1}} {. m \r m}]
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{5 7 1 4 0 0 0} 3} -output ""
tcltest::test ambiguities-3.4 "Right-right-ass." -body {
   set NW [network::pure::construct {m {2 1}} {. m \r m}]
   verified_ambiguities [list $NW {}] [list $NW {}] -signatures
} -result {{4 5 1 3 0 0 0} 1 {5 7 1 4 0 0 0} 2} -output ""
tcltest::test ambiguities-3.5 "Gluing alternating 2-paths" -body {
   set NW1 [list [network::pure::construct {S {1 1} R {1 1}} {
     S S \r R R
   }] {{0 1} {1 0}}]
   set NW2 [list [network::pure::construct {S {1 1} R {1 1}} {
     R \r S
   }] {}]
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{6 5 1 1 0 1 0} 2 {7 7 2 2 2 0 0} 4} -output ""
% \end{tcl}
% 
% Finally, let's try a collection of real life examples, which 
% exercise some aspect of the ambiguity construction mechanism. The 
% first two check regions with cut edges, by superimposing \(m \circ 
% (\id \otimes\nobreak S) \circ \Delta\) on another Hopf algebra 
% identity.
% \begin{tcl}
tcltest::test ambiguities-4.1 "Join legs 1" -body {
   set Hopf {Delta {1 2} m {2 1} S {1 1}}
   set NW1 [list [network::pure::construct $Hopf {
     . Delta \r
     . Delta . \r
     X S . \r
     . m . \r
     . m
   }] {{0 0}}]
   set NW2 [list [network::pure::construct $Hopf {
     Delta \r
     . S \r
     m
   }] {}]
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{7 8 1 1 0 1 0} 1} -output ""
tcltest::test ambiguities-4.2 "Join legs 2" -body {
   set Hopf {Delta {1 2} m {2 1} S {1 1}}
   set NW1 [list [network::pure::construct $Hopf {
     . Delta \r
     . Delta . \r
     X S . \r
     . m . \r
     . m
   }] {{0 0}}]
   set NW2 [list [network::pure::construct $Hopf {
     Delta \r
     . S \r
     m
   }] {}]
   verified_ambiguities $NW2 $NW1 -signatures ; # Different order
} -result {{7 8 1 1 0 0 1} 1} -output ""
% \end{tcl}
% Swapping which connections have the antipode $S$ on them brings 
% another variant on connecting legs.
% \begin{tcl}
tcltest::test ambiguities-4.3 "Join legs 3" -body {
   set Hopf {Delta {1 2} m {2 1} S {1 1}}
   set NW1 [list [network::pure::construct $Hopf {
     . Delta \r
     . Delta . \r
     X . S \r
     . m . \r
     . m
   }] {{0 0}}]
   set NW2 [list [network::pure::construct $Hopf {
     Delta \r
     S . \r
     m
   }] {}]
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{8 9 1 1 0 0 0} 1} -output ""
% \end{tcl}
% Where does the feedback used in |NW1| above come from, though? None 
% of the Hopf algebra axioms has any feedbacks, but the process of 
% forming ambiguities can create feedbacks. The following is one 
% situation which can create it.
% \begin{tcl}
tcltest::test ambiguities-4.4 "Feedback creation" -body {
   set Hopf {Delta {1 2} m {2 1} S {1 1}}
   set NW1 [list [network::pure::construct $Hopf {
     . Delta \r
     m S \r
     m
   }] {}]
   set NW2 [list [network::pure::construct $Hopf {
     Delta \r
     . Delta
   }] {}]
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{7 9 2 2 1 0 0} 1} -output ""
% \end{tcl}
% For Frobenius algebras, where product--coproduct compatibility 
% should probably go the other way, there are two ambiguities that 
% the two rules should create. Adding the incorrect full set of 
% feedbacks for these rules allows for one extra ambiguity, where 
% both vertices overlap (but are connected along different edges).
% \begin{tcl}
tcltest::test ambiguities-4.5 "Frobenius overlaps" -body {
   set Frobenius {Delta {1 2} m {2 1}}
   set NW1 [list [network::pure::construct $Frobenius {
     . Delta \r m .
   }] {}]
   set NW2 [list [network::pure::construct $Frobenius {
     Delta . \r . m
   }] {}]
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{5 7 2 3 0 0 0} 1 {5 7 3 2 0 0 0} 1} -output ""
tcltest::test ambiguities-4.6 "Pseudo-Frobenius overlaps" -body {
   set Frobenius {Delta {1 2} m {2 1}}
   set NW1 [list [network::pure::construct $Frobenius {
     . Delta \r m .
   }] {{1 0}}]
   set NW2 [list [network::pure::construct $Frobenius {
     Delta . \r . m
   }] {{0 1}}]
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{4 4 1 1 0 1 1} 1 {5 7 2 3 2 0 0} 1 {5 7 3 2 2 0 0} 1}\
  -output ""
% \end{tcl}
% The following case, which was found ``in the wild'', triggered an 
% error in |groomed_ambiguities| but not in plain |ambiguities|. It 
% turned out the real error was in |minimal_grading|.
% \begin{tcl}
tcltest::test ambiguities-4.7 "Grooming error 2007-02-14" -body {
   set NW1 {
     {{{} {} 8} {{} {6 7} {}} {S 0 5} {m 9 {0 2}} {Delta {1 2} 6}\
       {m 5 {1 3}} {Delta {3 4} 7} {m 8 {9 4}}} 
     {{3 0 2 0} {5 0 4 0} {3 1 4 1} {5 1 6 0} {7 1 6 1} {2 0 5 0}\
       {4 0 1 0} {6 0 1 1} {0 0 7 0} {7 0 3 0}}
   }
   set NW2 {
     {{{} {} 4} {{} {0 2 3} {}} {m 1 {2 3}} {m 4 {0 1}}} 
     {{3 0 1 0} {3 1 2 0} {2 0 1 1} {2 1 1 2} {0 0 3 0}}
   }
   verified_ambiguities [list $NW1 {}] [list $NW2 {}] -signatures
} -result {{9 12 1 3 0 0 0} 1} -output ""
% \end{tcl}
% The following example generated a bad feedback to ``input $-1$''. 
% Regenerating |NW2| caused the error to disappear, so apparently it 
% depended on the labelling.
% \begin{tcl}
tcltest::test ambiguities-4.8 "Feedback error 2007-02-26" -body {
   set NW1 {{
      {{{} {} {7 0 2}} {{} {5 6} {}} {twist {0 1} {4 8}} {m 3 {5 1}}\
        {m 2 {3 10}} {unit 4 {}} {Delta {9 10} 6} {Delta {7 8} 9}} 
      {{0 1 2 0} {3 1 2 1} {0 2 4 0} {4 0 3 0} {2 0 5 0} {3 0 1 0}\
        {6 0 1 1} {0 0 7 0} {2 1 7 1} {7 0 6 0} {4 1 6 1}}
   } {{1 0} {0 0}}}
   set NW2 {{
      {{{} {} {7 3 2}} {{} {5 6} {}} {m 0 {5 8}} {m 3 {0 1}}\
        {twist {1 2} {10 4}} {unit 4 {}} {Delta {9 10} 6}\
        {Delta {7 8} 9}} 
      {{3 0 2 0} {3 1 4 0} {0 2 4 1} {0 1 3 0} {4 1 5 0} {2 0 1 0}\
        {6 0 1 1} {0 0 7 0} {2 1 7 1} {7 0 6 0} {4 0 6 1}}
   } {{2 0} {0 0}}}
   verified_ambiguities $NW1 $NW2 -signatures
} -result {{12 17 4 2 3 0 0} 1} -output ""
%</test>
% \end{tcl}
% 
% \begin{proc}[alpha]{trimAndQuote}
%   This procedure is called upon by the tracing facilities in 
%   AlphaTcl to format commands for display in traces. The $250$ 
%   characters limit imposed by the default definition is insufficient 
%   for debugging |ambiguities|, on top of which its truncation of 
%   the string often leaves the argument woefully unbalanced.
%   
%   This definition elides all lines but the first and last in a 
%   multi-line argument (typically a body for a control structure) 
%   and presents everything else in full.
%   \begin{tcl}
%<*alpha&debug>
proc alpha::trimAndQuote {arg} {
    set L [split $arg \n\r]
    if {[llength $L] > 1} then {
	return "[lindex $L 0]\u2039[expr {[llength $L]-2}]\
          lines\u203A[lindex $L end]"
    } else {
	return $arg
    }
}
%</alpha&debug>
%   \end{tcl}
% \end{proc}
% 
% 
% \section{Enriched networks}
% 
% While the pure networks of the previous section capture the essence 
% of a graphic \PROP\ expression, there is a lot of useful information 
% that one might want to store with networks which however cannot fit 
% in this simple definition. Rich networks provides a framework within 
% which one may store such additional information, without causing 
% problems for the algebraic processing of networks.
% 
% \begin{tcl}
namespace eval network::rich {}
% \end{tcl}
% \setnamespace{network::rich}
% 
% The general framework is that an enriched network is a dictionary, 
% where each entry contains some particular kind of information about 
% the whole. The central part is the 
% \describestring[rich entry]{pure}|pure| entry, which is the pure 
% network that the other entries enrich. Many other entries reuse 
% labels in this network as indices, which means renumbering the |pure| 
% entry in a rich network in general requires corresponding changes 
% also in many other entries.
% 
% Many procedures operating on rich networks can do so both by value 
% and by reference. When they operate by value, they take the network 
% as argument and return a modified network. When they operate by 
% reference, they instead require the network to have been unrolled 
% into an array in the calling context and modify the contents of 
% this array directly. When such procedures accept a variable number 
% of options and values, a common pattern is that there are two 
% options
% \begin{ttdescription}
%   \item{-val} 
%     The rich network to set vertex positions in. If this 
%     option is provided and the command updates the network in some 
%     way, then the return value will be the updated network.
%   \item{-var} 
%     The name of an array in the calling context into 
%     which the rich network has been unrolled. If |-val| is not 
%     given then |-var| must be. Any modifications of the network will 
%     be performed directly in the array and there is probably no 
%     particular return value.
% \end{ttdescription}
% 
% One very useful entry is that which keeps track of vertex positions 
% for the purpose of drawing the network. The entry in question is 
% called |vpos-Tk|, and is a list of coordinate pairs with one pair 
% per vertex. The suffix |-Tk| is a hint that the coordinate system 
% used is that of the Tk |canvas| (i.e., the positive $y$ axis points 
% downwards).
% 
% A similar entry is 
% \describestring[rich entry]{ecurve-Tk-tt}|ecurve-Tk-tt|, which 
% contains coordinates for the edges as a Tk canvas |line| item with 
% |-smooth true| settings. The entry itself is a list with one element 
% per edge (indexed by edge label) and each element is the actual list 
% of coordinates. Alternatively, an 
% \describestring+[rich entry]{ecurve-Tk-raw} entry coordinates for the 
% edges as a Tk canvas |line| item with |-smooth raw| settings (i.e., 
% in terms of cubic curves). The curves need not be equivalent if 
% both entries are present, but both should work for the given vertex 
% positions.
% 
% Of more technical importance is the 
% \describestring[rich entry]{canonical}|canonical| entry. If present, 
% then this is a cache of the canonical form of the |pure| network, to 
% be used as a unique identifier.
% 
% A late addition is the \describestring+[rich entry]{bbox-Tk} entry, 
% which (if set) holds the (nominal) bounding box of the network. 
% This is needed since many drawing targets indirectly require the 
% user to provide this information!
% \changes{2.4}{2009/05/22}{Introducing \texttt{bbox-Tk} entry. 
%   Refactoring code accordingly. (LH)}
% 
% Two things that are \emph{not} put into rich networks are 
% corresponding feedback-lists and information about the graphical 
% representations of vertex types. The reason for this is that these 
% are typically properties that are common for several rich networks 
% and therefore belong at a higher level; if they were to be changed, 
% it is important that the change takes effect simultaneously for all 
% networks in a collection.
% 
% 
% \subsection{Drawing networks}
% 
% The \describestring[rich entry]{vpos-Tk}|vpos-Tk| entry of a rich 
% network holds one coordinate for each vertex. The entry is a list 
% indexed by vertex label and the elements are pairs of Tk $x$- and 
% $y$-coordinates. Canvas coordinates with units are not supported, 
% due to the arithmetic difficulties this would produce.
% 
% The \emph{appearence} of a vertex is determined by its decoration, 
% using information supplied in a separate table. The entries in this 
% table are lists
% \begin{quote}
%   \word{vertex-items} \word{output-offsets} \word{input-offsets}
% \end{quote}
% where the \word{vertex-items} is a list
% \begin{quote}
%   \begin{regblock}[\regplus]\word{item-type} 
%   \word{coordinates-command} \word{options}\end{regblock}
% \end{quote}
% where each triplet specifies one canvas item drawn for this vertex.
% The \word{item-type} is a canvas item type, \word{options} is a 
% list of item options (and pseudooptions) to apply to that item, and 
% \word{coordinates-command} is a command prefix that, when given 
% the position of the vertex as two additional arguments, returns the 
% list of coordinates needed for the canvas item. More precisely the 
% syntax is
% \begin{quote}
%   \meta{coordinates-command} \word{x} \word{y}
% \end{quote}
% where the \meta{coordinates-command} of course may be more than one 
% word. This command is furthermore evaluated in the |network::shape| 
% namespace, which makes it possible to omit namespace qualifiers for 
% commands in that namespace.
% \begin{tcl}
namespace eval network::shape {}
% \end{tcl}
% 
% \begin{proc}[network::shape]{square}
%   The |square| procedure has the syntax
%   \begin{quote}
%     |network::shape::square| \word{half-side} \word{x} \word{y}
%   \end{quote}
%   It returns a list of four numbers, giving the coordinates of two 
%   diagonally opposed corners of a square with center at $(x,y)$ and 
%   whose side is twice the \word{half-side}.
%   \begin{tcl}
proc network::shape::square {r x y} {
   list [expr {$x - $r}] [expr {$y - $r}] [expr {$x + $r}]\
     [expr {$y + $r}]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}[network::shape]{offsets}
%   The |offsets| procedure has the syntax
%   \begin{quote}
%     |network::shape::offsets| \word{offset-pair}\regstar\ ^^A
%     \word{x} \word{y}
%   \end{quote}
%   It returns a list of twice as many numbers as there are 
%   offset-pairs, where each pair of numbers is a sum of $(x,y)$ and 
%   an offset-pair.
%   \begin{tcl}
proc network::shape::offsets {args} {
   set x [lindex $args end-1]
   set y [lindex $args end]
   set res {}
   foreach pair [lrange $args 0 end-2] {
      lappend res [expr {$x + [lindex $pair 0]}]\
        [expr {$y + [lindex $pair 1]}]
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% In general, proper item options begin with a minus (|-|), so all 
% options that don't are assumed to be pseudooptions. The only 
% pseudooption defined so far is 
% \describestring+[pseudooption]{colourable}, which controls how 
% colour is applied to a vertex. The format of this option is a 
% dictionary of options and values, which specifies the default state 
% for the corresponding item (typically |-fill black| or 
% |-outline black|, but this is very item-dependent). When the item 
% is coloured, all these option values are instead set to the target 
% colour.
% 
% \begin{proc}{drawit}
%   The |drawit| procedure draws a network in a canvas (or reasonable 
%   simulation). The call syntax is
%   \begin{quote}
%     |network::rich::drawit| \word{canvas-cmd} 
%     \word{appearance-dict} \word{tag-list} 
%     \begin{regblock}[\regplus]\word{option} 
%     \word{value}\end{regblock}
%   \end{quote}
%   where \word{canvas-cmd} is a command prefix that behaves like a 
%   Tk |canvas| and \word{appearance-dict} is a dictionary that maps 
%   vertex annotations to vertex appearances.
%   
%   The \word{tag-list} is a list of tags that are given to all 
%   canvas items representing parts of the network. In addition, the 
%   tag |vertex|\meta{n} is given to everything that is part of 
%   vertex $n$, the tag |edge|\meta{n} is given to everything that is 
%   part of edge $n$ (currently only one |line| item), and the tag 
%   |part|\meta{n} (where $n$ starts at $0$) is given to the $n$th 
%   canvas item for a particular vertex. These tags are used to 
%   manage updates of positions of items in the network.
%   
%   The available options are
%   \begin{ttdescription}
%     \item[-val] Standard pass-network-by-value option.
%     \item[-var] Standard pass-network-by-variable option.
%     \item[-update]
%       Takes a boolean value, defaults to |0|. If true, all items in 
%       the network are assumed to already exist, and only their 
%       coordinates and options should be updated. If false, create 
%       new canvas items for everything.
%     \item[-origin]
%       Takes a pair of numbers, defaults to |0 0|. The value is the 
%       position in the canvas's coordinate system of the origin of 
%       the network's coordinate system. This option can be used to 
%       graphically offset the network, in particular for situations 
%       where several networks are drawn into the same canvas.
%     \item[-region]
%       Takes as value a region which should be highlighted in the 
%       drawing. Defaults to `|{} {} {}|', i.e., the empty region.
%     \item[-incolour]
%       The colour to use for edges on the in-boundary of the region; 
%       defaults to |blue|.
%     \item[-outcolour]
%       The colour to use for edges on the out-boundary of the region; 
%       defaults to |red|.
%     \item[-midcolour]
%       The colour to use for vertices, internal edges, and in\&out 
%       edges of the region; defaults to |green|.
%   \end{ttdescription}
%   The network specified through the |-val| or |-var| option must 
%   have the |vpos-Tk| and |ecurve-Tk-tt| entries set to suitable 
%   values. This network is not modified, and there is no particular 
%   return value.
%   \changes{2.1}{2008/10/30}{Added support for colouring a region, 
%     and the concept of pseudooptions so that this could be 
%     supported. (LH)}
%   
%   \begin{tcl}
proc network::rich::drawit {canvas appearance tagL args} {
   array set Opt {-update 0 -origin {0 0}\
     -region {{} {} {}} -incolour blue -outcolour red -midcolour green}
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
   foreach {x0 y0} $Opt(-origin) break
   array set Look $appearance
%   \end{tcl}
%   The |Vreg| array has an entry for a vertex if it is in the 
%   region, but the value of that entry is just an empty string. The 
%   |Ereg| array has an entry for an edge if it is on the region 
%   boundary. The value is one of |in|, |out|, and |inout|.
%   \begin{tcl}
   foreach v [lindex $Opt(-region) 0] {set Vreg($v) {}}
   foreach e [lindex $Opt(-region) 2] {append Ereg($e) in}
   foreach e [lindex $Opt(-region) 1] {append Ereg($e) out}
%   \end{tcl}
%   Since it is usually a good idea that vertex boundaries overlap 
%   edge endpoints, the edges are drawn first.
%   \begin{tcl}
   set cLL {}
   set ecolL {}
   foreach L $NW(ecurve-Tk-tt) {
      set cL {}
      foreach {x y} $L {
         lappend cL [expr {$x0+$x}] [expr {$y0+$y}] 
      }
      lappend cLL $cL
      if {[info exists Ereg([llength $ecolL])]} then {
         switch -- $Ereg([llength $ecolL]) in {
            lappend ecolL $Opt(-incolour)
         } out {
            lappend ecolL $Opt(-outcolour)
         } inout {
            lappend ecolL $Opt(-midcolour)
         }
      } elseif {[
         info exists Vreg([lindex $NW(pure) 1 [llength $ecolL] 0])
      ]} then {
         lappend ecolL $Opt(-midcolour)
      } else {
         lappend ecolL black
      }
   }
   if {$Opt(-update)} then {
      set n -1; foreach L $cLL col $ecolL {incr n
         set tag [join [linsert $tagL end "edge$n"] &&]
         uplevel 1 [linsert $canvas end coords $tag $L]
         uplevel 1 [linsert $canvas end itemconfigure $tag -fill $col]
      }
   } else {
      set n -1; foreach L $cLL col $ecolL {incr n
         uplevel 1 [linsert $canvas end create line $L -smooth true\
           -tags [linsert $tagL end "edge$n"] -fill $col]
      }
   }
%   \end{tcl}
%   Drawing the vertices is similar, but one needs an extra loop over 
%   the item-parts.
%   \begin{tcl}
   set nsshape [namespace parent]::shape
   set n -1; foreach v [lindex $NW(pure) 0] pos $NW(vpos-Tk) {
      if {[incr n]<2} then {continue}
      set k -1
      foreach {type coordCmd optL} [lindex $Look([lindex $v 0]) 0] {
         incr k
         array set A $optL
         if {[info exists A(colourable)]} then {
            if {[info exists Vreg($n)]} then {
               foreach {opt col} $A(colourable) {
                  set A($opt) $Opt(-midcolour)
               }
            } else {
               foreach {opt col} $A(colourable) {set A($opt) $col}
            }
         }
         set optL [array get A -*]
         array unset A
         if {$Opt(-update)} then {
            set tag [join [linsert $tagL end vertex$n item$k] &&]
            uplevel 1 [linsert $canvas end coords $tag [
               namespace inscope $nsshape $coordCmd\
                 [expr {$x0 + [lindex $pos 0]}]\
                 [expr {$y0 + [lindex $pos 1]}]
            ]]
            uplevel 1 [linsert $canvas end itemconfigure $tag] $optL
         } else {
            set call $canvas
            lappend call create $type [
               namespace inscope $nsshape $coordCmd\
                 [expr {$x0 + [lindex $pos 0]}]\
                 [expr {$y0 + [lindex $pos 1]}]
            ] -tags [linsert $tagL end vertex$n item$k]
            uplevel 1 [eval [list lappend call] $optL]
         }
      }
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}[]{tclAE_wish}
%   This is a small procedure I use to experiment with the graphical 
%   parts of the program in a development environment where I cannot 
%   |package require Tk|. The idea is to start Wish as a 
%   separate application and then send all canvas commands to be 
%   evaluated there, while keeping the rest of the processing where I 
%   can easily monitor it. If |.c| is a canvas in Wish then I can use 
%   |tclAE_wish .c| as \word{canvas} above and have everything work 
%   out the way I want it.
%   \begin{tcl}
%<*alpha>
proc tclAE_wish {args} {
  tclAE::build::resultData -t 30000 'WiSH' misc dosc ----\ 
    [tclAE::build::TEXT $args]
}
%</alpha>
%   \end{tcl}
% \end{proc}
% 
% The \word{output-offsets} and \word{input-offsets} elements in a 
% vertex appearance are lists of lists with the structure
% \begin{quote}
%   \word{x-ofs} \word{y-ofs} 
%   \begin{regblock}[\regopt]\word{dir-x} \word{dir-y}\end{regblock}
% \end{quote}
% The \word{x-ofs} and \word{y-ofs} make up the offset from the vertex 
% position to the point where an edge is attached to it, i.e., the 
% endpoint of the |line| object that represents the edge. The 
% \word{dir-x} and \word{dir-y} make up a vector in the direction of 
% the edge from that point. If omitted, \word{dir-x} defaults to $0$ 
% and \word{dir-y} defaults to $1$ or $-1$ for output and input edges 
% respectively. These items are typically not used in drawing 
% networks, but rather when computing graphical representations for 
% edges, however it is natural to keep all of them in the same data 
% structure.
% 
% \begin{variable}[]{Hopf_appearance}
%   This variable is a dictionary of appearances for vertex types 
%   that may occur in calculations related to Hopf algebras. |m| is 
%   the multiplication, |unit| the unit, |Delta| the coproduct, 
%   |epsilon| the counit, |S| the antipode, and |twist| an abstract 
%   twist operation.
%   \begin{tcl}
%</pkg>
%<*Hopf>
set Hopf_appearance {
   m {
      {oval {square 8} {colourable {-outline black}}} 
      {{0 8}}
      {{-5.657 -5.657 -1 -1} {5.657 -5.657 1 -1}}
   }
   unit {
      {oval {square 8} {colourable {-outline black}}} 
      {{0 8}}
      {}
   }
   Delta {
      {oval {square 8} {colourable {-outline black}}} 
      {{-5.657 5.657 -1 1} {5.657 5.657 1 1}}
      {{0 -8}}
   }
   epsilon {
      {oval {square 8} {colourable {-outline black}}}
      {}
      {{0 -8}}
   }
   S {
      {rectangle {square 8} {colourable {-outline black}}} 
      {{0 8}}
      {{0 -8}}
   }
   twist {
      {oval {square 8} {colourable {-outline black}}
       line {square 5.657} {colourable {-fill black}} 
       line {offsets {5.657 -5.657} {-5.657 5.657}}\
         {colourable {-fill black}}} 
      {{-5.657 5.657 -1 1} {5.657 5.657 1 1}}
      {{-5.657 -5.657 -1 -1} {5.657 -5.657 1 -1}}
   }
}
%</Hopf>
%<*pkg>
%   \end{tcl}
% 
% \end{variable}
% 
% 
% \begin{proc}{draw_feedbacks}
%   This procedure is not really specific to rich networks, but it is 
%   placed here since it is a natural partner of |drawit|. The call 
%   syntax is
%   \begin{quote}
%     |network::rich::draw_feedbacks| \word{canvas-cmd} 
%     \word{tags} \word{feedbacks} 
%     \begin{regblock}[\regplus]\word{option} 
%     \word{value}\end{regblock}
%   \end{quote}
%   and what it does is that it uses the specified \word{canvas-cmd} 
%   to draw feedbacks for a network, whose exact geometry depends 
%   on the options. These are:
%   \begin{ttdescription}
%     \item[-outx]
%       A list of $x$-coordinates for the outputs of the network. 
%       This option must be given.
%     \item[-inx]
%       A list of $x$-coordinates for the inputs of the network. 
%       This option must be given.
%     \item[-bbox]
%       A bounding box for the network, used for determining where 
%       the feedbacks may be drawn: below, to the left of, and above 
%       this box. If this option is not given the |bbox| subcommand 
%       of the \word{canvas-cmd} will be used to return the relevant 
%       data.
%     \item[-origin]
%       The canvas coordinates for the origin of the network 
%       coordinate system. All options above specify data in the 
%       network coordinate system. Defaults to |0 0|.
%     \item[-style]
%       List of options and values for the |line| items drawn for the 
%       feedbacks. Defaults to |-dash -| (dashed line). An alternative 
%       might be |-fill #888| (grey line).
%     \item[-legsep]
%       Typical distance (horizontally and vertically) between two 
%       legs. Defaults to $8$.
%     \item[-margin]
%       Distance between |-bbox| and innermost feedback leg. Defaults 
%       to double the |-legsep|.
%     \item[-outermargin]
%       Distance between outermost feedback leg and reported bounding 
%       box. Defaults to half the |-legsep|.
%   \end{ttdescription}
%   The return value is a bounding box for the material drawn.
%   
%   A feedback consists of three parts: (i)~an outleg part, which goes 
%   from the end of the out-leg to a point to the left of the 
%   network; (ii)~a switching part, which appears to the left of the 
%   network and goes from the bottom side to the top side; and 
%   (iii)~an inleg part, which goes from a point to the left of the 
%   network to the end of the in-leg. Lines may only cross in the 
%   switching part.
%   The items created get the tags in |tagL| and the additional tag 
%   |feedback|. The parts that correspond to one particular leg also 
%   get the additional tag |in|\meta{$k$} or |out|\meta{$k$} as 
%   appropriate.
%   
%   Initially, there is quite a lot of argument processing to handle 
%   all the options and their defaults.
%   \begin{tcl}
proc network::rich::draw_feedbacks {canvas tagL feedbackL args} {
   array set Opt {-legsep 8 -origin {0 0} -style {-dash -}}
   array set Opt $args
   if {![info exists Opt(-outx)]} then {
      error "Must specify -outx list"
   } elseif {![info exists Opt(-inx)]} then {
      error "Must specify -inx list"
   }
   foreach {x0 y0} $Opt(-origin) break
   set inL {}
   foreach x $Opt(-inx) {lappend inL [expr {$x+$x0}]}
   set outL {}
   foreach x $Opt(-outx) {lappend outL [expr {$x+$x0}]}
   if {[info exists Opt(-bbox)]} then {
      foreach  var {left top right bottom}  t $Opt(-bbox) \
        d [list $x0 $y0 $x0 $y0]  {set $var [expr {$t+$d}]}
   } else {
      foreack {left top right bottom} [
         $canvas bbox [join $tagL &&]
      ] break
   }
   if {![llength $feedbackL]} then {
      return [list $left $top $left $bottom]
   }
   if {![info exists Opt(-margin)]} then {
      set Opt(-margin) [expr {2*$Opt(-legsep)}]
   }
   if {![info exists Opt(-outermargin)]} then {
      set Opt(-outermargin) [expr {0.5*$Opt(-legsep)}]
   }
%   \end{tcl}
%   Processing proper begins by determining which inputs and outpus 
%   are at all involved in a feedback.
%   \begin{tcl}
   [namespace parent]::setconstlist  useIL 0 $Opt(-inx) \
     useOL 0 $Opt(-outx)
   foreach fb $feedbackL {
      lset useOL [lindex $fb 0] 1
      lset useIL [lindex $fb 1] 1
   }
%   \end{tcl}
%   In-leg and out-leg parts are only drawn for those legs that are 
%   involved in feedbacks. |in2L| and |out2L| are lists of 
%   $x$-coordinates for the points to the left of the network where 
%   feedback parts attach to in-leg and out-leg respectively. 
%   Coordinates for the bounding box are computed as a side-effect.
%   \begin{tcl}
   set left1 [expr {$left - $Opt(-margin)}]
   set top1 [expr {$top - $Opt(-margin)}]
   set in2L {}
   foreach x $inL u $useIL {
      if {$u} then {
         set call $canvas
         lappend call create line $x $top $x $top1 $left1 $top1 $left1\
           $top -tags [linsert $tagL end feedback "in[llength $in2L]"]
         uplevel 1 $call [lrange $Opt(-style) 0 end]
         lappend in2L $left1
         set left1 [expr {$left1 - $Opt(-legsep)}]
         set top1 [expr {$top1 - $Opt(-legsep)}]
         set right1 $x
      } else {
         lappend in2L ""
      }
   }
   set left0 [expr {$left - $Opt(-margin)}]
   set bottom0 [expr {$bottom + $Opt(-margin)}]
   set out2L {}
   foreach x $outL u $useOL {
      if {$u} then {
         set call $canvas
         lappend call create line $x $bottom $x $bottom0 $left0\
           $bottom0 $left0 $bottom\
           -tags [linsert $tagL end feedback "out[llength $out2L]"]
         uplevel 1 $call [lrange $Opt(-style) 0 end]
         lappend out2L $left0
         set left0 [expr {$left0 - $Opt(-legsep)}]
         set bottom0 [expr {$bottom0 + $Opt(-legsep)}]
         set right0 $x
      } else {
         lappend out2L ""
      }
   }
%   \end{tcl}
%   Once the endpoints are known, drawing the switching parts is 
%   straightforward.
%   \begin{tcl}
   foreach fb $feedbackL {
      set call $canvas
      lappend call create line [lindex $out2L [lindex $fb 0]] $bottom\
        [lindex $in2L [lindex $fb 1]] $top\
        -tags [linsert $tagL end feedback]
      uplevel 1 $call [lrange $Opt(-style) 0 end]
   }
   set d [expr {$Opt(-legsep) - $Opt(-outermargin)}]
   return [list [
      expr {($left0>$left1 ? $left1 : $left0) + $d}
   ] [
      expr {$top1 + $d}
   ] [
      expr {($right0>$right1 ? $right0 : $right1) + $Opt(-outermargin)}
   ] [
      expr {$bottom0 - $d}
   ]]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{draw_brackets}
%   This is another procedure that doesn't mention rich networks in 
%   any way but still constitutes a natural partner of |drawit|. It 
%   is typically used to draw brackets around a network to package it 
%   as an item that can be used in a formula.
%   
%   The call syntax is
%   \begin{quote}
%     |network::rich::draw_brackets| \word{canvas-cmd} \word{tags}
%     \begin{regblock}[\regstar]\word{option} 
%     \word{value}\end{regblock}
%   \end{quote}
%   where \word{canvas-cmd} is a command prefix (with the same 
%   interface as a canvas) that will be used to do the actual 
%   drawing. \word{tags} is a list of tags that will be given to the 
%   items drawn, in addition the fixed tag |bracket|. The 
%   \word{option}s supported are
%   \begin{ttdescription}
%     \item[-bbox]
%       The bounding box of the items to bracket. If this option is 
%       omitted, then the |bbox| subcommand of \word{canvas-cmd} is 
%       used to obtain this information.
%     \item[-inch]
%       The length of a nominal inch, in the coordinate system of the 
%       \word{canvas-cmd}; this affects how thick the bracket stems 
%       should be. The default value is $72.0$. In the case of a Tk 
%       canvas, |[winfo fpixels |\word{canvas}| 1i]| computes the 
%       right value.
%     \item[-blacker]
%       A number of pixels (typically between $0$ and $1$) by which 
%       the width of stems should be increased before rounding. 
%       Defaults to $0.0$.
%     \item[-delimitershortfall]
%       This is how much shorter than the bounding box the brackets 
%       may be. The value is given in \TeX\ points (see below) and 
%       should be \emph{negative} if you want the brackets to be 
%       taller than the network. The default is $-5.0$. [Check 
%       appearance]
%     \item[-delimiterfactor]
%       This is a lower bound on the height of the brackets in the 
%       unit of the height of the bounding box. For historical 
%       reasons, the default is $0.901$.
%     \item[-operation]
%       This option controls which operation is performed. It 
%       defaults to |draw|, which means actually draw the brackets, 
%       but it can also be |width| or |bbox|, in which case nothing 
%       is drawn but the size of the brackes are determined. In the 
%       case of the |width| operation, the return value is also 
%       changed to be the width (in \word{canvas-cmd} units) of one 
%       of the brackets that would have been drawn. This can be used 
%       to determine how much space to reserve for the backets before 
%       positioning that which the brackets should surround.
%       \changes{2.3}{2009/03/29}{Added \texttt{bbox} operation. (LH)}
%   \end{ttdescription}
%   The return value is the bounding box of the brackets, which is 
%   not tight; bounding boxes for adjacent items should probably 
%   be set to touch this bounding box.
%   
%   The appearance of the brackets closely follows the \TeX\ font 
%   \texttt{cmex10}~\cite{CMfonts}\Ldash even down to the 
%   discretisation adjustments\Dash and size of the brackets is 
%   chosen as \TeX's |\left| and |\right| primitives would (except 
%   the normal size brackets are not considered, as they reside in a 
%   different font). In particular this means that many quantities 
%   have \TeX\ points ($1/72.27$ inches) as units rather than pixels, 
%   and following the MetaFont tradition these have names ending in 
%   |#|~(sharp). Some variable names even end in |.u#|, which means 
%   the quantity is a multiple of the basic design unit \(u\SH = 
%   20/36\,\mathrm{pt}\); it's easier to introduce this factor in a 
%   calculation than to incorporate it in a constant list of values.
%   
%   Variable names below often have curious names to reflect 
%   their MetaFont origin. 
%   The main unit for this part of the design is |dh#|, 
%   which is specified as ``60\% of the design size'', i.e., 
%   $6\,\mathrm{pt}$.
%   \begin{tcl}
proc network::rich::draw_brackets {canvasCmd tagL args} {
   array set Opt {-inch 72.0  -delimitershortfall -5.0 \
     -delimiterfactor 0.901  -blacker 0.0  -operation draw}
   array set Opt $args
   if {![info exists Opt(-bbox)]} then {
      set Opt(-bbox) [uplevel 1 [linsert $canvasCmd end bbox\
        [join $tagL &&]]]
   }
%   \end{tcl}
%   The first part selects the bracket size, which is one of |\big|, 
%   |\Big|, |\bigg|, |\Bigg|, or extensible. |bh#| is the nominal 
%   height of the bracket character. |bw.u#| is the basic width of a 
%   bracket character. |aw.u#| is additional leading added (using 
%   \textbf{adjust\_fit}) to the outer side of the bracket. |th| is 
%   a parameter determining the thickness of the bracket by 
%   linearly interpolating between $\mathit{rule\_thickness}$ and 
%   $\mathit{stem}$.
%   \begin{tcl}
   foreach {left top right bottom} $Opt(-bbox) break
   set hppp [expr {$Opt(-inch)/72.27}]
   set h# [expr {($bottom - $top)/$hppp}]
   foreach bh# {12 18 24 30 infinity} \
         bw.u# {6 6.5 7 7.5 8} \
         aw.u# {1.5 2 2.5 3 4} \
            th {0 0.25 0.5 0.75 1} {
      if {${bh#} >= ${h#} - $Opt(-delimitershortfall) && \
          ${bh#} >= ${h#} * $Opt(-delimiterfactor)} then {break}
   }
   if {${bh#} eq "infinity"} then {
      set bh# [expr {${h#} - $Opt(-delimitershortfall)}]
      if {${bh#} < ${h#} * $Opt(-delimiterfactor)} then {
         set bh# [expr {${h#} * $Opt(-delimiterfactor)}]
      }
   }
%   \end{tcl}
%   Now we get to the pixel measurements, which are what the return 
%   value is all about. To that end, it is useful to make a list of 
%   font parameters and their values.
%   \begin{longtable}{r@{${}={}$}l}
%     \textit{letter\_fit}\SH& $0$\,pt\\
%     \textit{letter\_fit}& $0$\\
%     \textit{shrink\_fit}& $1$
%   \end{longtable}
%   \textit{shrink\_fit} is a rather curious parameeter, which behind 
%   the scenes is subtracted from the glyph pixel width while the 
%   glyph is being drawn, and then added back before the glyph is 
%   shipped out. Anyhow, these are what affect the width, so we now 
%   know enough to handle the |width| operation. Since the right 
%   bracket has its $x$ origin in a known position (|right|), it is 
%   easier to get actual coordinates for this glyph and then mirror 
%   them when drawing the left bracket.
%   \begin{tcl}
   set r [expr {round((${aw.u#}+${bw.u#})*20/36.0*$hppp)}]
   if {$Opt(-operation) eq "width"} then {return $r}
   set w [expr {$r - round(${aw.u#}*20/36.0*$hppp) - 1}]
   set u [expr {$w/${bw.u#}}]
%   \end{tcl}
%   In the MetaFont program, the \textit{shrink\_fit} is subtracted 
%   already from $r$ (and then added back at the very end), but since 
%   the value of $r$ anyway isn't used until it is time to determine 
%   the width, it can be left in a ``pure'' state. The calculation of 
%   $u$ can be found in the \textbf{do\_expansion} macro, which is 
%   called from \textbf{adjust\_fit}.
%   
%   Next comes the calculation of the bracket thickness. This is 
%   determined by a couple of additional parameters:
%   \begin{longtable}{r@{${}={}$}l}
%     \textit{rule\_thickness}\SH& $0.4$\,pt\\
%     \textit{rule\_thickness}& $\lceil 0.4 \mathit{hppp}\rceil$\\
%     \textit{stem}\SH& $25/36$\,pt\\
%     \textit{stem}& $[\mathit{stem}\SH \cdot \mathit{hppp} + 
%       \mathit{blacker}]$
%   \end{longtable}
%   At typical screen resolutions, both of them will be $1$, which 
%   means the bracket thickness is independent of the size, but the 
%   extra complexity doesn't hurt much.
%   \begin{tcl}
   set thickness [expr { round(
      (1-$th)*ceil(0.4*$hppp) +
      $th*round($hppp*25/36.0 + $Opt(-blacker))
   )}]
%   \end{tcl}
%   There are three $x$-coordinates which are relevant: $x_{1r}$ 
%   (outer side of bracket), $x_{1l}$ (inner side of bracket), and 
%   $x_4$ (end of tips).
%   \begin{tcl}
   set x1r [expr {round($w - 2.5*$u + 0.5*$thickness)}]
   set x1l [expr {$x1r - $thickness}]
   set x4  [expr {round(0.75*$u - 0.5*$thickness)}]
%   \end{tcl}
%   The relevant $y$-coordinates are $y_1$ (top), $y_2$ (bottom), 
%   $y_{4l}$ (inner side of top tip), and $y_{6r}$ (inner side of 
%   bottom tip). Exact rounding of these would be rather complicated, 
%   since it involves also sharp calculations made in \TeX\ and 
%   rounding in the DVI viewer. What I do here is that I find the 
%   sharp top and bottom positions for the bracket and then round 
%   them separately. The separate rounding happens also in the 
%   MetaFont case, but the integer coordinates to which one rounds 
%   need not reside in the same places. One feature of the MetaFont 
%   code that has been kept is that the bracket is shrunk by one 
%   pixel at the bottom side.
%   \begin{tcl}
   set mid [expr {0.5*($top+$bottom)}]
   set y1 [expr {round($mid - 0.5*${bh#}*$hppp)}]
   set y2 [expr {round($mid + 0.5*${bh#}*$hppp) - 1}]
   set y4l [expr {$y1 + $thickness}]
   set y6r [expr {$y2 - $thickness}]
%   \end{tcl}
%   The actual drawing is done by \textbf{fill}ing a |polygon|, 
%   unlike the MetaFont code which \textbf{filldraw}s three strokes. 
%   The reasons for this change are (i)~that it's actually possible 
%   to specify the outline in this case, as the pen has size $0$, and 
%   (ii)~that restrictions in the |canvas| make it impossible to 
%   position lines with more than pixel precision anyway (an odd 
%   width line conceptually fills half pixels at the sides).
%   \begin{tcl}
   if {$Opt(-operation) eq "draw"} then {
      lappend canvasCmd create polygon
      set optL [list -tags [linsert $tagL end bracket] \
        -fill black  -outline ""]
      uplevel 1 $canvasCmd [
         list [expr {$right+$x4}] $y2  [expr {$right+$x1r}] $y2 \
           [expr {$right+$x1r}] $y1  [expr {$right+$x4}] $y1 \
           [expr {$right+$x4}] $y4l  [expr {$right+$x1l}] $y4l \
           [expr {$right+$x1l}] $y6r [expr {$right+$x4}] $y6r
      ] $optL
      uplevel 1 $canvasCmd [
         list [expr {$left-$x4}] $y2  [expr {$left-$x1r}] $y2 \
           [expr {$left-$x1r}] $y1  [expr {$left-$x4}] $y1 \
           [expr {$left-$x4}] $y4l  [expr {$left-$x1l}] $y4l \
           [expr {$left-$x1l}] $y6r [expr {$left-$x4}] $y6r
      ] $optL
   }
%   \end{tcl}
%   Finally construct the bounding box to return.
%   \begin{tcl}
   list [expr {$left-$r}] $y1 [expr {$right+$r}] [expr {$y2+1}]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{drawit_bracketed}
%   This is a conveniency wrapper around the |drawit| and 
%   |draw_brackets| procedures, which additionally provides the 
%   feature of anchoring the drawn material to a point, thus making 
%   the origin of the network's own coordinate system irrelevant. The 
%   call syntax is
%   \begin{displaysyntax}
%     |network::rich::drawit_bracketed| \word{canvas-cmd} 
%     \word{appearance-dict} \word{x} \word{y} 
%     \begin{regblock}[\regstar]\word{option} 
%     \word{value}\end{regblock}
%   \end{displaysyntax}
%   where the first two arguments are as for the |drawit| 
%   procedure, and \word{x} and \word{y} are the coordinates where 
%   the network should be drawn. The return value is the bounding 
%   box of the material that was drawn.
%   
%   \changes{2.3}{2009/03/29}{Command added. (LH)}
%   
%   The primary options supported are:
%   \begin{ttdescription}
%     \item[-val] Standard pass-network-by-value option.
%     \item[-var] Standard pass-network-by-variable option.
%     \item[-bracket]
%       Should the network be bracketed (boolean)? Defaults to true.
%     \item[-anchor]
%       The anchoring position, i.e., where the given point $(x,y)$ 
%       should be relative to the network. This is like a standard Tk 
%       |-anchor| option, and can take the values |n|, |ne|, |e|, 
%       |se|, |s|, |sw|, |w|, |nw|, and |center|. It also takes the 
%       nonstandard value |origin| (default), in which case $(x,y)$ 
%       is at the origin of the network coordinate system.
%     \item[-uselayout]
%       This is a boolean and defaults to true. In that case, it 
%       specifies that the network bounding box can be taken from the 
%       |level-layout-Tk| entry rather than computed from the 
%       |vpos-Tk| and |ecurve-Tk-tt| entries, as would anyway be done 
%       if the |level-layout-Tk| entry is missing.
%     \item[-tags]
%       The list of tags to use; defaults to being empty.
%   \end{ttdescription}
%   Besides these, all options are passed on to the two underlying 
%   procedures, although some may be overridden (e.g.~|-var|, |-val|, 
%   |-origin|, and |-bbox|).
%   
%   First, the boilerplate for option handling.
%   \begin{tcl}
proc network::rich::drawit_bracketed {canvas appearance x0 y0 args} {
   array set Opt {
      -bracket 1  -anchor origin  -uselayout 1  -tags {}
   }
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
      unset Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
%   \end{tcl}
%   Second, the computation of a bounding box for anchoring.
%   \begin{tcl}
   set xL {}
   set yL {}
   if {$Opt(-uselayout) && [info exists NW(level-layout-Tk)]} then {
      foreach {component bbox} $NW(level-layout-Tk) {
         lappend xL [lindex $bbox 0] [lindex $bbox 2]
         lappend yL [lindex $bbox 1] [lindex $bbox 3]
      }
   } else {
      foreach edge $NW(ecurve-Tk-tt) {
         foreach {x y} $edge {
            lappend xL $x
            lappend yL $y
         }
      }
      set ns [namespace parent]::shape
      array set Look $appearance
      foreach  pair [lrange $NW(vpos-Tk) 2 end] \
        vertex [lrange [lindex $NW(pure) 0] 2 end]  {
         foreach {type cmd opts} [lindex $NW([lindex $vertex 0]) 0] {
            foreach {x y} [eval $cmd $pair] {
               lappend xL $x
               lappend yL $y
            }
         }
      }
   }
   if {![llength $xL]} then {lappend xL 0.0 1.0}
   if {![llength $yL]} then {lappend yL 0.0 1.0}
   set xL [lsort -real $xL]
   set yL [lsort -real $yL]
   set bbox0 [list [lindex $xL 0] [lindex $yL 0] [lindex $xL end]\
     [lindex $yL end]]
   if {$Opt(-bracket)} then {
      foreach {x y} [eval\
        [list draw_brackets {error "Shouldn't happen"} {}]\
        [array get Opt] [list -var NW -bbox $bbox0 -operation bbox]] {
         lappend xL $x
         lappend yL $y
      }
      set xL [lsort -real $xL]
      set yL [lsort -real $yL]
      set bbox [list [lindex $xL 0] [lindex $yL 0] [lindex $xL end]\
        [lindex $yL end]]
   } else {
      set bbox $bbox0
   }
%   \end{tcl}
%   With the bounding box in network-coordinates known, it is 
%   possible to compute the origin of that coordinate system.
%   \begin{tcl}
   switch -- $Opt(-anchor) {
      nw - w - sw {
         set x0 [expr {$x0 - [lindex $bbox 0]}]
      }
      ne - e - se {
         set x0 [expr {$x0 - [lindex $bbox 2]}]
      }
      n - center - s {
         set x0 [expr {$x0 - 0.5*[lindex $bbox 0] - 0.5*[lindex $bbox 2]}]
      }
      origin {}
      default {
         return -code error "Unknown -anchor: $Opt(-anchor)"
      }
   }
   switch -- $Opt(-anchor) {
      nw - n - ne {
         set y0 [expr {$y0 - [lindex $bbox 1]}]
      }
      w - center - e {
         set y0 [expr {$y0 - 0.5*[lindex $bbox 1] - 0.5*[lindex $bbox 3]}]
      }
      sw - s - se {
         set y0 [expr {$y0 - [lindex $bbox 3]}]
      }
      origin {}
      default {
         return -code error "Unknown -anchor: $Opt(-anchor)"
      }
   }
%   \end{tcl}
%   And with that, it's finally time to get drawing.
%   \begin{tcl}
   eval [list drawit $canvas $appearance $Opt(-tags)]\
     [array get Opt] [list -var NW -origin [list $x0 $y0]]
   set bbox1 {}
   foreach {x y} $bbox0 {
      lappend bbox1 [expr {$x+$x0}] [expr {$y+$y0}]
   }
   if {$Opt(-bracket)} then {
      set xL {}
      set yL {}
      foreach {x y} [concat $bbox1 [
         eval [list draw_brackets $canvas $Opt(-tags)]\
          [array get Opt] [list -var NW -operation draw -bbox $bbox1]
      ]] {
         lappend xL $x
         lappend yL $y
      }
      set xL [lsort -real $xL]
      set yL [lsort -real $yL]
      return [list [lindex $xL 0] [lindex $yL 0] [lindex $xL end]\
        [lindex $yL end]]
   } else {
      return $bbox1
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Level layout}
% \label{Ssec:Layout}
% 
% The level layout for networks is based on a decomposition of the 
% network into components and the components into levels, such as 
% that computed by |network::pure::graded_components|: all items in a 
% level are put side-by-side, different levels are stacked on top of 
% each others, and different components are put side-by-side. It is 
% expected that this will become the primary layout for networks, even 
% though the rich network data structure allows any number of 
% alternative layouts.
% 
% The description of a layout is kept in the
% \describestring[rich entry]{level-layout-Tk}|level-layout-Tk| entry 
% of a network. In overall appearance this is similar to a list of 
% graded components, but there are extra elements all over that encode 
% graphical information. The lowest level is a list
% \begin{quote}
%   \begin{regblock}[\regstar]\word{component} \word{bbox}\end{regblock}
% \end{quote}
% where the first \word{component} must contain all inputs and outputs, 
% but the order is otherwise arbitrary. A \word{bbox} is a list
% \begin{quote}
%   \word{left} \word{top} \word{right} \word{bottom}
% \end{quote}
% of the four Tk coordinates of the boundary of the \word{component}.
% 
% A \word{component} is a list
% \begin{quote}
%   \begin{regblock}[\regstar]\word{level} \word{y-pos} 
%   \word{half-height}\end{regblock}
% \end{quote}
% where \word{y-pos} is the $y$-coordinate for the corresponding 
% \word{level} and \word{half-height} is how far below and above this 
% position that the level is considered to extend (the extent is 
% presumed to be symmetrical). A \word{level} is a list of items, 
% which have one of the following two forms:
% \begin{quote}
%   |vertex| \word{label} \word{x-pos}\\
%   |edge| \word{label} \word{x-pos}
% \end{quote}
% The levels are ordered from output to input side of the network. The 
% first and last \word{level} of the first component corresponds to the 
% output and input vertices respectively, but the items in these levels 
% are |edge|s enumerating the corresponding legs. (This arrangement is 
% motivated by the special role of the output and input vertices as 
% mere placeholders: even though they exist internally, they should not 
% be included in presentations of networks.) Empty extremal levels in 
% components other than the first may be omitted, but they can also be 
% included and left empty.
% 
% \begin{variable}{level-layout-Tk_defaults}
%   The |make_level-layout-Tk| procedure that normally constructs the 
%   |level-layout-Tk| entry in a rich network takes a great variety of 
%   options. Defaults for many of these options are kept in the 
%   |level-layout-Tk_defaults| variable, which is a dictionary. This 
%   allows centralised configuration of graphical details without 
%   having to modify every piece of code which might need to call 
%   |make_level-layout-Tk|.
%   
%   \begin{tcl}
namespace eval network::rich {variable level-layout-Tk_defaults {
   -padx 10  -pady 16
%   \end{tcl}
%   Extra space inserted between items in a level and between levels, 
%   respectively. Half these amounts are also inserted at the edges 
%   of the network for the calculation of the bounding box, with the 
%   exception of |-pady| in the first component.
%   \begin{tcl}
   -edgew 5  -edgeh 10
%   \end{tcl}
%   The nominal width and height respectively of an edge in a level.
%   \begin{tcl}
   -vsizes {* {20 20}}
%   \end{tcl}
%   This option is a \word{vertex-sizes} lists, as explained below. 
%   It is not used by the classical procedures (which instead have a 
%   mandatory argument for this if they need it), but the experience 
%   so far has been that this default is never changed, so newer 
%   procedures will rather perfer to have an option for this.
%   \changes{2.7}{2012/05/14}{\texttt{-vsizes} default added. (LH)}
%   \begin{tcl}
   -haligncmd align_active_midpoints
%   \end{tcl}
%   This is a command prefix used to align levels horisontally. It 
%   has the call syntax
%   \begin{quote}
%     \meta{haligncmd} \word{pure network} \word{below-level} 
%     \word{above-level}
%   \end{quote}
%   where the last two arguments are preliminary levels in the 
%   \word{pure network} for which an alignment should be computed. 
%   The items in these levels have the slightly modified forms
%   \begin{quote}
%     |vertex| \word{label} \word{left} \word{right}\\
%     |edge| \word{label} \word{left} \word{right}
%   \end{quote}
%   where the \word{left} and \word{right} are preliminary 
%   $x$-coordinates for the left and right sides of the area reserved 
%   for the item; the final position is the average of these two 
%   positions. The return value is the number which should be added to 
%   the positions in the \word{above-level} to make that level line up 
%   with the \word{below-level}. The command name is resolved from 
%   within the |network::rich| namespace.
%   
%   \begin{tcl}
   -anchor nw
%   \end{tcl}
%   This is like a standard Tk |-anchor| option, and can take the 
%   values |n|, |ne|, |e|, |se|, |s|, |sw|, |w|, |nw|, and |center|. 
%   These points are relative to the bounding box of the entire 
%   network, and what is specified is the point which will be at 
%   coordinates $(0,0)$. The default |nw| is to make it maximally 
%   likely that the network is visible if drawn in a nonscrolled 
%   canvas.
%   
%   The |-seqcmd| option is by default not initialised. This is, as in 
%   |network:|\discretionary{}{}{}|:pure:|\discretionary{}{}{}^^A
%   |:order_graded_components|, the command prefix used to find an 
%   ordering of items within a level. Not giving a value for this 
%   means to use the default of |order_graded_components|.
%   \begin{tcl}
}}
%   \end{tcl}
% \end{variable}
% 
% 
% \begin{proc}{Tk_from_pure}
%   This procedure takes a pure network as argument and returns a 
%   corresponding rich network enriched with the Tk-graphical entries 
%   |level-layout-Tk|, |bbox-Tk|, |vpos-Tk|, and |ecurve-Tk-tt|. 
%   The procedure is basically a conveniency wrapper around the three 
%   procedures |make_level-layout-Tk|, |vpos-Tk_by_level|, and 
%   |ecurve-Tk-tt_by_level| typically used to compute these things.
%   
%   \changes{2.3}{2009/03/29}{Command added. (LH)}
%   
%   The call syntax is
%   \begin{displaysyntax}
%     |network::rich::Tk_from_pure| \word{pure network}
%     \word{vertex-sizes} \word{appearance-dict} 
%     \begin{regblock}[\regstar] \word{option} \word{value} 
%     \end{regblock}
%   \end{displaysyntax}
%   where the \word{option} \word{value} pairs are passed on to 
%   |make_level-layout-Tk|, as is the \word{vertex-sizes}. The 
%   \word{appearance-dict} is passed on to |ecurve-Tk-tt_by_level|.
%   \begin{tcl}
proc network::rich::Tk_from_pure {NW vSizes vApp args} {
   set A(pure) $NW
   make_level-layout-Tk $vSizes {*}$args -var A
   vpos-Tk_by_level -var A
   ecurve-Tk-tt_by_level $vApp -var A
   return [array get A]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{align_active_midpoints}
%   This procedure implements the default mode of aligning 
%   neighbouring levels within a network to each other. The call 
%   syntax is
%   \begin{quote}
%     |align_active_midpoints| \word{pure network} 
%     \word{below-level} \word{above-level}
%   \end{quote}
%   where \word{below-level} and \word{above-level} have the format 
%   described with the |-haligncmd| option above.
%   The idea is to compute for each level the interval on the 
%   $x$-axis in which there are items which connect to the other 
%   level, and then align the midpoints of these intervals.
%   
%   \begin{tcl}
proc network::rich::align_active_midpoints {NW belowL aboveL} {
   foreach {min max} {min0 max0 min1 max1}  sideidx {2 1} \
     levelL [list $belowL $aboveL] {
      set $min infinity
      set $max !
      foreach item $levelL {
         foreach {type label l r} $item break
         if {$type eq "edge"  || \
           $type eq "vertex" &&\
             [llength [lindex $NW 0 $label $sideidx]]>0} then {
            if {$r > [set $max]} then {set $max $r}
            if {$l < [set $min]} then {set $min $l}
         }
      }
   }
   if {$min0 != "infinity"} then {
      return [expr {0.5*($max0+$min0 - $max1-$min1)}]
%   \end{tcl}
%   If that branch was not taken, there was no connection between the 
%   two levels. A midpoint alignment is then computed based on all 
%   items, and in case one of the levels hasn't got any items, the 
%   return value is $0$.
%   \begin{tcl}
   } elseif {[llength $belowL] && [llength $aboveL]} then {
      return [expr {0.5*([lindex $belowL end 3]+[lindex $belowL 0 2]\
        - [lindex $aboveL end 3]-[lindex $aboveL 0 2])}]
   } else {
      return 0
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{make_level-layout-Tk}
%   This procedure constructs a |level-layout-Tk| entry, and also a 
%   |bbox-Tk| entry, for a network from its underlying |pure| network 
%   and extra data provided through options. The call syntax is
%   \begin{quote}
%     |network::rich::make_level-layout-Tk| \word{vertex-sizes} 
%     \begin{regblock}[\regplus]\word{option} \word{value}\end{regblock}
%   \end{quote}
%   where \word{vertex-sizes} is a list with the structure
%   \begin{quote}
%     \begin{regblock}[\regplus]\word{pattern} \word{size}\end{regblock}
%   \end{quote}
%   where \word{pattern} is a |string match| pattern to match against a 
%   vertex annotation and \word{size} is a pair of width and height for 
%   vertices with such annotations. A match is sought from start to 
%   end; it is an error if no match is found.
%   
%   The available \word{option}s, in addition to those documented 
%   with the |level-layout-Tk_defaults| above, are:
%   \begin{ttdescription}
%     \item[-val] Standard pass-network-by-value option.
%     \item[-var] Standard pass-network-by-variable option.
%     \item[-levellist]
%       If specified, this is a list indexed by vertex labels, giving 
%       the level (counting from $0$ at the output) of each vertex. 
%       If not given, |graded_components| uses its default for this.
%       The level of the input vertex must be larger than the level 
%       of any other vertex in its component, similarly the level of 
%       the output vertex must be lower than that of any other vertex.
%     \item[-componentlist]
%       If specified, this is a list of components, where each 
%       component is an flat list of items (i.e., there is no level 
%       grading). If not given, |graded_components| uses its default 
%       for this.
%     \item[-prehints]
%       Early hints for relative order of items (`|vertex |$v$', 
%       `|edge |$e$~\textit{level}').
%     \item[-prehints]
%       Late hints for relative order of items (`|vertex |$v$', 
%       `|edge |$e$~\textit{level}').
%   \end{ttdescription}
%   
%   The first order of business is to interpret options and defaults.
%   \begin{tcl}
proc network::rich::make_level-layout-Tk {vsizes args} {
   variable level-layout-Tk_defaults
   array set Opt ${level-layout-Tk_defaults}
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
%   \end{tcl}
%   The second step is to compute the ordered graded component 
%   decomposition of the network.
%   \begin{tcl}
   set call [list [namespace parent]::pure::ordered_graded_components]
   foreach opt {
      -levellist -componentlist -orderchunk -prehints -posthints
   } {
      if {[info exists Opt($opt)]} then {
         lappend call $opt $Opt($opt)
      }
   }
   set grCompL [eval [lappend call $NW(pure)]]
   if {[lindex $grCompL 0 0] ne "{vertex 0}"  || \
     [lindex $grCompL 0 end] ne "{vertex 1}"} then {
      error "Bad level for external vertex"
   }
   set L {}
   foreach e [lindex $NW(pure) 0 0 2] {lappend L [list edge $e]}
   lset grCompL 0 0 $L
   set L {}
   foreach e [lindex $NW(pure) 0 1 1] {lappend L [list edge $e]}
   lset grCompL 0 end $L
%   \end{tcl}
%   The third step rebuilds the decomposition in the general form of 
%   a layout. However, the level items contain two $x$-coordinates 
%   (for boundaries of the item rather than its midpoint) and the 
%   different components most probably have overlapping $x$-coordinates. 
%   Empty levels are discarded, as are empty components, unless we're 
%   in the first component.
%   \begin{tcl}
   set layout {}
   foreach part $grCompL {
      set comp {}
      set left infinity; set right !
      set y 0
      foreach piece $part {
         set level {}
         set x 0
         set h 0
         foreach item $piece {
            set x [expr {$x + $Opt(-padx)}]
            switch -- [lindex $item 0] "vertex" {
               set annot [lindex $NW(pure) 0 [lindex $item 1] 0]
               if {![info exists Size($annot)]} then {
                  foreach {pat size} $vsizes {
                     if {[string match $pat $annot]} then {
                        set Size($annot) $size
                        break
                     }
                  }
                  if {![info exists Size($annot)]} then {
                     error "No vertex size specified for: $annot"
                  }
               }
               if {$h < [lindex $Size($annot) 1]} then {
                  set h [lindex $Size($annot) 1]
               }
               lappend item $x
               set x [expr {$x + [lindex $Size($annot) 0]}]
               lappend item $x
               lappend level $item
            } "edge" {
               if {$h < $Opt(-edgeh)} then {set h $Opt(-edgeh)}
               lappend item $x
               set x [expr {$x + $Opt(-edgew)}]
               lappend item $x
               lappend level $item
            }
         }
         if {![llength $level] && [llength $layout]} then {continue}
         set dx [eval [linsert $Opt(-haligncmd) end $NW(pure)\
           [lindex $comp end-2] $level]]
         set L {}
         foreach item $level {
            foreach {type label l r} $item break
            lappend L [list $type $label [expr {$l+$dx}] [expr {$r+$dx}]]
         }
         set level $L
         if {[llength $level]} then {
            if {$left > [lindex $level 0 2]} then {
               set left [lindex $level 0 2]
            }
            if {$right < [lindex $level end 3]} then {
               set right [lindex $level end 3]
            }
         }
         lappend comp $level [expr {$y - 0.5*$h}] [expr {0.5*$h}]
         set y [expr {$y - $h - $Opt(-pady)}]
      }
      if {$left == "infinity"} then {
         set left 0; set right 0
      } else {
         set left [expr {$left - 0.5*$Opt(-padx)}]
         set right [expr {$right + 0.5*$Opt(-padx)}] 
      }
      if {[llength $comp]} then {
         lappend layout $comp [list\
           $left [expr {$y + 0.5*$Opt(-pady)}]\
           $right [expr {0.5*$Opt(-pady)}]]
      }
   }
   lset layout 1 1 [lindex $layout 0 end-1]
   lset layout 1 3 [lindex $layout 0 1]
%<debug>   puts $layout
%   \end{tcl}
%   The fourth step rebuilds the preliminary layout in finished form, 
%   offsetting components so that they won't overlap. First a list 
%   |wOfsL| with the structure
%   \begin{quote}
%     \begin{regblock}[\regplus]\word{x-ofs} 
%     \word{y-ofs}\end{regblock}
%   \end{quote}
%   that expresses the differences for each component between the 
%   prelimary position and the position for the network if anchored 
%   |w|. This also computes the |top|, |right|, and |bottom| 
%   coordinates for the total bounding box in that position, whereas 
%   the left coordinate of course is $0$.
%   \changes{2}{2007/02/22}{Added \texttt{-anchor} option. (LH)}
%   \begin{tcl}
   set wOfsL {}
   set right 0
   set top 0; set bottom 0
   foreach {tcomp bbox} $layout {
      set dx [expr {$right - [lindex $bbox 0]}]
      set dy [expr {-0.5*([lindex $bbox 1]+[lindex $bbox 3])}]
      lappend wOfsL $dx $dy
      if {$top > [lindex $bbox 1]+$dy} then {
         set top [expr {[lindex $bbox 1]+$dy}]
      }
      if {$bottom < [lindex $bbox 3]+$dy} then {
         set bottom [expr {[lindex $bbox 3]+$dy}]
      }
      set right [expr {$dx + [lindex $bbox 2]}]
   }
%   \end{tcl}
%   Secondary offsets |dx2| and |dy2| are computed to correspond to 
%   the |-anchor| value.
%   \begin{tcl}
   switch -- $Opt(-anchor) "center" - "e" - "w" {
      set dy2 0
   } "n" - "ne" - "nw" {
      set dy2 [expr {-$top}]
   } "s" - "sw" - "se" {
      set dy2 [expr {-$bottom}]
   } default {
      error "Bad -anchor value"
   }
   switch -- $Opt(-anchor) "w" - "nw" - "sw" {
      set dx2 0
   } "e" - "ne" - "se" {
      set dx2 [expr {-$right}]
   } "s" - "n" - "center" {
      set dx2 [expr {-0.5$right}]
   } default {
      error "Bad -anchor value"
   }
%   \end{tcl}
%   Finally the layout is rebuilt and the updated network is returned, 
%   if needed.
%   \begin{tcl}
   set NW(level-layout-Tk) {}
   set xL {}; set yL {}
   foreach {tcomp bbox} $layout {dx dy} $wOfsL {
      set dx [expr {$dx+$dx2}]
      set dy [expr {$dy+$dy2}]
      set ncomp {}
      foreach {tlevel ypos h} $tcomp {
         set nlevel {}
         foreach item $tlevel {
            lappend nlevel [lreplace $item 2 end [
               expr {$dx + 0.5*([lindex $item 2]+[lindex $item 3])}
            ]]
         }
         lappend ncomp $nlevel [expr {$ypos + $dy}] $h
      }
      set L {}
      foreach {x y} $bbox {
         lappend L [expr {$x+$dx}] [expr {$y+$dy}]
      }
      lappend NW(level-layout-Tk) $ncomp $L
      foreach {x y} $L {lappend xL $x; lappend yL $y}
   }
   if {[llength $xL]} then {
      set xL [lsort -real $xL]; set yL [lsort -real $yL]
      if {[lindex $xL 0] == [lindex $xL end]} then {
         lappend xL [expr {1 + [lindex $xL end]}]
      }
      if {[lindex $yL 0] == [lindex $yL end]} then {
         lappend yL [expr {1 + [lindex $yL end]}]
      }
      set NW(bbox-Tk) [list [lindex $xL 0] [lindex $yL 0]\
        [lindex $xL end] [lindex $yL end]]
   } else {
      set NW(bbox-Tk) {0.0 0.0 1.0 1.0}
   }
   if {[info exists Opt(-val)]} then {
      return [array get NW]
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{vpos-Tk_by_level}
%   This procedure sets the |vpos-Tk| entry of a network to the 
%   coordinates found in the |level-layout-Tk| entry.
%   The call syntax is
%   \begin{quote}
%     |network::rich::vpos-Tk_by_level| 
%     \begin{regblock}|-val| \word{network}\regalt
%     |-var| \word{array-name}\end{regblock}
%   \end{quote}
%   where the two options have their standard interpretation.
%   \begin{tcl}
proc network::rich::vpos-Tk_by_level {style val} {
   switch -- $style "-val" {
      array set NW $val
   } "-var" {
      upvar 1 $val NW
   } default {
      error "Must specify -val or -var"
   }
   [namespace parent]::setconstlist C {- -} [lindex $NW(pure) 0]
   foreach {comp bbox} $NW(level-layout-Tk) {
      foreach {level y h} $comp {
         foreach item $level {
            foreach {type label x} $item break
            if {$type eq "vertex"} then {lset C $label [list $x $y]}
         }
      }
   }
   set NW(vpos-Tk) $C
   if {$style eq "-val"} then {return [array get NW]}
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ecurve-Tk-tt_by_level}
%   This procedure sets the |ecurve-Tk-tt| entry of a network using 
%   the coordinates found in the |level-layout-Tk| entry and a 
%   vertex appearance table. The call syntax is
%   \begin{quote}
%     |network::rich::ecurve-Tk-tt_by_level| \word{appearance}
%     \begin{regblock}|-val| \word{network}\regalt
%     |-var| \word{array-name}\end{regblock}
%   \end{quote}
%   where the two options have their standard interpretation and 
%   \word{appearance} is a dictionary mapping vertex annotations,
%   \begin{tcl}
proc network::rich::ecurve-Tk-tt_by_level {dict style val} {
   switch -- $style "-val" {
      array set NW $val
   } "-var" {
      upvar 1 $val NW
   } default {
      error "Must specify -val or -var"
   }
   array set Look $dict
%   \end{tcl}
%   The procedure first goes through the entire layout and records 
%   $x$-coordinates, $y$-coordinates, and half-heights in the array 
%   |Node| that has indices on the forms |vertex |\word{n} and 
%   |edge |\word{n}. The entries are flat lists with the structure
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{$x$} \word{$y$} 
%     \word{$h/2$}\end{regblock}
%   \end{quote}
%   and the first triplet corresponds to the occurrence of this item 
%   that is closest to the output.
%   \begin{tcl}
   foreach {comp bbox} $NW(level-layout-Tk) {
      foreach {level y h} $comp {
         foreach item $level {
            lappend Node([lrange $item 0 1]) [lindex $item 2] $y $h
         }
      }
   }
%   \end{tcl}
%   The next step is to compute the actual edge coordinates, for each 
%   edge in sequence. The curve that is constructed has one control 
%   point in each level that the edge encounters and two control 
%   points between two levels, which are used to determine tangents 
%   for the curve. The vertical position is $y+h$ for the control 
%   point below a level at position $y$ that has half-height $h$ and 
%   similarly $y-h$ for the control point above this level. 
%   Horizontal positions are chosen to get the wanted tangents.
%   
%   The loop first constructs coordinates for levels where the edge 
%   is mentioned, as if those are levels which the edge pass through. 
%   Then adjustments are made at the ends, either inserting 
%   coordinates for the attachment to a vertex, or removing the extra 
%   coordinate pair just past the end of a leg.
%   \begin{tcl}
   set res {}
   foreach e [lindex $NW(pure) 1] {
      set L {}
      foreach {x y h} [lappend "Node(edge [llength $res])"] {
         lappend L $x [expr {$y+$h}] $x $y $x [expr {$y-$h}]
      }
      if {[lindex $e 0] >= 2} then {
         foreach {x y h} $Node(vertex [lindex $e 0]) break
         set look $Look([lindex $NW(pure) 0 [lindex $e 0] 0])
         foreach {dx1 dy1 dx2 dy2} [
            linsert [lindex $look 2 [lindex $e 1]] end 0 -1
         ] break
         set L [linsert $L 0 [expr {$x+$dx1}] [expr {$y+$dy1}]\
           [expr {$x+$dx1 - $dx2*($dy1+$h)/$dy2}] [expr {$y-$h}]]
      } else {
         set L [lreplace $L 0 1]
      }
      if {[lindex $e 2] >= 2} then {
         foreach {x y h} $Node(vertex [lindex $e 2]) break
         set look $Look([lindex $NW(pure) 0 [lindex $e 2] 0])
         foreach {dx1 dy1 dx2 dy2} [
            linsert [lindex $look 1 [lindex $e 3]] end 0 1
         ] break
         lappend L [expr {$x+$dx1 + $dx2*($h-$dy1)/$dy2}]\
           [expr {$y+$h}] [expr {$x+$dx1}] [expr {$y+$dy1}]
      } else {
         set L [lreplace $L end-1 end]
      }
      lappend res $L
   }
   set NW(ecurve-Tk-tt) $res
   if {$style eq "-val"} then {return [array get NW]}
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{ecurve-Tk-raw_by_level}
%   This procedure sets the |ecurve-Tk-raw| entry of a network using 
%   the coordinates found in the |level-layout-Tk| entry and a 
%   vertex appearance table. The call syntax is
%   \begin{quote}
%     |network::rich::ecurve-Tk-raw_by_level| \word{appearance}
%     \begin{regblock}[\regplus] \word{option} \word{value} 
%     \end{regblock}
%   \end{quote}
%   where \word{appearance} is a dictionary mapping vertex 
%   annotations to appearances. The supported options are |-val| and 
%   |-var| with their standard interpretations, and |-hscale| which 
%   takes a numeric factor as value. That factor is multiplied by the 
%   height of a pass-through level, so it can be used to control the 
%   length of the line segments there; it defaults to |0.5|.
%   \begin{tcl}
proc network::rich::ecurve-Tk-raw_by_level {dict args} {
   array set Opt {-hscale 0.5}
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
   array set Look $dict
%   \end{tcl}
%   The procedure first goes through the entire layout and records 
%   $x$-coordinates, $y$-coordinates, and half-heights in the array 
%   |Node| that has indices on the forms |vertex |\word{n} and 
%   |edge |\word{n}. The entries are flat lists with the structure
%   \begin{quote}
%     \begin{regblock}[\regstar]\word{$x$} \word{$y$} 
%     \word{$h/2$}\end{regblock}
%   \end{quote}
%   and the first triplet corresponds to the occurrence of this item 
%   that is closest to the output.
%   \begin{tcl}
   foreach {comp bbox} $NW(level-layout-Tk) {
      foreach {level y h} $comp {
         foreach item $level {
            lappend Node([lrange $item 0 1]) [lindex $item 2] $y\
              [expr {$h*$Opt(-hscale)}]
         }
      }
   }
%   \end{tcl}
%   The next step is to compute the actual edge coordinates, for each 
%   edge in sequence. The curve has one straight line segment for 
%   each level being passed through and one curve segment for each 
%   space between two levels.
%   The basic approach for the curve segments is to use the MetaFont 
%   formula for the case that knots and tangents at knots are given, 
%   though with some extra tension to avoid certain inflexions. This 
%   is computed by the |MetaFont_controls| helper procedure.
%   \changes{2.6}{2011/01/21}{Not using \texttt{atleast} for MetaFont 
%     controls, as it could lead to control points being very close 
%     to their knots. The results look better without it! (LH)}
%   
%   Internal edges have one curve segment more than they got 
%   pass-through levels (i.e., triplets in their |Node| entry), so 
%   one can compute most segments in a loop over the |Node| entry, 
%   and then compute the final segment outside the loop. This is 
%   basically what is done, but a number of complications have to be 
%   dealt with:
%   \begin{itemize}
%     \item
%       Each |Node| entry contributes both to the end of the previous 
%       segment and to the beginning of the next, so it is necessary 
%       to remember some data (|x0|, |y0|, and |ofs0|) from the 
%       previous iteration. This data is initialised according to the 
%       head vertex, and the extra segment uses data about the tail 
%       vertex.
%     \item
%       Between two segments, there is a straight line segment which 
%       is generated by repeating the last pair of coordinates from 
%       the previous curve segment and the first pair of coordinates 
%       from the next curve segment. However, that repetition should 
%       only take place when there was a previous curve segment (|L| 
%       is nonempty).
%     \item
%       When the head vertex is $0$ or the tail vertex is $1$, then 
%       the first or last respectively curve segment is missing, so 
%       it is necessary to check for those cases explicitly.
%   \end{itemize}
%   \begin{tcl}
   set res {}
   foreach e [lindex $NW(pure) 1] {
      set L {}
      set v [lindex $e 0]
      if {$v>1} then {
         foreach {x0 y0} $Node(vertex $v) break
         set ofs0 [lindex $Look([lindex $NW(pure) 0 $v 0]) 2 [lindex $e 1]]
         lappend ofs0 0 -1
      }
      foreach {x y h} [lappend "Node(edge [llength $res])"] {
         if {$v<=1} then {
            set v 2
         } else {
            set seg\
              [MetaFont_controls $x0 $y0 $ofs0 $x $y [list 0 $h 0 1] 0 1]
            if {[llength $L]} then {
               set seg [concat\
                 [lrange $L end-1 end] [lrange $seg 0 1] $seg]
            }
            eval [list lappend L] $seg
         }
         set x0 $x; set y0 $y
         set ofs0 [list 0 [expr {-$h}] 0 -1]
      }
      set v [lindex $e 2]
      if {$v>1} then {
         foreach {x y} $Node(vertex $v) break
         set ofs [lindex $Look([lindex $NW(pure) 0 $v 0])\
           1 [lindex $e 3]]
         lappend ofs 0 1
         set seg [MetaFont_controls $x0 $y0 $ofs0 $x $y $ofs 0 1]
         if {[llength $L]} then {
            set seg [concat [lrange $L end-1 end] [lrange $seg 0 1] $seg]
         }
         eval [list lappend L] $seg
      }
      lappend res $L
   }
   set NW(ecurve-Tk-raw) $res
   if {[info exists Opt(-val)]} then {return [array get NW]}
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{MetaFont_controls}
%   This procedure computes knot and control points for a cubic curve 
%   segment, when the endpoints and tangents at those points are given. 
%   The call syntax is
%   \begin{displaysyntax}
%     |MetaFont_controls| \word{$X_0$} \word{$Y_0$} \word{offset-0}
%     \word{$X_3$} \word{$Y_3$} \word{offset-3} \word{atleast} 
%     \word{no-$y$-stationary}
%   \end{displaysyntax}
%   and the return value is the list
%   \begin{displaysyntax}
%     \word{$x_0$} \word{$y_0$} \word{$x_1$} \word{$y_1$}
%     \word{$x_2$} \word{$y_2$} \word{$x_3$} \word{$y_3$}
%   \end{displaysyntax}
%   of coordinates for the curve segment.
%   
%   The two \word{offset-$k$} arguments are lists that contain most 
%   of the information defining the curve; they have the structure
%   \begin{displaysyntax}
%     \word{$\Delta x$} \word{$\Delta y$} \word{$v_x$} \word{$v_y$}
%   \end{displaysyntax}
%   where $(\Delta x,\Delta y)$ is the offset to the knot point 
%   $(x_k,y_k)$ from the \emph{reference point} $(X_k,Y_k)$. 
%   $(v_x,v_y)$ is a tangent vector (at the knot in question) to 
%   the curve segment; its length is irrelevant. The \word{atleast} 
%   argument is a boolean for whether the curve tension should be 
%   `atleast $1$' rather than just~$1$. The \word{no-$y$-stationary} 
%   argument is another boolean which causes the tensions to be 
%   increased to avoid stationary points for the $y$-component of the 
%   curve parametrisation.
%   
%   (\textit{set\_controls} procedure)
%   \begin{tcl}
proc network::rich::MetaFont_controls {X0 Y0 ofs0 X3 Y3 ofs3 atleast\
  nostationary} {
   set x0 [expr {$X0 + [lindex $ofs0 0]}]
   set y0 [expr {$Y0 + [lindex $ofs0 1]}]
   set x3 [expr {$X3 + [lindex $ofs3 0]}]
   set y3 [expr {$Y3 + [lindex $ofs3 1]}]
%   \end{tcl}
%   The knots are straightforward, but the control points are 
%   tricky. Basically, the points chosen by MetaFont at tension~$1$ 
%   are
%   \begin{align*}
%     (x_1,y_1) ={}& (x_0,y_0) + 
%       \mathbf{e}_0 f(\theta,\phi) \lvert\mathbf{z}\rvert 
%       \text{,}\\
%     (x_2,y_2) ={}& (x_3,y_3) + 
%       \mathbf{e}_3 f(\phi,\theta) \lvert\mathbf{z}\rvert 
%   \end{align*}
%   where $\mathbf{e}_0$ is the inward unit tangent vector at 
%   $(x_0,y_0)$, $\mathbf{e}_3$ is the inward unit tangent vector at 
%   $(x_3,y_3)$, \(\mathbf{z} = (x_3,y_3) - (x_0,y_0)\), and the 
%   factors $f(\theta,\phi)$ and $f(\phi,\theta)$ respectively are 
%   heuristics developed by John Hobby to make the curves look as 
%   good as possible.
%   \begin{tcl}
   set v0 [expr {hypot( [lindex $ofs0 2], [lindex $ofs0 3] )}]
   set e0x [expr { [lindex $ofs0 2] / $v0 }]
   set e0y [expr { [lindex $ofs0 3] / $v0 }]
   set v3 [expr {hypot( [lindex $ofs3 2], [lindex $ofs3 3] )}]
   set e3x [expr { [lindex $ofs3 2] / $v3 }]
   set e3y [expr { [lindex $ofs3 3] / $v3 }]
   set zx [expr {$x3 - $x0}] ; set zy [expr {$y3 - $y0}]
   set z [expr {hypot($zx,$zy)}]
%   \end{tcl}
%   The numbers $\theta$ and $\phi$ are the angles from $\mathbf{z}$ 
%   to $\mathbf{e}_0$ and from $\mathbf{e}_3$ to $-\mathbf{z}$ 
%   respectively. The definition of $f$ is
%   $$
%     f(\theta,\phi) = \frac{
%       2 + \sqrt{2}\,(\sin\theta - \frac{1}{16}\sin\phi)
%         (\sin\phi-\frac{1}{16}\sin\theta) (\cos\theta-\cos\phi)
%     }{
%       3\,\bigl(1 + \frac{1}{2}(\sqrt{5}-1)\cos\theta + 
%         \frac{1}{2}(3-\sqrt{5}\,)\cos\phi\bigr)
%     }
%     \text{.}
%   $$
%   
%   \begin{tcl}
   set pt [expr {$zx*$e0x + $zy*$e0y}]
   set ct [expr {$pt / $z}]
   set pp [expr {-($zx*$e3x + $zy*$e3y)}]
   set cp [expr {$pp / $z}]
   set st [expr {($zx*$e0y - $zy*$e0x) / $z}]
   set sp [expr {($zx*$e3y - $zy*$e3x) / $z}]
   set numer1 [expr {sqrt(2)*($st-$sp/16)*($sp-$st/16)*($ct-$cp)}]
   set ftpz [expr {$z * (2+$numer1) /\
     (1.5*( 2 + (sqrt(5)-1)*$ct + (3-sqrt(5))*$cp ))}]
   set fptz [expr {$z * (2-$numer1) /\
     (1.5*( 2 + (sqrt(5)-1)*$cp + (3-sqrt(5))*$ct ))}]
%   \end{tcl}
%   Since |ftpz| and |fptz| are actual lengths, their bounds in the 
%   `atleast' case can be computed using the sine theorem:
%   \[
%     \frac{\sin Z}{z} = 
%     \frac{\sin \lvert\theta\rvert}{t} = 
%     \frac{\sin \lvert\phi\rvert}{p}
%   \]
%   where \(Z = \pi - \lvert\theta\rvert - \lvert\phi\rvert\), $t$ is 
%   the bound for |fptz|, and $p$ is the bound for |ftpz|.
%   \begin{tcl}
   if {$atleast && ($st>0 && $sp>0 || $st<0 && $sp<0)} then {
      set sinZ [expr {abs($st)*$cp + $ct*abs($sp)}]
      set t [expr {$z/$sinZ*abs($st)}]
      set p [expr {$z/$sinZ*abs($sp)}]
      if {$ftpz > $p} then {set ftpz $p}
      if {$fptz > $t} then {set fptz $t}
   }
%   \end{tcl}
%   The no-$y$-stationary feature is based on the observation that
%   $$
%     y(t) = 3a (1-t)^2 t + 3(b-a) (1-t) t^2 + b t^3
%   $$
%   which goes from \(y(0)=0\) to \(y(1)=b\) lacks stationary points 
%   for \(0 < a < b\) but develops one at \(t=\frac{1}{2}\) when 
%   \(a=b\) and goes non-increasing if \(a>b\). The curve computed 
%   above may well venture outside the \(0<a<b\) domain if the angles 
%   $\theta$ and $\phi$ get large enough.
%   
%   The idea is to constrain \(q = a/b\) to the range 
%   $\mathopen{]}-1,1\mathclose{[}$ by changing this factor to 
%   $\tanh q$; this has minimal effect for \(\lvert q\rvert < 0.5\), 
%   and is nicely monotonous.
%   \begin{tcl}
   if {$nostationary && abs($zy)>1} then {
      set q [expr {$e0y*$ftpz / $zy}]
      set ftpz [expr {$ftpz * tanh($q)/$q}]
      set q [expr {$e3y*$fptz / $zy}]
      set fptz [expr {$fptz * tanh($q)/$q}]
   }
   set x1 [expr {$x0 + $e0x*$ftpz}] ; set y1 [expr {$y0 + $e0y*$ftpz}] 
   set x2 [expr {$x3 + $e3x*$fptz}] ; set y2 [expr {$y3 + $e3y*$fptz}] 
   list $x0 $y0 $x1 $y1 $x2 $y2 $x3 $y3
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Elastic edges}
% 
% [The following was first done in version 1 of the \textsf{network} 
% code, but ultimately the spring-type heuristics for networks turned 
% out to not be as good as folklore suggests they are for graphs\Dash 
% apparently it makes a considerable difference whether the edges 
% point in fixed directions or can rotate freely. The only thing that 
% the elastic model turned out to be noticably good at was finding a 
% nice shape for edges once the positions of vertices were known, so 
% I have kept that. The argument leading up to the procedure should 
% however still be of interest.]
% 
% The problem of automatically finding a nice way to draw a graph in 
% the plane has generated a substantial body of 
% literature~\cite{GraphDrawingBibl}, and it turns out that in most 
% cases the problem of finding the \emph{best} (with respect to some 
% reasonable criteria) way to draw a graph is NP-hard. 
% There are however plenty of useful heuristic methods around.
% 
% One of the most popular heuristics, originally due to Eades, is to 
% consider the graph as a physical system, where the edges are replaced by 
% springs and the vertex positions are chosen so that the system is in 
% equilibrium. Finding an equilibrium configuration is in general easy, 
% since a simulation (with some kind of ``friction'') of the system 
% will in general quickly approach and come to rest at some equilibrium. 
% As is often the case in graph theory, such physical models demonstrate 
% an unreasonable usefulness.
% 
% In the network situation, where edges are curves rather than straight 
% lines, it probably makes more sense to think of them as strings made 
% from some elastic material than to think of them as actual springs. 
% The physical law governing their behaviours would be the same in both 
% cases, but it is easier to justify the calculations below in a truly 
% continuous model.
% 
% The relevant physical law for elasticity in this case is \emph{Hooke's 
% law}
% \begin{equation} \label{Eq:Hooke}
%   \sigma = E \varepsilon 
%   \qquad\text{where}\qquad 
%   \varepsilon = \frac { \mathit{\Delta l} }{ l }
%   \text{,}
% \end{equation}
% which relates the tension $\sigma$ to the relative elongation 
% $\varepsilon$ of the string, via the \emph{elasticity coefficient} $E$ 
% of the material. However in this particular problem it is more 
% convenient to relate $\varepsilon$ to the amount of energy that is 
% stored in the string (or equivalently: the amount of energy it took 
% to deform the string), as reasoning about energy is often much simpler 
% than reasoning about forces. In this case the relevant formula is
% \begin{equation}
%   W = k \varepsilon^2
% \end{equation}
% as follows from \eqref{Eq:Hooke} by integration over $\mathit{\Delta l}$. 
% (The constant \(k = \frac{1}{2} EAl\), where $A$ is the cross-section 
% area of the string and the factor $\frac{1}{2}$ comes from the 
% integration.)
% 
% Since it is given that each edge will have the shape of a parametric 
% curve $\mathbf{r}(t)$ for \(t \in [t_1,t_2]\), it is close at hand to 
% adopt the parameter $t$ as being proportional to the natural length of 
% the string. In this case, $\varepsilon$ need not be constant along the 
% string, but varies with parametric speed so that \(\bigl( 1 +\nobreak 
% \varepsilon(t) \bigr) v_0 = v(t)\), where \(v(t) = \bigl\vert 
% \mathbf{v}(t) \bigr\vert\), \(\mathbf{v}(t) = \mathbf{r}'(t)\), and 
% $v_0$ is the parametric speed for the string at its natural length. 
% Consequently
% \begin{equation} \label{Eq:ElastiskEnergi}
%   W = k \int_{t_1}^{t_2} \varepsilon(t)^2 \,\mathit{dt} =
%   \frac{k}{v_0^2} \int_{t_1}^{t_2} \bigl( v(t) - v_0 \bigr)^2 
%   \,\mathit{dt}
% \end{equation}
% is the relevant quantity to consider.
% 
% As a first step, one may consider what shape the edges should assume 
% if endpoints and endpoint tangents are given. The answer is that they 
% should assume a shape with minimal energy, i.e., a shape for which 
% the integral
% \begin{equation} \label{Eq:Kant-energi}
%   \int_{t_1}^{t_2} \bigl( v(t) - v_0 \bigr)^2 \,\mathit{dt}
% \end{equation}
% is minimal. Since the edge curve $\mathbf{r}(t)$ is a |-smooth true| 
% canvas curve defined by four points $\mathbf{z}_0$, $\mathbf{z}_1$, 
% $\mathbf{z}_2$, and $\mathbf{z}_3$, it is most easily expressed in 
% terms of Bern\v{s}te\u{\i}n polynomials. For any \(n \in \mathbb{N}\) 
% and $a_0,\dotsc,a_n$ define
% \begin{equation}
%   B_n(a_0,\dotsc,a_n; t) =
%   \sum_{k=0}^n \binom{n}{k} (1-t)^{n-k} t^k a_k \text{.}
% \end{equation}
% Then by definition of |-smooth true| curves,
% \begin{equation*}
%   \mathbf{r}(t) = \begin{cases}
%     B_2( \mathbf{z}_0, \mathbf{z}_1, \tfrac{1}{2}\mathbf{z}_1 + 
%       \tfrac{1}{2}\mathbf{z}_2; t) &
%       \text{if \(0 \leqslant t \leqslant 1\),}\\
%     B_2( \tfrac{1}{2}\mathbf{z}_1 + \tfrac{1}{2}\mathbf{z}_2, 
%       \mathbf{z}_2, \mathbf{z}_3; t-1) &
%       \text{if \(1 \leqslant t \leqslant 2\).}
%   \end{cases}
% \end{equation*}
% In general,
% \begin{equation} \label{Eq:Bernstein-diff}
%    \frac{d}{\mathit{dt}} B_n(a_0,\dotsc,a_n; t) =
%    B_{n-1}(a_1-a_0,\dotsc,a_n-a_{n-1}; t)
% \end{equation}
% and consequently
% \begin{equation*}
%   \mathbf{v}(t) = \begin{cases}
%     2B_1( \mathbf{z}_1 - \mathbf{z}_0 , 
%       \tfrac{1}{2}\mathbf{z}_2 - \tfrac{1}{2}\mathbf{z}_1; t) &
%       \text{if \(0 \leqslant t \leqslant 1\),}\\
%     2B_1( \tfrac{1}{2}\mathbf{z}_2 - \tfrac{1}{2}\mathbf{z}_1, 
%       \mathbf{z}_3 - \mathbf{z}_2; t-1) &
%       \text{if \(1 \leqslant t \leqslant 2\).}
%   \end{cases}
% \end{equation*}
% Since
% \begin{multline*}
%   \bigl\vert B_1(\mathbf{a}_0,\mathbf{a}_1;t) \bigr\vert^2 =
%   \bigl< B_1(\mathbf{a}_0,\mathbf{a}_1;t), 
%     B_1(\mathbf{a}_0,\mathbf{a}_1;t) \bigr> = \\ =
%   \bigl< (1-t) \mathbf{a}_0, (1-t) \mathbf{a}_0 \bigr> + 
%     \bigl< (1-t) \mathbf{a}_0, t \mathbf{a}_1 \bigr> + 
%     \bigl< t \mathbf{a}_1, (1-t) \mathbf{a}_0 \bigr> + 
%     \bigl< t \mathbf{a}_1, t \mathbf{a}_1 \bigr> = \\ =
%   B_2\bigl( \lvert\mathbf{a}_0\rvert^2, 
%     \langle \mathbf{a}_0, \mathbf{a}_1\rangle, 
%     \lvert\mathbf{a}_1\rvert^2; t \bigr)
% \end{multline*}
% it follows that
% \begin{equation*}
%   v(t)^2 = \begin{cases}
%     4 B_2\Bigl( \lvert \mathbf{z}_1 - \mathbf{z}_0 \rvert^2, 
%       \tfrac{1}{2} \langle \mathbf{z}_1 - \mathbf{z}_0, 
%         \mathbf{z}_2 - \mathbf{z}_1 \rangle,
%       \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2; 
%       t \Bigr)
%       & \text{if \(0 \leqslant t \leqslant 1\),}\\
%     4 B_2\Bigl( 
%       \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2, 
%       \tfrac{1}{2} \langle \mathbf{z}_2 - \mathbf{z}_1,
%         \mathbf{z}_3 - \mathbf{z}_2 \rangle,
%       \lvert \mathbf{z}_3 - \mathbf{z}_2 \rvert^2; 
%       t-1 \Bigr) &
%       \text{if \(1 \leqslant t \leqslant 2\).}
%   \end{cases}
% \end{equation*}
% 
% From applying \eqref{Eq:Bernstein-diff} backwards one gets
% \begin{equation*}
%   \int B_n(a_0,\dotsc,a_n; t) \, \mathit{dt} =
%   \tfrac{1}{n+1} B_{n+1}( 0, a_0, a_0+a_1, \dotsc, a_0 + a_1 + 
%     \dotsb + a_n; t) + C
% \end{equation*}
% and thus in particular
% \begin{equation*}
%   \int_0^1 B_n(a_0,\dotsc,a_n; t) \, \mathit{dt} =
%   \frac{1}{n+1} \sum_{k=0}^n a_k
%   \text{,}
% \end{equation*}
% whence
% \begin{align*}
%   \int_0^2 v(t)^2 \, \mathit{dt} ={}&
%   \int_0^1 v(t)^2 \, \mathit{dt} + \int_0^1 v(t+1)^2 \, \mathit{dt} 
%     = \\ ={}&
%   \frac{4}{3} \bigl( 
%     \lvert \mathbf{z}_1 - \mathbf{z}_0 \rvert^2 + 
%     \tfrac{1}{2} \langle \mathbf{z}_1 - \mathbf{z}_0, 
%         \mathbf{z}_2 - \mathbf{z}_1 \rangle +
%     \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2
%   \bigr) \\ &\quad {}+
%   \frac{4}{3} \bigl( 
%     \tfrac{1}{4} \lvert \mathbf{z}_2 - \mathbf{z}_1 \rvert^2 +
%     \tfrac{1}{2} \langle \mathbf{z}_2 - \mathbf{z}_1,
%         \mathbf{z}_3 - \mathbf{z}_2 \rangle + 
%     \lvert \mathbf{z}_3 - \mathbf{z}_2 \rvert^2
%   \bigr) = \\ ={}&
%   \frac{4}{3} \bigl( 
%     \lvert \mathbf{z}_1 - \mathbf{z}_0 \rvert^2 + 
%     \lvert \mathbf{z}_3 - \mathbf{z}_2 \rvert^2 + 
%     \tfrac{1}{2} \langle \mathbf{z}_2 - \mathbf{z}_1,
%         \mathbf{z}_3 - \mathbf{z}_0 \rangle
%   \bigr)
%   \text{.}
% \end{align*}
% Writing \(\mathbf{c} = \mathbf{z}_3 - \mathbf{z}_0\), \(r\mathbf{a} = 
% \mathbf{z}_1 - \mathbf{z}_2\), and \(s\mathbf{b} = \mathbf{z}_2 - 
% \mathbf{z}_3\) (because the vectors $\mathbf{a}$, $\mathbf{b}$, and 
% $\mathbf{c}$ are fixed by the endpoint conditions but the scalar 
% factors $r$ and $s$ are not), the difference \(\mathbf{z}_2 - 
% \mathbf{z}_1 = \mathbf{c} + s\mathbf{b} - r\mathbf{a}\) and the above 
% becomes
% \begin{equation} \label{Eq:rs-kant-energi}
%   3\int_0^2 v(t)^2 \, \mathit{dt} =
%   4r^2 \mathbf{a}^2 + 4s^2\mathbf{b}^2 + 2 \mathbf{c}^2 +
%   2s \langle\mathbf{b},\mathbf{c}\rangle 
%   - 2r \langle\mathbf{a},\mathbf{c}\rangle
%   \text{.}
% \end{equation}
% 
% Thus far, things are pretty easy, but that is just one term of 
% \eqref{Eq:Kant-energi}. There is also a trivial term 
% \(\int_0^2 v_0^2\,\mathit{dt} = 2 v_0^2\) and a term
% \begin{equation*}
%   \int_0^2 -2 v_0 v(t) \,\mathit{dt} =
%   -2 v_0 \int_0^2 \sqrt{ \bigl< \mathbf{v}(t), \mathbf{v}(t) \bigr> }
%     \,\, \mathit{dt}
% \end{equation*}
% which is rather difficult due to the square root. 
% 
% As a preparation for the problem with the shape of edges with positive 
% natural length, one may consider the integral
% $$
%   \int_0^1 \sqrt{ (\alpha t - \beta)^2 + 1 } \,\,\mathit{dt}
%   \qquad \text{where \(\alpha > 0\),}
% $$
% which (up to a constant factor) is what \( \int_0^1 v(t)\,dt \) boils 
% down to (for a suitable choice of constants $\alpha$ and $\beta$). 
% One finds that
% \begin{align*}
%   \int_0^1 \sqrt{ (\alpha t - \beta)^2 + 1 } \,\,\mathit{dt} ={}& 
%   \left\{ \begin{aligned}
%     \alpha t - \beta ={}& \sinh u \\
%     u ={}& \operatorname{arsinh}( \alpha t - \beta ) \\
%     t ={}& \alpha^{-1} \sinh u + \beta/\alpha \\
%     \frac{\mathit{dt}}{\mathit{du}} ={}& \alpha^{-1} \cosh u
%   \end{aligned} \right\} 
%     = \\ ={}&
%   \int_{-\operatorname{arsinh}\beta}^{\operatorname{arsinh}(\alpha-\beta)}
%     \alpha^{-1}\cosh^2 u \, \mathit{du} 
%     = \displaybreak[0]\\ ={}&
%   \int_{-\operatorname{arsinh}\beta}^{\operatorname{arsinh}(\alpha-\beta)}
%     \tfrac{1}{2\alpha}\cosh(2u) + \tfrac{1}{2\alpha} \, \mathit{du} 
%     = \displaybreak[0]\\ ={}&
%   \biggl[ \frac{1}{4\alpha} \sinh(2u) + \frac{u}{2\alpha} \biggr]
%     _{u = \operatorname{arsinh}\beta}
%     ^{u = \operatorname{arsinh}(\alpha-\beta)}
%     = \displaybreak[0]\\ ={}&
%   \biggl[ \frac{1}{2\alpha} \sinh u \cosh u + \frac{u}{2\alpha} \biggr]
%     _{u = \operatorname{arsinh}\beta}
%     ^{u = \operatorname{arsinh}(\alpha-\beta)}
%     = \displaybreak[0]\\ ={}&
%   \frac{1}{2\alpha} \Bigl(
%     (\alpha-\beta) \sqrt{ (\alpha-\beta)^2 + 1 } + 
%     \operatorname{arsinh}(\alpha-\beta)
%     \\ & \quad{} - 
%     \beta\sqrt{\beta^2 + 1} -
%     \operatorname{arsinh}\beta
%   \Bigr)
%     = \\ ={}&
%   \frac{1}{2\alpha} \biggl(
%     (\alpha-\beta) \sqrt{ (\alpha-\beta)^2 + 1 } 
%     - \beta\sqrt{\beta^2 + 1}
%     \\ & \quad{}
%     + \operatorname{arsinh} \left( 
%       (\alpha-\beta) \sqrt{\beta^2 + 1} 
%       - \beta \sqrt{ (\alpha-\beta)^2 + 1 } 
%     \right)
%   \biggr)
% \end{align*}
% 
% Certainly not 
% impossible---$v(t)^2$ is just a second degree polynomial in $t$, so 
% the primitive function of $v(t)$ can be expressed in terms of 
% elementary functions---but complicated enough to be rather awkward 
% to program. Therefore I prefer to let \(v_0=0\) (certainly in 
% complete disregard of how \eqref{Eq:Kant-energi} was derived, but 
% since this is just a heuristic anyway, I can do whatever I bloody 
% want as long as I am satisfied with the results!), which corresponds 
% to giving the edges zero natural length. This is not a problem in 
% practice, since there will (besides the attraction from the edges) 
% also be repulsive forces between the vertices.\footnote{Obviously a 
% comment based on the expectation that forces along edges should be 
% modelled after forces in springs. This, as it turned out, was not a 
% very good idea.}
% 
% Continuing with the problem of minimising the edge energy, one finds 
% that \eqref{Eq:rs-kant-energi} has its minimum for
% \begin{equation} \label{Eq:Elastiska-rs}
%   r = \frac{\langle\mathbf{c},\mathbf{a}\rangle}{4 \mathbf{a}^2}
%   \quad\text{and}\quad
%   s = \frac{\langle -\mathbf{c},\mathbf{b}\rangle}{4 \mathbf{b}^2}
%   \text{.}
% \end{equation}
% The following procedure computes corresponding coordinates for the 
% edges.
% 
% [At this point, we leave the old presentation; unlike the physics, 
% the program has changed to fit new circumstances.]
% 
% ---
% 
% \begin{proc}{elastic_edges}
%   The |elastic_edges| procedure computes coordinates for the edges of 
%   a network such that the energy needed to strech it to that form is 
%   minimal. The syntax is
%   \begin{quote}
%     |network::elastic_edges| \word{network-var} \word{type-arr} 
%     \word{min-coeff}\regopt
%   \end{quote}
%   where \word{network-var} and \word{type-arr} are names of variables 
%   in the local context of the caller. The \word{min-coeff}, which 
%   defaults to |0.6|, is a lower bound for the $r$ and $s$ 
%   coefficients which overrides the normal formula 
%   \eqref{Eq:Elastiska-rs}. There is no particular return 
%   value, but the \word{network-var} will be modified.
%   
%   Each edge curve is defined by four points. The two endpoints are 
%   precisely the points where the edge is attached to a vertex, or in 
%   the case of the input\slash output end of a leg, the cut-off point 
%   of that leg. The endpoint tangent lines go through the corresponding 
%   vertex, or in the case of legs, is vertical. This leaves only two 
%   degrees of freedom, for which the values are normally computed 
%   according to \eqref{Eq:Elastiska-rs}, but if either of these fall 
%   below the \word{min-coeff} then that number is used instead for 
%   that coefficient. The reason such a lower bound is useful is that 
%   the $r$ and $s$ computed by the above formulae may well be zero or 
%   negative, and in that case the edge curves would not begin in the 
%   intended direction.
%   \begin{tcl}
proc network::elastic_edges {NWvar TAvar {minrs 0.6}} {
   upvar 1 $NWvar NW $TAvar TA
   set n 0
   foreach e [lindex $NW 1] {
      set i [lindex $e 1]
      if {$i>=0} then {
         set j [lsearch -exact -integer [lindex $NW 0 $i 1] $n]
         foreach {a1 a2} [lindex $TA([lindex $NW 0 $i 0]) 1 1 $j]\
           {break}
         set x0 [expr {[lindex $NW 0 $i 3 0] + $a1}]
         set y0 [expr {[lindex $NW 0 $i 3 1] + $a2}]
      } else {
         set a1 0; set a2 1
         set x0 [lindex $NW 2 3 [expr {-$i-1}]]
         set y0 [lindex $NW 2 5]
      }
      set i [lindex $e 0]
      if {$i>=0} then {
         set j [lsearch -exact -integer [lindex $NW 0 $i 1] $n]
         foreach {b1 b2} [lindex $TA([lindex $NW 0 $i 0]) 1 1 $j]\
           {break}
         set x3 [expr {[lindex $NW 0 $i 3 0] + $b1}]
         set y3 [expr {[lindex $NW 0 $i 3 1] + $b2}]
      } else {
         set b1 0; set b2 -1
         set x3 [lindex $NW 2 2 [expr {-$i-1}]]
         set y3 [lindex $NW 2 4]
      }
      set r [expr {(($x3 - $x0) * $a1 + ($y3 - $y0) * $a2) / 
        4 / ($a1*$a1 + $a2*$a2) }]
      if {$r < $minrs} then {set r $minrs}
      set s [expr {-(($x3 - $x0) * $b1 + ($y3 - $y0) * $b2) / 
        4 / ($b1*$b1 + $b2*$b2) }]
      if {$s < $minrs} then {set s $minrs}
      set x1 [expr {$x0 + $r*$a1}]
      set y1 [expr {$y0 + $r*$a2}]
      set x2 [expr {$x3 + $s*$b1}]
      set y2 [expr {$y3 + $s*$b2}]
      while {[llength $e]<5} {lappend e {}}
      lset e 3 [list $x0 $y0 $x1 $y1 $x2 $y2 $x3 $y3]
      lset NW 1 $n $e
      incr n
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{SVG rendering}
% 
% As the complexity of networks and expressions involving networks 
% increases, the Tk |canvas| is getting less convenient as a drawing 
% vehicle; it lacks direct support for the higher level presentation 
% concerns (especially line breaking) that start to appear. 
% A rendering target which offers better support in that area is SVG, 
% as it can be embedded into XHTML.
% 
% Being an application of XML, it is convenient to return SVG code as a 
% \Tcl\ data-tree and then rely on e.g.~\textsf{tdom} to convert this 
% to standard XML code.
% A \emph{data-tree} is a rooted tree where the nodes carry a type-tag 
% and optionally attributes, the children of a node are ordered, and 
% (as a special case) strings may appear as children of a node. The 
% encoding of these follow the \textsf{tdom} ``list'' format for XML 
% nodes, i.e., a data-tree is either (i)~a three element list
% \begin{quote}
%   \word{tag} \word{attributes} \word{children}
% \end{quote}
% where \word{tag} is a string (which must be a valid XML name), 
% \word{attributes} is a dictionary (mapping attribute name to value), 
% and \word{children} is a list of data-trees, or a data-tree is (ii)~a 
% two element list
% \begin{quote}
%   |#text| \word{string}
% \end{quote}
% encoding the explicit string \word{string}.
% 
% Note that all \word{string}s and attribute values are \Tcl\ strings, 
% not XML encodings of such strings. This means the amperand character 
% is really `|&|', not `|&amp;|'. Also note that |#text| is not a valid 
% \word{tag}, since `|#|' is not allowed in XML names. This implies 
% that \textbf{data-trees can be processed directly using the 
% data-is-code technique}.
% 
% \begin{proc}{as_SVG}
%   The |as_SVG| procedure takes a rich network with |vpos-Tk| and 
%   |ecurve-Tk-tt| entries as argument, and returns the data-tree for 
%   an SVG drawing of the same. The call syntax is
%   \begin{displaysyntax}
%     |network::rich::as_SVG| \word{vertex-object dict} 
%     \begin{regblock}[\regplus] \word{option} \word{value} 
%     \end{regblock}
%   \end{displaysyntax}
%   where the \word{vertex-object dict} maps vertex decorations to 
%   corresponding graphical appearances, as SVG data-trees with the 
%   reference point at $(0,0)$. The default XML namespace for these 
%   is that of SVG, and they occur once for each vertex (if sharing 
%   is wanted, then use |use| elements or similar for these).
%   
%   The available options are
%   \begin{ttdescription}
%     \item[-val] Standard pass-network-by-value option.
%     \item[-var] Standard pass-network-by-variable option.
%     \item[-class]
%       The value of the |class| attribute for the top-level |svg| 
%       element. Defaults to |network|. An empty string means the 
%       attribute is omitted.
%     \item[-setstroke]
%       Takes a boolean value, defaults to true. When true, the 
%       attributes |fill="none" stroke="currentColor"| are applied to 
%       the top-level SVG element, as that is the most practical 
%       default by virtue of being the same as in Tk. If these 
%       attributes are instead supplied through a class, then turning 
%       |-setstroke| off yields less code.
%       \changes{2.5}{2009/07/27}{Switching to stroking as default 
%          paint mode in SVG networks. (LH)}
%     \iffalse
%     \item[-region]
%       Takes as value a region which may be highlighted in the 
%       drawing. Defaults to `|{} {} {}|', i.e., the empty region.
%     \item[-incolour]
%       The colour to use for edges on the in-boundary of the region; 
%       defaults to |blue|.
%     \item[-outcolour]
%       The colour to use for edges on the out-boundary of the region; 
%       defaults to |red|.
%     \item[-midcolour]
%       The colour to use for vertices, internal edges, and in\&out 
%       edges of the region; defaults to |green|.
%     \fi
%   \end{ttdescription}
%   
%   \begin{tcl}
proc network::rich::as_SVG {vertexD args} {
   array set Opt {-class network -setstroke 1}
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
   array set SVG $vertexD
   set attr [dict create xmlns http://www.w3.org/2000/svg]
   if {$Opt(-class) ne ""} then {dict set attr class $Opt(-class)}
   if {$Opt(-setstroke)} then {
      dict set attr  fill none  stroke currentColor
   }
   if {[info exists NW(bbox-Tk)]} then {
      dict set attr width\
        [expr {[lindex $NW(bbox-Tk) 2] - [lindex $NW(bbox-Tk) 0]}]
      dict set attr height\
        [expr {[lindex $NW(bbox-Tk) 3] - [lindex $NW(bbox-Tk) 1]}]
   }
   set childL {}
%   \end{tcl}
%   First the edges are drawn. These are |path| elements.
%   \begin{tcl}
   foreach L $NW(ecurve-Tk-tt) {
      set knotL [lrange $L 0 1]
      set x1 [lindex $L 2]; set y1 [lindex $L 3]
      foreach {x y} [lrange $L 4 end-2] {
         lappend knotL [expr {0.5*($x1+$x)}] [expr {0.5*($y1+$y)}]
         set x1 $x; set y1 $y
      }
      lappend knotL [lindex $L end-1] [lindex $L end]
      set dataL [list M]
      lappend dataL [lindex $knotL 0] [lindex $knotL 1]
      lappend dataL Q [lindex $L 2] [lindex $L 3]\
        [lindex $knotL 2] [lindex $knotL 3]
      if {[llength $knotL]>4} then {
         lappend dataL T
         foreach {x y} [lrange $knotL 4 end] {lappend dataL $x $y}
      }
      lappend childL [list path [dict create d [join $dataL]] {}]
   }
%   \end{tcl}
%   \begin{tcl}
   set n -1; foreach v [lindex $NW(pure) 0] pos $NW(vpos-Tk) {incr n
      if {$n<2} then {continue}
      set shift\
        [format translate(%g,%g) [lindex $pos 0] [lindex $pos 1]]
      set vattr [lindex $SVG([lindex $v 0]) 1]
      if {[dict exists $attr transform]} then {
         dict set vattr transform "$shift [dict get $attr transform]"
      } else {
         dict set vattr transform $shift
      }
      lappend childL [lreplace $SVG([lindex $v 0]) 1 1 $vattr]
   }
%   \end{tcl}
%   \begin{tcl}
   list svg $attr $childL
}
%   \end{tcl}
% \end{proc}
% 
% \begin{tcl}
namespace eval network::rich::tosvg {}
% \end{tcl}
% \setnamespace{network::rich::tosvg}
% The |network::rich::tosvg| namespace houses commands for converting 
% |canvas| items, as specified in an \word{appearance} dictionary, to 
% SVG elements\Dash specifically, convert one triplet from a 
% \word{vertex-items} list. In order to convert a triplet
% \begin{displaysyntax}
%   \word{item-type} \word{coordinates-command} \word{options}
% \end{displaysyntax}
% one makes the call
% \begin{displaysyntax}
%   network::rich::tosvg::\meta{item-type} 
%   \word{coordinates-command} \word{options} \word{shape-ns}
% \end{displaysyntax}
% where the \word{shape-ns} is the namespace in which the 
% \word{coordinates-command} would be called.
% 
% 
% \begin{proc}{rectangle}
%   Tk |rectangle| items become SVG |rect| elements. 
%   \begin{tcl}
proc network::rich::tosvg::rectangle {coordcmd opts ns} {
   foreach {attr opts} [_opts2paint $opts 0 1] break
   set xL {}
   set yL {}
   foreach {x y} [namespace eval $ns $coordcmd {0 0}] {
      lappend xL $x; lappend yL $y
   }
   set xL [lsort -real $xL]; set yL [lsort -real $yL]
   dict set attr x [lindex $xL 0]
   dict set attr y [lindex $yL 0]
   dict set attr width [expr {[lindex $xL 1] - [lindex $xL 0]}]
   dict set attr height [expr {[lindex $yL 1] - [lindex $yL 0]}]
   list rect $attr {}
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{_opts2paint}
%   The |_opts2paint| procedure converts |canvas| item options 
%   corresponding to SVG applications of paint to the corresponding 
%   SVG attributes. The call syntax is
%   \begin{displaysyntax}
%     |_opts2paint| \word{opts} \word{fill-is-stroke} 
%     \word{stroke-by-default}
%   \end{displaysyntax}
%   where \word{opts} is the key--value list of options to convert, 
%   and the other arguments are booleans. The return value is a list
%   \begin{displaysyntax}
%     \word{attributes} \word{remaining opts}
%   \end{displaysyntax}
%   where \word{attributes} is the attribute dictionary and 
%   \word{remaining opts} is the key--value list of options that were 
%   not converted.
%   
%   The \word{stroke-by-default} argument is |1| if stroking is the 
%   default state for this item; this is true for most |canvas| 
%   items. The \word{fill-is-stroke} argument is |1| for |canvas| 
%   items (most notably |line|) that uses |-fill| rather than 
%   |-outline| for what would normally be considered a stroke.
%   
%   A difference between Tk and SVG is that most items on the Tk 
%   |canvas| default to being stroked, whereas the corresponding SVG 
%   items default to being filled. Items in networks are however 
%   assumed to inherit a default of stroking with |currentColor| and 
%   no filling.
%   \begin{tcl}
proc network::rich::tosvg::_opts2paint\
  {allopts fill_is_stroke stroke_by_default} {
   set opts {}
   set attr [dict create]
   if {!$stroke_by_default} then {
      dict set attr fill currentColor
      dict set attr stroke none
   }
%   \end{tcl}
%   The main loop has a simple |switch| as body. Right now it only 
%   does |-fill| and |-outline|, but it should be clear how to extend 
%   it.
%   \begin{tcl}
   foreach {opt val} $allopts {
      switch -- $opt -fill {
         if {$fill_is_stroke} then {
            dict set attr stroke [_colour $val]
         } else {
            dict set attr fill [_colour $val]
         }
      } -outline {
         dict set attr stroke [_colour $val]
      } default {
         lappend opts $opt $val
      }
   }
   return [list $attr $opts]
}
%   \end{tcl} 
% \end{proc}
% 
% \begin{proc}{_colour}
%   The |_colour| command should generally convert a Tk colour to the 
%   corresponding SCG colour. The bare minimum is to change the empty 
%   string to |none| and leave everything else as it is:
%   \begin{tcl}
proc network::rich::tosvg::_colour {tkcol} {
   if {$tkcol ne ""} then {return $tkcol} else {return none}
}
%   \end{tcl}
%   However, if one wants this to be foolproof then the operation can 
%   be very complex indeed, probably requiring extensive conversion 
%   tables.
% \end{proc}
% 
% \begin{proc}{oval}
%   Tk |oval| items become SVG |circle| or |ellipse| elements; the 
%   |square| coordinates command corresponds to the |circle| case.
%   \begin{tcl}
proc network::rich::tosvg::oval {coordcmd opts ns} {
   foreach {attr opts} [_opts2paint $opts 0 1] break
   if {[lindex $coordcmd 0] eq "square"} then {
      dict set attr r [format %g [lindex $coordcmd 1]]
      return [list circle $attr {}]
   }
   set xL {}
   set yL {}
   foreach {x y} [namespace eval $ns $coordcmd {0 0}] {
      lappend xL $x; lappend yL $y
   }
   set xL [lsort -real $xL]; set yL [lsort -real $yL]
   dict set attr cx [expr {0.5*([lindex $xL end]+[lindex $xL 0])}]
   if {[dict get $attr cx]==0} then {dict unset attr cx}
   dict set attr cy [expr {0.5*([lindex $yL end]+[lindex $yL 0])}]
   if {[dict get $attr cy]==0} then {dict unset attr cy}
   dict set attr rx [expr {0.5*([lindex $xL end]-[lindex $xL 0])}]
   dict set attr ry [expr {0.5*([lindex $yL end]-[lindex $yL 0])}]
   list ellipse $attr {}
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{line}
%   Tk |line| items become SVG |polyline| elements; one could as a 
%   special case turn |line| items with two points into |line| 
%   elements, but the extra complexity (both in processing and 
%   generated code) just doesn't seem worth it. More principal is the 
%   catch that |-smooth| items need to be turned into |path| 
%   elements; this is currently detected but throws an error.
%   \begin{tcl}
proc network::rich::tosvg::line {coordcmd opts ns} {
   foreach {attr opts} [_opts2paint $opts 1 1] break
   if {[dict exists $opts -smooth] &&\
     ![string is false [dict get $opts -smooth]]} then {
       return -code error "The -smooth option is not supported yet"
   }
   dict set attr points [join [namespace eval $ns $coordcmd {0 0}]]
   list polyline $attr {}
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{text}
%   Not surprisingly, Tk |text| items become SVG |text| elements. 
%   There are two tricky options to handle: |-font| (because the 
%   values of this option are so varied) and |-anchor| (because SVG 
%   only supports the horizontal aspect of this!). |-font| is 
%   therefore delegated to a helper procedure, whereas the effect of 
%   |-anchor| is emulated using vertical shifts in |ex| units.
%   
%   \begin{tcl}
proc network::rich::tosvg::text {coordcmd opts ns} {
   foreach {attr opts} [_opts2paint $opts 0 0] break
   if {[dict exists $opts -font]} then {
      set attr [dict merge $attr [_Tkfont [dict get $opts -font]]]
   }
   foreach {x y} [namespace eval $ns $coordcmd {0 0}] break
   if {$x!=0 || $y!=0} then {
      dict set attr transform [format translate(%g,%g)] $x $y]
   }
   if {![dict exists $opts -anchor]}\
   then {dict set opts -anchor center}
   switch -- [dict get $opts -anchor] {
      "nw" - "w" - "sw"    {dict set attr text-anchor start}
      "n" - "center" - "s" {dict set attr text-anchor middle}
      "ne" - "e" - "se"    {dict set attr text-anchor end}
%   \end{tcl}
%   This interpretation is bidi-ignorant, since the values |start|, 
%   |middle|, and |end| refer to the logical reading order rather 
%   than the rendering, but Tk is bidi-ignorant too.
%   \begin{tcl}
      default {
         return -code error\
           "bad anchor position \"[dict get $opts -anchor]\""
      }
   }
   switch -- [dict get $opts -anchor] {
      "se" - "s" - "sw"    {dict set attr baseline-shift 0.5ex}
      "e" - "center" - "w" {dict set attr baseline-shift -0.5ex}
      "ne" - "n" - "nw"    {dict set attr baseline-shift -1.5ex}
   }
   if {[dict exists $opts -angle]} then {
      dict append attr transform [format { rotate(%g)}\
        [expr {-[dict get $opts -angle]}]]
   }
   if {![dict exists $opts -text]} then {dict set opts -text ""}
   list text $attr [list [list \#text [dict get $opts -text]]]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{_Tkfont}
%   This procedure converts a Tk font description to SVG attributes. 
%   The call syntax is
%   \begin{displaysyntax}
%     |_Tkfont| \word{font description}
%   \end{displaysyntax}
%   and the return value is the dictionary of corresponding 
%   attributes.
%   
%   Since Tk implements several font description formats, matching it 
%   fully is a bit tricky. Right now only the option--value form is 
%   supported.
%   \begin{tcl}
proc network::rich::tosvg::_Tkfont {descr} {
   set res [dict create]
   dict for {opt val} $descr {
      switch -- $opt -family {
         dict set res font-family $val
      } -size {
         if {$val>0} then {
            dict set res font-size [format {%g pt} $val]
         } else {
            dict set res font-size [format %g [expr {-$val}]]
         }
      } -weight {
         dict set res font-weight $val
      } -slant {
         if {$val eq "roman"} then {
            dict set res font-style normal
         } else {
            dict set res font-style $val
         }
      } -underline {
         if {$val} then {dict set res text-decoration underline}
      } -overstrike {
         if {$val} then {dict set res text-decoration line-through}
      }
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \setnamespace{network::rich}
% \begin{proc}{SVG_appearances}
%   This procedure takes a vertex appearance dictionary as argument 
%   and generates a corresponding vertex-object dictionary.
%   \begin{tcl}
proc network::rich::SVG_appearances {inD} {
   set resD [dict create]
   set shape_ns [namespace parent]::shape
   set tosvg_ns [namespace current]::tosvg
   dict for {key material} $inD {
      set itemL {}
      foreach {type coords opts} [lindex $material 0] {
         set cmdL [info commands ${tosvg_ns}::${type}*]
         if {[llength $cmdL] == 1} then {
            lappend itemL [[lindex $cmdL 0] $coords $opts $shape_ns]
         } elseif {[llength $cmdL]} then {
            return -code error "Ambiguous item type '$type'; must be\
              one of: [join $cmdL ", "]"
         } else {
            return -code error "Unknown item type '$type'; must be one\
              of: [join [info commands ${tosvg_ns}::\[a-zA-Z\]*] ", "]"
         }
      }
      if {[llength $itemL]==1} then {
         dict set resD $key [lindex $itemL 0]
      } else {
         dict set resD $key [list g {} $itemL]
      }
   }
   return $resD
}
%</pkg>
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{\LaTeX\ (PGF) rendering}
% 
% The basic approach for the \LaTeX\ rendering is to build on the PGF 
% package, since this provides better coverage of PS \emph{and} PDF 
% than anything else I've encountered. Unfortunately, raw PGF code is 
% rather verbose, so it seems a good idea to create a new frontend 
% that permits more compact code.
% 
%    \begin{macrocode}
%<*sdpgf>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{sdpgf}[2011/01/24 Space-delimited PGF pictures]
\ProcessOptions
\RequirePackage{pgfcore}
\usepgfmodule{shapes}
%    \end{macrocode}
% 
% The characteristic trait of this frontend is that it uses \TeX\ 
% commands with \emph{space-delimited} arguments. First, this is more 
% compact than brace-delimiting (one delimiter character per argument 
% instead of two). Second, it permits ordinary text wrapping commands 
% to reflow the code; this can do wonders for reducing the number of 
% lines a picture takes to draw, and is thus also of great help for 
% keeping the code visually compact (without appearing rigid).
% 
% \begin{macro}{\sdpgfunit}
%   Another trait is that all coordinates are expressed as multiples 
%   of |\sdpgfunit| rather than as explicit lengths (which is the 
%   normal case in PGF). This saves at least two characters per 
%   coordinate (no \TeX\ unit is shorter than two characters) and 
%   gives a ``coordinate transformation'' scaling capability, which 
%   can be useful since the ``quick'' PGF commands used operate at 
%   the level below PGF's coordinate transformations.
%    \begin{macrocode}
\newdimen\sdpgfunit
%    \end{macrocode}
%   By choosing the |\sdpgfunit| carefully, it can furthermore be 
%   possible to make all coordinates integers, which saves another 
%   character for the decimal point.
% \end{macro}
% 
% \begin{macro}{\SDPGF@x}
% \begin{macro}{\SDPGF@y}
%   A third trait is that many SDPGF commands use relative 
%   coordinates rather than absolute; again to squeeze another 
%   character or two from many arguments. Since PGF doesn't seem to 
%   provide an easy method of retrieving the coordinates of the 
%   current point however, it becomes necessary to allocate two extra 
%   registers to keep track of this within the frontend.
%    \begin{macrocode}
\newdimen\SDPGF@x
\newdimen\SDPGF@y
%    \end{macrocode}
% \end{macro}\end{macro}
% 
% \begin{macro}{\SDPGF@@L}
%   An example of this is the |\L| command, which corresponds to PS's 
%   \textsf{rlineto} operator (except the arguments come after, since 
%   this is still \TeX).
%    \begin{macrocode}
\def\SDPGF@@L #1 #2 {%
   \advance \SDPGF@x #1\sdpgfunit
   \advance \SDPGF@y #2\sdpgfunit
   \pgfpathqlineto{\the\SDPGF@x}{\the\SDPGF@y}%
}
%    \end{macrocode}
%   The commands are normally kept in control sequences with a 
%   |\SDPGF@@| prefix, and only switched to ``user'' names inside the 
%   \texttt{sdpgf} environment (see below).
% \end{macro}
% 
% \begin{macro}{\SDPGF@@m}
% \begin{macro}{\SDPGF@@M}
%   The current position is usually initialised using the |\m| 
%   command, which takes absolute coordinates (thus corresponding to 
%   PS's \textsf{moveto}). For completeness, there is also an |\M| 
%   command which takes relative coordinates (thus corresponding to 
%   PS's \textsf{rmoveto}).
%    \begin{macrocode}
\def\SDPGF@@m #1 #2 {%
   \SDPGF@x=#1\sdpgfunit
   \SDPGF@y=#2\sdpgfunit
   \pgfpathqmoveto{\the\SDPGF@x}{\the\SDPGF@y}%
}
\def\SDPGF@@M #1 #2 {%
   \advance \SDPGF@x #1\sdpgfunit
   \advance \SDPGF@y #2\sdpgfunit
   \pgfpathqmoveto{\the\SDPGF@x}{\the\SDPGF@y}%
}
%    \end{macrocode}
% \end{macro}\end{macro}
% 
% \begin{macro}{\SDPGF@@C}
%   The |\C| command corresponds to the Type~1 charstring 
%   \textsf{rrcurveto} command, i.e., the coordinates of each new 
%   point (whether control point or knot) are relative to those of 
%   the point before.
%   
%   This is slightly more complicated than the previous commands, 
%   because the control point coordinates needs to be saved away as 
%   tokens.
%    \begin{macrocode}
\def\SDPGF@@C #1 #2 #3 #4 #5 #6 {%
   \advance \SDPGF@x #1\sdpgfunit
   \advance \SDPGF@y #2\sdpgfunit
   \edef\@tempa{{\the\SDPGF@x}{\the\SDPGF@y}}%
   \advance \SDPGF@x #3\sdpgfunit
   \advance \SDPGF@y #4\sdpgfunit
   \edef\@tempa{%
     \noexpand\pgfpathqcurveto\@tempa{\the\SDPGF@x}{\the\SDPGF@y}%
   }%
   \advance \SDPGF@x #5\sdpgfunit
   \advance \SDPGF@y #6\sdpgfunit
   \@tempa{\the\SDPGF@x}{\the\SDPGF@y}%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\SDPGF@@h}
%   As in PDF, the |\h| command closes the current path, but does not 
%   change the current point (just like its Type~1 charstring 
%   counterpart).
%    \begin{macrocode}
\def\SDPGF@@h{\pgfsyssoftpath@closepath}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\SDPGF@@S}
%   Also as in PDF, the |\S| command strokes the current path without 
%   closing it first, i.e., it is an alias for |\pgfusepathqstroke|. 
%   Some experiments showed that occurrencies of |\pgfusepathqstroke| 
%   tended to account for a third of all characters in an image!
%    \begin{macrocode}
\def\SDPGF@@S{\pgfusepathqstroke}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\SDPGF@@re}
%   The |\re| command constructs a rectangle, like the PDF operator 
%   \textsf{re}. It has the syntax
%   \begin{quote}
%     |\re| \meta{left} \meta{bottom} \meta{width} \meta{height}
%   \end{quote}
%   Implementation-wise, it maps directly to the 
%   |\pgfsyssoftpath@rect| command. It might be argued that it should 
%   also update |\SDPGF@x| and |\SDPGF@y|, but this didn't seem 
%   necessary.
%    \begin{macrocode}
\def\SDPGF@@re #1 #2 #3 #4 {%
   \pgfsyssoftpath@rect{#1\sdpgfunit}{#2\sdpgfunit}%
     {#3\sdpgfunit}{#4\sdpgfunit}%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\SDPGF@@ov}
%   The |\ov| (for `oval') command constructs an ellipse inscribed in 
%   and with axes parallel to the corresponding |\re| rectangle. It 
%   thus has the syntax
%   \begin{quote}
%     |\ov| \meta{min-x} \meta{min-y} \meta{width} \meta{height}
%   \end{quote}
%   although the two coordinates can technically be for any corner of 
%   the bounding box, if the signs of \meta{width} and \meta{height} 
%   are adjusted accordingly.
%   
%    \begin{macrocode}
\def\SDPGF@@ov #1 #2 #3 #4 {%
   \SDPGF@x=#1\sdpgfunit    \SDPGF@y=#2\sdpgfunit
   \pgf@x=#3\sdpgfunit      \pgf@y=#4\sdpgfunit
   \pgf@xa=0.224\pgf@x      \pgf@ya=0.224\pgf@y
   \pgf@xb=0.5\pgf@x        \pgf@yb=0.5\pgf@y
   \pgf@xc=0.776\pgf@x      \pgf@yc=0.776\pgf@y
   \advance\pgf@x\SDPGF@x   \advance\pgf@y\SDPGF@y
   \advance\pgf@xa\SDPGF@x  \advance\pgf@ya\SDPGF@y
   \advance\pgf@xb\SDPGF@x  \advance\pgf@yb\SDPGF@y
   \advance\pgf@xc\SDPGF@x  \advance\pgf@yc\SDPGF@y
   \edef\@tempa{%
      \noexpand\pgfpathqmoveto{\the\pgf@x}{\the\pgf@yb}%
      \noexpand\pgfpathqcurveto{\the\pgf@x}{\the\pgf@yc}%
        {\the\pgf@xc}{\the\pgf@y}{\the\pgf@xb}{\the\pgf@y}%
      \noexpand\pgfpathqcurveto{\the\pgf@xa}{\the\pgf@y}%
        {\the\SDPGF@x}{\the\pgf@yc}{\the\SDPGF@x}{\the\pgf@yb}%
      \noexpand\pgfpathqcurveto{\the\SDPGF@x}{\the\pgf@ya}%
        {\the\pgf@xa}{\the\SDPGF@y}{\the\pgf@xb}{\the\SDPGF@y}%
      \noexpand\pgfpathqcurveto{\the\pgf@xc}{\the\SDPGF@y}%
        {\the\pgf@x}{\the\pgf@ya}{\the\pgf@x}{\the\pgf@yb}%
   }%
   \@tempa
   \h %\pgfsyssoftpath@closepath 
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\SDPGF@@TR}
%   The |\TR| command creates a text node with \texttt{rectangle} 
%   shape and a particular anchoring at a particular point. The syntax 
%   is
%   \begin{quote}
%     |\TR| \meta{x} \meta{y} \meta{angle} \meta{anchor} 
%     \meta{label text}
%   \end{quote}
%   where \meta{anchor} and \meta{label text} are as for the 
%   |\pfgnode| command. Note that these arguments may well contain 
%   spaces themselves, so the caller must take care to brace them 
%   when necessary. The \meta{x} and \meta{y} arguments are 
%   coordinates in |\sdpgfunit|s, and the \meta{angle} is in degrees; 
%   use \texttt{0} for an ordinary horizontal baseline.
%   
%   The node path is always discarded. The coordinate transformation 
%   needed to put the node somewhere other than the origin is kept 
%   within a group.
%   
%   \changes{2.6}{2011/01/24}{Command added. (LH)}
%   
%    \begin{macrocode}
\def\SDPGF@@TR #1 #2 #3 #4 #5 {{%
   \pgftransformxshift{#1\sdpgfunit}%
   \pgftransformyshift{#2\sdpgfunit}%
   \pgftransformrotate{#3}%
   \pgfnode{rectangle}{#4}{#5}{}{\pgfusepath{discard}}%
}}
%    \end{macrocode}
%   Having waded through a trace of this command, I must say I am 
%   sorely tempted to rewrite it in terms of |\pgfqbox| and\slash or 
%   |\pgfqboxsynced| instead\Dash there's simply no reason to put 
%   \TeX\ through all that just for this. On the other hand, it would 
%   make the \textsf{sdpgf} package quite a bit larger. An 
%   interesting compromise could be to implement a |\Tr| command that 
%   handles everything but rotation directly using |\pgfqbox| and 
%   \TeX\ box manuoevres\dots
% \end{macro}
% 
% \begin{macro}{\SDPGF@Fs}
% \begin{macro}{\SDPGF@FS}
%   The |\Fs| command is a compact alias for |\fontsize| (i.e., it 
%   sets the font size). The |\FS| command does the same, and in 
%   addition calls |\selectfont| to actually change the current font.
%   The  syntaxes are
%   \begin{quote}
%     |\Fs{|\meta{units or length}|}|\\
%     |\FS{|\meta{units or length}|}|
%   \end{quote}
%   since these command are typically used within a space-delimited 
%   \meta{label text}, and would therefore be impractical to delimit 
%   with spaces.
%   
%   The \meta{units \emph{or} length} part exploits a 
%   not-so-well-known feature of |\fontsize|, namely that it takes a 
%   \meta{dimen} as argument but will supply |pt| as default unit if 
%   none is given. |\Fs| and |\FS| does the same, but supplies 
%   |\sdpgfunit| as the default unit.
%   
%    \begin{macrocode}
\def\SDPGF@@Fs#1{\fontsize{#1\sdpgfunit}\z@}
\def\SDPGF@@FS#1{\SDPGF@@Fs{#1}\selectfont}
%    \end{macrocode}
%   The reason it works to merely insert an |\sdpgfunit| like that is 
%   that |\fontsize| internally uses |\@defaultunits|, which causes 
%   everything after the first syntactically valid \meta{dimen} to be 
%   gobbled. It's a hack, but it works beautifully.
% \end{macro}\end{macro}
% 
% 
% \begin{environment}{sdpgf}
%   The |sdpgf| environment is a |pgfpicture| environment with some 
%   extra initialisation, particularly the switching-in of |\SDPGF@@| 
%   commands. The syntax is
%   \begin{quote}
%     |\begin{sdpgf}|\marg{left}\marg{top}\marg{right}\marg{bottom}^^A
%     \marg{unit}\\
%     \vadjust{}\quad\meta{graphics}\\
%     |\end{sdpgf}|
%   \end{quote}
%   where \meta{unit} (a length) is the |\sdpgfunit| value used in 
%   the environment. The \meta{left}, \meta{top}, \meta{right}, and 
%   \meta{bottom} (all factors) define the bounding box for the 
%   environment.
%   
%   The baseline of the picture is initialised so that the picture 
%   is positioned as if it had been |\vcenter|ed.
%   To that end, it is necessary to record the length of |-1ex| 
%   before the |\pgfpicture| command, as the latter apparently 
%   switches to |\nullfont|.
%    \begin{macrocode}
\newenvironment{sdpgf}[5]{%
   \SDPGF@y=-1ex%
   \setlength\sdpgfunit{#5}%
   \pgfpicture
%    \end{macrocode}
%   From the PGF manual, the kosher way of setting the bounding box 
%   seems to be to say \verb*"\pgfusepath{use as bounding box}", but 
%   the actual effect of that rather appears to be to turn 
%   bbox-checking \emph{off}! Any contribution to the bbox would come 
%   from the path construction phase, which in turn means quick paths 
%   are ignored\dots
%   
%   Some source-diving turned up four |\dimen| registers that 
%   actually keep track of the bounding box. Setting them directly is 
%   much easier, but apparently one has to do so globally.
%    \begin{macrocode}
   \global\pgf@picminx=#1\sdpgfunit
   \global\pgf@picminy=#4\sdpgfunit
   \global\pgf@picmaxx=#3\sdpgfunit
   \global\pgf@picmaxy=#2\sdpgfunit
%    \end{macrocode}
%   Setting the baseline has another surprise in store: apparently 
%   the value has to be expanded in order to be recorded correctly.
%    \begin{macrocode}
   \advance \SDPGF@y #2\sdpgfunit
   \advance \SDPGF@y #4\sdpgfunit
   \advance \SDPGF@y -1ex
   \divide \SDPGF@y \tw@
   \expandafter\pgfsetbaseline\expandafter{\the\SDPGF@y}%
   \let\m\SDPGF@@m
   \let\M\SDPGF@@M
   \let\L\SDPGF@@L
   \let\C\SDPGF@@C
   \let\h\SDPGF@@h
   \let\S\SDPGF@@S
   \let\re\SDPGF@@re
   \let\ov\SDPGF@@ov
   \let\TR\SDPGF@@TR
   \let\Fs\SDPGF@@Fs
   \let\FS\SDPGF@@FS
}{\endpgfpicture}
%    \end{macrocode}
% \end{environment}
% 
%    \begin{macrocode}
%</sdpgf>
%    \end{macrocode}
% 
% \setnamespace{network::rich}
% 
% \begin{proc}{as_PGF}
%   The |as_PGF| procedure takes a rich network with |vpos-Tk|, 
%   |ecurve-Tk-raw|, and |bbox-Tk| entries as argument, and returns 
%   \LaTeX\ code (using the \texttt{sdpgf} environment) for drawing 
%   the same. The call syntax is
%   \begin{displaysyntax}
%     |network::rich::as_PGF| \word{appearance-dict} 
%     \begin{regblock}[\regplus] \word{option} \word{value} 
%     \end{regblock}
%   \end{displaysyntax}
%   where the \word{appearance-dict} maps vertex decorations to 
%   vertex appearances.
%   
%   The available options are
%   \begin{ttdescription}
%     \item[-val] Standard pass-network-by-value option.
%     \item[-var] Standard pass-network-by-variable option.
%     \item[-unit]
%       \LaTeX\ length corresponding to the unit in the network.
%     \item[-division]
%       The unit actually used in the result will be the value of 
%       |-unit| divided by the value of |-division|; setting 
%       |-division| to $2$ can avoid making a lot of coordinates 
%       ending in |.5| when not rounding. Defaults to |1|.
%     \item[-region]
%       Takes as value a region which may be highlighted in the 
%       drawing. Defaults to `|{} {} {}|', i.e., the empty region.
%     \item[-regionstyle]
%       This option controls how a |-region| is highlighted. 
%       If it is |colour| then the PGF colour is set to the 
%       |-midcolour| when things part of the region are being drawn. 
%       If it is |cutmarks| then the cut positions on the edges are 
%       marked by short lines intersecting the edge curves at right 
%       angles. If it is |gone| then the region is simply omitted. 
%       The default is |cutmarks|.
%       \changes{2.8}{2013/02/03}{Implemented showing regions in PGF,
%         with styles of \texttt{cutmarks} and \texttt{gone}. (LH)}
%     \item[-midcolour]
%       The colour to use for vertices and edge-pieces in the region; 
%       defaults to |green|. This becomes an argument of 
%       |\pgfsetcolor|.
%     \item[-cuthalf]
%       Half the length of a cutmark, in canvas units. Defaults to 
%       $3$.
%     \iffalse
%     \item[-round]
%       Boolean to control whether coordinates being output should be 
%       rounded to integers. Defaults to true.
%     \item[-incolour]
%       The colour to use for edges on the in-boundary of the region; 
%       defaults to |blue|.
%     \item[-outcolour]
%       The colour to use for edges on the out-boundary of the region; 
%       defaults to |red|.
%     \fi
%   \end{ttdescription}
%   
%   \begin{tcl}
%<*pkg>
proc network::rich::as_PGF {vertexD args} {
   array set Opt {
      -unit 1pt -division 1
      -region {{} {} {}} -regionstyle cutmarks 
      -cuthalf 3.0 -midcolour green
   }
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
   array set Look $vertexD
   set factor 1.0; set unit pt
   scan $Opt(-unit) %f%s factor unit
   set factor [expr {$factor/$Opt(-division)}]
   set res {\begin{sdpgf}}
   foreach {x y} $NW(bbox-Tk) {
      append res [format "{%d}{%d}" [expr {round($x*$Opt(-division))}]\
        [expr {round(-$y*$Opt(-division))}]]
   }
   append res [format "{%s%s}" $factor $unit] \n
%   \end{tcl}
%   The edges are drawn first, the vertices last. 
%   
%   The |-region| may cause edges to be subdivided, so the first step 
%   in processing it must be to figure out how many pieces there are 
%   of each edge. This information can be computed from the 
%   \word{output-list} and \word{input-list} of the region, but this 
%   is not straightforward as the extended labelling of edges applied 
%   in these lists only has separate labels for the pieces \emph{in} 
%   the region, leaving no room for labelling the pieces not in the 
%   region. The easist way of dealing with this seems to be to 
%   relabel the region legs so that each piece has its own label; 
%   that implies also computing lists |OL| and |IL| of region legs 
%   after relabelling.
%   \begin{tcl}
   set OL {}
   set IL {}
%   \end{tcl}
%   Recall that an extended label has the form $l+mi$, where $l$ is 
%   the underlying edge label, $m$ is the number of edges, and $i$ is 
%   the piece index. Making room for pieces between those that are in 
%   the region requires doubling the $i$ part, but there are two 
%   cases to consider. If the edge tail is in the region then a 
%   straight doubling \(i \mapsto 2i\) is correct, but if the edge 
%   tail is not in the region then one must make it \(i \mapsto 
%   2i+1\) where the extra $1$ is for the piece containing the tail. 
%   The cases where that extra $1$ should be added are precisely 
%   those where $l$ is in the \word{input-list}, since an input leg 
%   can only have \(i=0\) if it is the first region piece of the 
%   edge.
%   
%   It is convenient to also compute the multiplicities when doing 
%   this relabelling; the |multL| list is indexed by edge label and 
%   its elements give the necessary multiplicities. An input leg can 
%   be the last piece of an edge, whereas an output leg is always 
%   followed by another piece. And then the actual \emph{multiplicity} 
%   is one higher still, since the index starts at $0$.
%   \begin{tcl}
   set multL {}
   foreach e [lindex $NW(pure) 1] {lappend multL 1}
   foreach e [lindex $Opt(-region) 1] {
      set l [expr {$e % [llength $multL]}]
      set i [expr {$e / [llength $multL] * 2}]
      if {$l in [lindex $Opt(-region) 2]} then {incr i}
      lappend OL [expr {$l + [llength $multL]*$i}]
      if {$i+1 >= [lindex $multL $l]} then {
         lset multL $l [expr {$i+2}]
      }
   }
   foreach e [lindex $Opt(-region) 2] {
      set l [expr {$e % [llength $multL]}]
      set i [expr {$e / [llength $multL] * 2}]
      if {$l in [lindex $Opt(-region) 2]} then {incr i}
      lappend IL [expr {$l + [llength $multL]*$i}]
      if {$i >= [lindex $multL $l]} then {
         lset multL $l [expr {$i+1}]
      }
   }
%   \end{tcl}
%   With the multiplicities known, the |EC| array is filled in with 
%   the |raw| curves of the pieces. The index into this array is the 
%   extended edge label of the piece.
%   \begin{tcl}
   set l -1; foreach curve $NW(ecurve-Tk-raw) m $multL {incr l
      if {$m == 1} then {
         set EC($l) $curve
      } else {
         set e $l
         foreach piece [subdivide_rawcurve $curve $m] {
            set EC($e) $piece
            incr e [llength $multL]
         }
      }
   }
%   \end{tcl}
%   Time now approaches to start generating code, but in the |gone| 
%   and |colour| styles those edges which are in the region should be 
%   treated specially (not generate any code, or be coloured, 
%   respectively). The easiest way to achieve this is to remove their 
%   pieces from the |EC| array and instead put them in the |EC2| array. 
%   The easiest way of finding those pieces that are not legs seems to 
%   be to remove any piece incident with a vertex in the region, even if 
%   that means every piece will be looked at twice.
%   \begin{tcl}
   if {$Opt(-regionstyle) eq "gone" || $Opt(-regionstyle) eq "colour"} then {
      set moveL [concat $OL $IL]
      foreach v [lindex $Opt(-region) 0] {
         lappend moveL {*}[lindex $NW(pure) 0 $v 1]
         foreach e [lindex $NW(pure) 0 $v 2] {
            lappend moveL [expr {
              $e + [llength $multL]*([lindex $multL $e]-1)
            }]
         }
      }
      foreach e $moveL {
         if {[info exists EC($e)]} then {
            set EC2($e) $EC($e)
            unset EC($e)
         }
      }
   }
%   \end{tcl}
%   Drawing the pieces is not so difficult.
%   \begin{tcl}
   foreach e [array names EC] {
      append res [rawcurve_as_PFG $Opt(-division) $EC($e)]
   }
   if {$Opt(-regionstyle) eq "colour" && [array size EC2]} then {
      append res {  \begin{pgfscope} }\
        [format {\pgfsetcolor{%s}} $Opt(-midcolour)] \n
      foreach e [array names EC2] {
         append res [rawcurve_as_PFG $Opt(-division) $EC2($e)]
      }
      append res {  \end{pgfscope}} \n
   }
%   \end{tcl}
%   Then comes the matter of the cutmarks. These are most easily 
%   located as endpoints of those curve pieces which are legs of the 
%   region. The |L| list constructed has the structure
%   \begin{displaysyntax}
%     \begin{regblock}[\regstar]
%       \word{$x$} \word{$y$} \word{$x'$} \word{$y'$}
%     \end{regblock}
%   \end{displaysyntax}
%   where $(x,y)$ is the point to cut at and $(x',y')$ is another 
%   point on the tangent at $(x,y)$ of the curve.
%   \begin{tcl}
   if {$Opt(-regionstyle) eq "cutmarks"} then {
      set L {}
      foreach e $OL {
         lappend L  [lindex $EC($e) 0] [lindex $EC($e) 1] \
           [lindex $EC($e) 2] [lindex $EC($e) 3]
      }
      foreach e $IL {
         lappend L  [lindex $EC($e) end-1] [lindex $EC($e) end] \
           [lindex $EC($e) end-3] [lindex $EC($e) end-2]
      }
      foreach {x y xp yp} $L {
         set r [expr {$Opt(-cuthalf)/hypot($xp-$x,$yp-$y)}]
         set u [expr {($yp-$y)*$r}]
         set v [expr {($x-$xp)*$r}]
         set x1 [expr {round($Opt(-division)*($x+$u))}]
         set x2 [expr {round($Opt(-division)*($x-$u))}]
         set y1 [expr {-round($Opt(-division)*($y+$v))}]
         set y2 [expr {-round($Opt(-division)*($y-$v))}]
         append res [format {  \m %d %d \L %d %d \S}\
           $x1 $y1 [expr {$x2-$x1}] [expr {$y2-$y1}]] \n
      }
   }
%   \end{tcl}
%   Then the vertices are drawn, using code in the |topgf| namespace.
%   \begin{tcl}
   set shape_ns [namespace parent]::shape
   set to_ns [namespace current]::topgf
   set colourscope 0
   set n -1; foreach v [lindex $NW(pure) 0] pos $NW(vpos-Tk) {incr n
      if {$n<2} then {continue}
      switch -- $Opt(-regionstyle) "gone" {
         if {$n in [lindex $Opt(-region) 0]} then {continue}
      } "colour" {
         if {$n in [lindex $Opt(-region) 0]} then {
            if {!$colourscope} then {
               append res {  \begin{pgfscope}} \n\
                 [format {  \pgfsetcolor{%s}} $Opt(-midcolour)] \n
               set colourscope 1
            }
         } else {
            if {$colourscope} then {
               append res {  \end{pgfscope}} \n
               set colourscope 0
            }
         }
      }
      foreach {type coords opts} [lindex $Look([lindex $v 0]) 0] {
         set cmdL [info commands ${to_ns}::${type}*]
         if {[llength $cmdL] == 1} then {
            foreach {state draw} [
               [lindex $cmdL 0] $coords $opts $shape_ns $pos\
                 $Opt(-division)
            ] break
            if {[llength $state]} then {
               append res {  \begin{pgfscope}} \n
               append res {    } [join $state "\n    "] \n
               append res {    } [join $draw "\n    "] \n
               append res {  \end{pgfscope}} \n
            } else {
               append res {  } [join $draw] \n
            }
         } elseif {[llength $cmdL]} then {
            return -code error "Ambiguous item type '$type'; must be\
              one of: [join $cmdL ", "]"
         } else {
            return -code error "Unknown item type '$type'; must be one\
              of: [join [info commands ${to_ns}::\[a-zA-Z\]*] ", "]"
         }
      }
   }
   if {$colourscope} then {
      append res {  \end{pgfscope}} \n
   }
%   \end{tcl}
%   A more optimised implementation could be to collect |draw| 
%   fragments with equal |state| settings, to reduce the amount of 
%   code that is required.
%   \begin{tcl}
   append res {\end{sdpgf}}
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{rawcurve_as_PGF}
%   This procedure takes a |raw| curve as a list of coordinates and 
%   returns \texttt{sdpgf} code for drawing that curve. The call 
%   synax is
%   \begin{displaysyntax}
%     |network::rich::rawcurve_as_PGF| \word{division} \word{curve}
%   \end{displaysyntax}
%   where \word{division} is what the \word{curve} coordinates will 
%   be multiplied by before they are rounded to integers.
%   \begin{tcl}
proc network::rich::rawcurve_as_PFG {div coordL} {
   set dataL {}
   foreach {x y} $coordL {
      lappend dataL [expr {round($x*$div)}] [expr {round(-$y*$div)}]
   }
   foreach {x0 y0} $dataL break
   set res [format "  \\m %d %d\n" $x0 $y0]
   foreach {x1 y1 x2 y2 x3 y3} [lrange $dataL 2 end] {
      set a [expr {$x3 - $x0}]
      set b [expr {$y3 - $y0}]
      set c [expr {$x1 - $x0}]
      set d [expr {$y1 - $y0}]
      set e [expr {$x2 - $x3}]
      set f [expr {$y2 - $y3}]
      set bound [expr {0.00002 * (abs($a) + abs($b))}]
      if {abs( $a*$d - $b*$c ) > $bound ||\
        abs( $a*$f - $b*$e ) > $bound ||\
        !($a||$b) && ($c||$d||$e||$f)
      } then {
         append res {  \C}
         foreach {x y} [list $x1 $y1 $x2 $y2 $x3 $y3] {
            append res [format { %d %d} [expr {$x-$x0}]\
              [expr {$y-$y0}]]
            set x0 $x; set y0 $y
         }
         append res \n
      } elseif {$x3 != $x0 || $y3 != $y0} then {
         append res [format {  \L %d %d} [expr {$x3-$x0}]\
           [expr {$y3-$y0}]] \n
         set x0 $x3; set y0 $y3
      }
   }
   append res {  \S} \n
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{subdivide_rawcurve}
%   This procedure takes a |raw| curve and a positive integer as 
%   argument, subdivides the curve into that many pieces (of equal 
%   ``time'' duration), and returns the list of pieces (each a |raw| 
%   curve itself). The call syntax is
%   \begin{displaysyntax}
%     |network::rich::subdivide_rawcurve| \word{curve} \word{pieces}
%   \end{displaysyntax}
%   It should be observed that the pieces are returned in reverse 
%   order (highest time first), since that turns out to be what makes 
%   most sense for the intended application of subdividing an edge 
%   (other procedure generate edge curves going from head to tail, 
%   but in a subdivision it makes sense to have tailmost piece first).
%   
%   The idea for the algorithm is to go for the last subdivision 
%   time, and split the corresponding curve segment (computing a new 
%   knot and its associated control points). The second half of the 
%   split (and any subsequent segments) is immediately data for a 
%   piece. The first half of the split replaces the original segment 
%   (and any segments after it), and then the algorithm continues 
%   with the previous split. Working from the end is easier since the 
%   times are relative to the start of the coordinate list.
%   
%   \begin{tcl}
proc network::rich::subdivide_rawcurve {coordL pieces} {
   set res {}
   set step [expr {double([llength $coordL]/6)/$pieces}]
   set stretch 1.0
   for {
      set time [expr {$step*($pieces-1)}]
   } {$time > 1e-3} {
      set time [expr {$time - $step}]
   } {
%   \end{tcl}
%   Special case: if the time is less than $10^{-3}$ from an integer, 
%   then cut at the already existing knot. This means you can't cut a 
%   curve into thousands of pieces with this procedure, but doing 
%   that probably wouldn't have been a good idea anyway.
%   \begin{tcl}
      if {abs($time-round($time)) < 1e-3} then {
         set knot [expr {round($time)*6}]
         lappend res [lrange $coordL $knot end]
         set coordL [lrange $coordL 0 [set coordL {}; expr {$knot+1}]]
         set stretch 1.0
         continue
      }
%   \end{tcl}
%   Otherwise one must compute the fraction $t$ at which to cut the 
%   segment. If this is the last segment, then that fraction is 
%   furthermore to be scaled by \textit{stretch}.
%   \begin{tcl}
      set t [expr {($time - int($time)) *\
        ([llength $coordL]/6 < $time+1 ? $stretch : 1)}]
      set pos [expr {int($time)*6}]
      set L {}
      foreach p {0 1 2 3 4 5} {
         lappend L [expr {(1-$t)*[lindex $coordL [expr {$pos+$p}]] +\
           $t*[lindex $coordL [expr {$pos+$p+2}]]}]
      }
      foreach p {0 1 2 3 6 7} {
         lappend L [expr {(1-$t)*[lindex $L $p] +\
           $t*[lindex $L [expr {$p+2}]]}]
      }
      lappend res [lreplace $coordL 0 [expr {$pos+5}] \
        [lindex $L end-1] [lindex $L end] \
        [lindex $L 8] [lindex $L 9]  [lindex $L 4] [lindex $L 5]]
      set coordL [lreplace $coordL [expr {$pos+2}] end \
        [lindex $L 0] [lindex $L 1]  [lindex $L 6] [lindex $L 7] \
        [lindex $L end-1] [lindex $L end]]
      set stretch [expr {1.0/($time-int($time))}]
   }
   lappend res $coordL
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \begin{tcl}
namespace eval network::rich::topgf {}
% \end{tcl}
% \setnamespace{network::rich::topgf}
% The |network::rich::topgf| namespace houses commands for converting 
% |canvas| items, as specified in an \word{appearance} dictionary, to 
% PGF code\Dash specifically, convert one triplet from a 
% \word{vertex-items} list. In order to convert a triplet
% \begin{displaysyntax}
%   \word{item-type} \word{coordinates-command} \word{options}
% \end{displaysyntax}
% one makes the call
% \begin{displaysyntax}
%   network::rich::topgf::\meta{item-type} 
%   \word{coordinates-command} \word{options} \word{shape-ns}
%   \word{center} \word{division}
% \end{displaysyntax}
% where the \word{shape-ns} is the namespace in which the 
% \word{coordinates-command} would be called, \word{center} is the 
% reference point for the item, and \word{division} is the number of 
% \texttt{sdpgf} units per Tk unit. The return value is a list
% \begin{displaysyntax}
%   \word{settings} \word{drawing}
% \end{displaysyntax}
% where both arguments are lists of \LaTeX\ commands that might 
% appear within a \texttt{sdpgf} environment.
% 
% 
% \begin{proc}{rectangle}
%   Tk |rectangle| items become |\re| commands. 
%   \begin{tcl}
proc network::rich::topgf::rectangle {coordcmd opts ns center div} {
   foreach {state use opts} [_opts2state $opts 0 1] break
   set xL {}
   set yL {}
   foreach {x y} [namespace eval $ns $coordcmd $center] {
      lappend xL [expr {round($x*$div)}]
      lappend yL [expr {-round($y*$div)}]
   }
   set xL [lsort -real $xL]; set yL [lsort -real $yL]
   set rect [format {\re %d %d %d %d} [lindex $xL 0] [lindex $yL 0]\
     [expr {[lindex $xL 1] - [lindex $xL 0]}]\
     [expr {[lindex $yL 1] - [lindex $yL 0]}]]
   list $state [list $rect $use]
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{_opts2state}
%   The |_opts2state| procedure parses |canvas| item options 
%   corresponding to changes in the PGF graphics state, and generates 
%   the corresponding code for setting these parameters. The call 
%   syntax is
%   \begin{displaysyntax}
%     |_opts2state| \word{opts} \word{fill-is-stroke} 
%     \word{stroke-by-default}
%   \end{displaysyntax}
%   where \word{opts} is the key--value list of options to convert, 
%   and the other arguments are booleans. The return value is a list
%   \begin{displaysyntax}
%     \word{state-changes} \word{use-code} \word{remaining opts}
%   \end{displaysyntax}
%   where \word{code} is the settings code, \word{use-code} is the 
%   |\pgfusepathq|\dots\ command, and \word{remaining opts} 
%   is the key--value list of options that were not converted.
%   
%   The \word{stroke-by-default} argument is |1| if stroking is the 
%   default state for this item; this is true for most |canvas| 
%   items. The \word{fill-is-stroke} argument is |1| for |canvas| 
%   items (most notably |line|) that uses |-fill| rather than 
%   |-outline| for what would normally be considered a stroke.
%   
%   \begin{tcl}
proc network::rich::topgf::_opts2state\
  {allopts fill_is_stroke stroke_by_default} {
   set opts {}
   set state {}
   set stroke $stroke_by_default
   set fill [expr {!$stroke_by_default}]
%   \end{tcl}
%   The main loop has a simple |switch| as body. Right now it only 
%   does |-fill| and |-outline|, but it should be clear how to extend 
%   it.
%   \begin{tcl}
   foreach {opt val} $allopts {
      switch -- $opt -fill {
         if {$fill_is_stroke} then {
            foreach {stroke val} [_colour $val] break
            if {$stroke} then {
               lappend state "\\pgfsetstrokecolor{$val}"
            }
         } else {
            foreach {fill val} [_colour $val] break
            if {$fill} then {
               lappend state "\\pgfsetfillcolor{$val}"
            }
         }
      } -outline {
         foreach {stroke val} [_colour $val] break
         if {$stroke} then {
            lappend state "\\pgfsetstrokecolor{$val}"
         }
      } default {
         lappend opts $opt $val
      }
   }
   return [list $state [
      lindex {{"" {\S}} {{\pgfusepathqfill}\
        {\pgfusepathqfillstroke}}} $fill $stroke
   ] $opts]
}
%   \end{tcl} 
% \end{proc}
% 
% \begin{proc}{_colour}
%   The |_colour| command should generally convert a Tk colour to a 
%   pair
%   \begin{displaysyntax}
%     \word{use} \word{\LaTeX\ colour}
%   \end{displaysyntax} 
%   where \word{use} is |0| or |1| (where |0| is only used for the 
%   empty Tk colour), and \word{\LaTeX\ colour} is the \LaTeX\ colour 
%   (technically \textsf{xcolor} colour) corresponding to the Tk 
%   colour. The bare minimum is to leave all colour names as they are.
%   \begin{tcl}
proc network::rich::topgf::_colour {tkcol} {
   list [expr {$tkcol ne ""}] $tkcol
}
%   \end{tcl}
%   However, if one wants this to be foolproof then the operation can 
%   be very complex indeed, probably requiring extensive conversion 
%   tables.
% \end{proc}
% 
% \begin{proc}{oval}
%   Tk |oval| items become |\ov| commands (that command was added 
%   primarily for this reason).
%   \begin{tcl}
proc network::rich::topgf::oval {coordcmd opts ns pos div} {
   foreach {state use opts} [_opts2state $opts 0 1] break
   set xL {}
   set yL {}
   foreach {x y} [namespace eval $ns $coordcmd $pos] {
      lappend xL [expr {round($x*$div)}]
      lappend yL [expr {-round($y*$div)}]
   }
   set xL [lsort -real $xL]; set yL [lsort -real $yL]
   set rect [format {\ov %d %d %d %d} [lindex $xL 0] [lindex $yL 0]\
     [expr {[lindex $xL 1] - [lindex $xL 0]}]\
     [expr {[lindex $yL 1] - [lindex $yL 0]}]]
   list $state [list $rect $use]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{line}
%   Tk |line| items are expressed using |\m| and |\L| commands; the 
%   |-smooth| option is currently not supported.
%   \begin{tcl}
proc network::rich::topgf::line {coordcmd opts ns pos div} {
   foreach {state use opts} [_opts2state $opts 1 1] break
   if {[dict exists $opts -smooth] &&\
     ![string is false [dict get $opts -smooth]]} then {
       return -code error "The -smooth option is not supported yet"
   }
   set draw {}
   set x0 ""; set y0 ""
   foreach {x y} [namespace eval $ns $coordcmd $pos] {
      if {$x0 eq ""} then {
         set x0 [expr {round($x*$div)}]
         set y0 [expr {round(-$y*$div)}]
         lappend draw [format {\m %d %d} $x0 $y0]
      } else {
         set x [expr {round($x*$div)}]
         set y [expr {round(-$y*$div)}]
         lappend draw [format {\L %d %d} [expr {$x-$x0}] [expr {$y-$y0}]]
         set x0 $x; set y0 $y
      }
   }
   lappend draw $use
   list $state $draw
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{polygon}
%   Tk |polygon| items are expressed using |\m|, |\L|, and |\h| 
%   commands. The |-smooth| option is currently not supported.
%   \changes{2.6}{2011/01/18}{Implemented polygons for PGF. (LH)}
%   \begin{tcl}
proc network::rich::topgf::polygon {coordcmd opts ns pos div} {
   foreach {state use opts} [_opts2state $opts 0 1] break
   if {[dict exists $opts -smooth] &&\
     ![string is false [dict get $opts -smooth]]} then {
       return -code error "The -smooth option is not supported yet"
   }
   set draw {}
   set x0 ""; set y0 ""
   foreach {x y} [namespace eval $ns $coordcmd $pos] {
      if {$x0 eq ""} then {
         set x0 [expr {round($x*$div)}]
         set y0 [expr {round(-$y*$div)}]
         lappend draw [format {\m %d %d} $x0 $y0]
      } else {
         set x [expr {round($x*$div)}]
         set y [expr {round(-$y*$div)}]
         lappend draw [format {\L %d %d} [expr {$x-$x0}] [expr {$y-$y0}]]
         set x0 $x; set y0 $y
      }
   }
   lappend draw {\h} $use
   list $state $draw
}
%   \end{tcl}
% \end{proc}
% 
% \begin{variable}{licr_map}
%   One basic problem is that of characters for which one would 
%   normally use a control sequence. The relationship between 
%   character and command are pretty arbitrary, so it is probably 
%   best done as a |string map|. This |licr_map| variable holds a 
%   mapping from characters to \LaTeX\ text counterparts.
%   
%   At the moment, this only does something for characters in the 
%   visible ASCII range, but one could consider extending it to 
%   larger character sets (\texttt{utf8enc.dfu} would be a good 
%   starting point for data about this mapping).
%   \begin{tcl}
namespace eval network::rich::topgf {
   variable licr_map {
      { } ~
%   \end{tcl}
%   Expressing spaces as |~| is primarily good for ensuring proper 
%   parsing, particularly avoiding that spaces are lost. It also 
%   prevents linebreaks, but that is probably enforced by a 
%   surrounding |\mbox| or |\fbox| anyway.
%   \begin{tcl}
      #   {\#}
      $   {\textdollar }
      %   {\%}
      &   {\&}
%   \end{tcl}
%   There might be a point in transforming the quotes as well, namely 
%   to prevent unintended ligatures, but that is not an urgent issue.
%   \begin{tcl}
      <   {\textless }
      >   {\textgreater }
      \\  {\textbackslash }
      ^   {\textasciicircum }
      _   {\textunderscore }
      \{  {\textbraceleft }
      |   {\textbar }
      \}  {\textbraceright }
      ~   {\textasciitilde }
   }
}
%   \end{tcl}
%   If this map yields unsatisfactory results, then the user should 
%   extend it.
% \end{variable}
% 
% \begin{proc}{text}
%   Tk |text| items are expressed using |\TR| commands (indeed, that 
%   command exists mainly to support |text| items).
%   
%   The options of |text| items are rather different from those 
%   handled by |_opts2state|, so it seems best to have an explicit 
%   parsing round.
%   \begin{tcl}
proc network::rich::topgf::text {coordcmd opts ns pos div} {
   variable licr_map
   set labeltext ""
   set fontcmd ""
   set colcmd ""
   set anchor "center"
   set angle 0
   foreach {opt val} $opts {
      switch -- $opt -anchor {
         switch -- $val {
            n  {set anchor north}
            ne {set anchor "north east"}
            e  {set anchor east}
            se {set anchor "south east"}
            s  {set anchor south}
            sw {set anchor "south west"}
            w  {set anchor west}
            nw {set anchor "north west"}
            c - ce - cen - cent - cente - center {
               set anchor center
            }
         }
      } -angle {
         set angle [string trimright\
           [string trimright [format %f $val] 0] .]
      } -fill {
         foreach {use col} [_colour $val] break
         if {$use} then {
            set colcmd "\\color{$col}"
         } else {
            set colcmd ""
         }
      } -font {
         set fontcmd [_Tkfont $val $div]
      } -text {
         set labeltext [string map $licr_map $val]
      }
   }
%   \end{tcl}
%   The coordinates are on the other hand very straightforward. The 
%   most trouble is to handle spaces in arguments.
%   \begin{tcl}
   foreach {x y} [namespace eval $ns $coordcmd $pos] break
   set draw {\TR}
   append draw " " [expr {round($x*$div)}] " " [expr {-round($y*$div)}]
   if {[string match "* *" $anchor]} then {
      set anchor "{$anchor}"
   }
   set text "$fontcmd$colcmd"
   if {[string match {*[A-Za-z]} $text] &&\
     [string match {[A-Za-z]*} $labeltext]} then {
      append text {\/}
   }
   append text $labeltext
   if {[string match "* *" $text]} then {set text "{$text}"}
   append draw " " $angle " " $anchor " " $text
   return [list {} [list $draw]]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{_Tkfont}
%   This procedure converts a Tk font description to \LaTeX\ commands 
%   making an equivalent font selection. The call syntax is
%   \begin{displaysyntax}
%     |_Tkfont| \word{font description} \word{division}
%   \end{displaysyntax}
%   and the return value is just \LaTeX\ code.
%   
%   Since Tk implements several font description formats, matching it 
%   fully is a bit tricky. Right now only the option--value form is 
%   supported. Others could be supported through a helper command 
%   that converts to option--value form, as that could be shared with 
%   the SVG counterpart of this command.
%   
%   The settings for the various NFSS axes are collected in the |A| 
%   array, which contains actual setting commands.
%   \begin{tcl}
proc network::rich::topgf::_Tkfont {descr div} {
   dict for {opt val} $descr {
      switch -- $opt -family {
%   \end{tcl}
%   The standard families |Times|, |Helvetica|, and |Courier| are 
%   not taken literally, but rather as aliases for |\rmdefault|, 
%   |\sfdefault|, and |\ttdefault|. 
%   \begin{tcl}
         case -- $val Times {
            set A(family) {\fontfamily{\rmdefault}}
         } Courier {
            set A(family) {\fontfamily{\ttdefault}}
         } Times {
            set A(family) {\fontfamily{\sfdefault}}
         }
      } -size {
         if {$val>0} then {
            set A(size) "\\Fs\{[string trimright [string trimright\
              [format %f $val] 0] .]bp\}"
%   \end{tcl}
%   Yes, Tk points are translated to \TeX\ |bp|. The difference is 
%   tiny, but one might as well do it right.
%   \begin{tcl}
         } else {
            set A(size) [format {\Fs{%s}} [expr {-$val*$div}]]
         }
      } -weight {
         case -- $val normal {
            set A(series) {\fontseries{\mddefault}}
         } bold {
            set A(series) {\fontseries{\bfdefault}}
         }
      } -slant {
         case -- $val roman {
            set A(shape) {\fontshape{n}}
         } italic {
            set A(shape) {\fontshape{it}}
         }
      }
   }
%   \end{tcl}
%   Then the commands are combined into a command string, which sets 
%   the parameters in reverse order of how they appear in \TeX\ font 
%   command names.
%   \begin{tcl}
   set res [append A(size) ""][append A(shape) ""][append A(series) ""]
   append res [append A(family) ""] {\selectfont}
%   \end{tcl}
%   Finally some mappings are made to fold |\selectfont| into another 
%   command, if possible.
%   \begin{tcl}
   set res [string map {
      {\fontfamily{\rmdefault}\selectfont} {\rmfamily}
      {\fontfamily{\sfdefault}\selectfont} {\sffamily}
      {\fontfamily{\ttdefault}\selectfont} {\ttfamily}
      {\fontseries{\mddefault}\selectfont} {\mdseries}
      {\fontseries{\bfdefault}\selectfont} {\bfseries}
      {\fontshape{n}\selectfont}           {\upshape}
      {\fontshape{it}\selectfont}          {\itshape}
   } $res]
   regsub {^\\Fs(\{[0-9a-z]*\})\\selectfont$} $res {\\FS\1} res
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \setnamespace{network::rich}
% 
% \begin{proc}{layout_as_PGF}
%   The |layout_as_PGF| procedure produces \LaTeX\ code displaying the 
%   \emph{layout} of a rich network (but not the network as such). 
%   The rich network must have the following entries:
%   \begin{ttdescription}
%     \item[level-layout-Tk]
%       This is the basic source of information about the position of 
%       items in the network layout. Items are drawn as rectangles.
%     \item[pure]
%       Is used to translate vertex item numbers to decorations, so 
%       that their sizes can be determined.
%     \item[ecurve-Tk-raw]
%       This is used for determining links between levels: a link is 
%       a curve segment where the control points do not coincide with 
%       the knot points.
%     \item[bbox-Tk]
%       This provides the bounding box.
%   \end{ttdescription}
%   
%   The call syntax is
%   \begin{displaysyntax}
%     |network::rich::layout_as_PGF| \word{vertex-sizes} 
%     \begin{regblock}[\regplus] \word{option} \word{value} 
%     \end{regblock}
%   \end{displaysyntax}
%   where the \word{vertex-sizes} is, as with |make_level-layout-Tk|, 
%   a pattern--size list.
%   
%   The available options are
%   \begin{ttdescription}
%     \item[-val] Standard pass-network-by-value option.
%     \item[-var] Standard pass-network-by-variable option.
%     \item[-unit]
%       \LaTeX\ length corresponding to the unit in the network.
%     \item[-division]
%       The unit actually used in the result will be the value of 
%       |-unit| divided by the value of |-division|; setting 
%       |-division| to $2$ can avoid making a lot of coordinates 
%       ending in |.5|. Defaults to |1|.
%     \item[-itemboxcol]
%       The colour of item boxes. Defaults to |red|.
%     \item[-linkthickness]
%       The thickness of link lines. Defaults to not being set.
%   \end{ttdescription}
%   In addition, the |-edgew| and |-edgeh| options of 
%   |level-layout-Tk_defaults| are taken note of.
%   
%   \begin{tcl}
proc network::rich::layout_as_PGF {vertexSizes args} {
   variable level-layout-Tk_defaults
   array set Opt ${level-layout-Tk_defaults}
   array set Opt {-unit 1pt -division 1 -round 1 -itemboxcol red}
   array set Opt $args
   if {[info exists Opt(-val)]} then {
      array set NW $Opt(-val)
   } elseif {[info exists Opt(-var)]} then {
      upvar 1 $Opt(-var) NW
   } else {
      error "Must specify -val or -var"
   }
   set factor 1.0; set unit pt
   scan $Opt(-unit) %f%s factor unit
   set factor [expr {$factor/$Opt(-division)}]
%   \end{tcl}
%   Coordinates are collected explicitly for a bounding box 
%   calculation, since the leg-item boxes actually extend beyond the 
%   network bounding box.
%   \begin{tcl}
   foreach {x y} $NW(bbox-Tk) {
      append xL [expr {round($x*$Opt(-division))}]
      append yL [expr {round(-$y*$Opt(-division))}]
   }
%   \end{tcl}
%   First the items are drawn, since one wants these to be below the 
%   links in stacking order.
%   \begin{tcl}
   set res {  \begin{pgfscope}} \n
   set texcol [topgf::_colour $Opt(-itemboxcol)]
   if {[lindex $texcol 0]} then {
      append res [format {    \pgfsetcolor{%s}} [lindex $texcol 1]] \n
   }
   foreach {component bbox} $NW(level-layout-Tk) {
      foreach {level ymid hlvl} $component {
         foreach item $level {
            switch -- [lindex $item 0] "edge" {
               set w $Opt(-edgew)
               set h $Opt(-edgeh) ; #[expr {2*$hlvl}] 
            } "vertex" {
               set annot [lindex $NW(pure) 0 [lindex $item 1] 0]
               foreach {pat sizes} $vertexSizes {
                  if {[string match $pat $annot]} then {
                     foreach {w h} $sizes break
                     break
                  }
               }
            }
            set x0 [expr {round($factor*([lindex $item 2] - 0.5*$w))}]
            set y0 [expr {round($factor*(-$ymid - 0.5*$h))}]
            set w [expr {round($factor*$w)}]
            set h [expr {round($factor*$h)}]
            append res\
              [format {    \re %d %d %d %d \S} $x0 $y0 $w $h] \n
            lappend xL $x0 [expr {$x0 + $w}]
            lappend yL $y0 [expr {$y0 + $h}]
         }
      }
   }
   append res {  \end{pgfscope}} \n
%   \end{tcl}
%   Then the links are drawn. This is inside a |pgfscope| where the 
%   line widths and line caps are set.
%   \begin{tcl}
   append res {  \begin{pgfscope}} \n
   if {[info exists Opt(-linkthickness)]} then {
      if {![regexp {[A-Za-z]} $Opt(-linkthickness)]} then {
         set Opt(-linkthickness) [format {%s\sdpgfunit}\
           [expr {$factor*$Opt(-linkthickness)}]]
      }
      append res\
        [format {    \pgfsetlinewidth{%s}} $Opt(-linkthickness)] \n
   }
   append res {    \pgfsetroundcap} \n
   foreach L $NW(ecurve-Tk-raw) {
      set dataL {}
      foreach {x y} $L {
         lappend dataL [expr {round($x*$Opt(-division))}]\
           [expr {round(-$y*$Opt(-division))}]
      }
      foreach {x0 y0} $dataL break
      foreach {x1 y1 x2 y2 x3 y3} [lrange $dataL 2 end] {
         set a [expr {$x3 - $x0}]
         set b [expr {$y3 - $y0}]
         set c [expr {$x1 - $x0}]
         set d [expr {$y1 - $y0}]
         set e [expr {$x2 - $x3}]
         set f [expr {$y2 - $y3}]
         if {hypot($c,$d) > 0.00002 || hypot($e,$f) > 0.00002} then {
            append res\
              [format {    \m %d %d \L %d %d \S} $x0 $y0 $a $b] \n
         }
         set x0 $x3; set y0 $y3
      }
   }
   append res {  \end{pgfscope}} \n
%   \end{tcl}
%   Finally wrap it all up with bounding box data.
%   \begin{tcl}
   set xL [lsort -integer $xL]
   set yL [lsort -integer $yL]
   format "\\begin{sdpgf}{%d}{%d}{%d}{%d}{%s}{%s}\n%s\\end{sdpgf}" \
     [lindex $xL 0] [lindex $yL end] [lindex $xL end] [lindex $yL 0]\
     $factor $unit $res
}
%   \end{tcl}
% \end{proc}
% 
% \begin{tcl}
%</pkg>
% \end{tcl}
% 
% 
% \section{Minor utility procedures}
% 
% \begin{proc}{network_as_LaTeX}
%   Together with |network::pure::construct|, this is very convenient 
%   when one is writing papers.
%   \begin{tcl}
%<*util>
variable vertex_sizes {* {20 20}}
proc network_as_LaTeX {NW args} {
   set A(pure) $NW
   variable Hopf_appearance
   variable vertex_sizes
   network::rich::make_level-layout-Tk $vertex_sizes {*}$args -var A
   network::rich::vpos-Tk_by_level -var A
   network::rich::ecurve-Tk-raw_by_level $Hopf_appearance {*}$args -var A
   return "\\left\[ [
     network::rich::as_PGF $Hopf_appearance {*}$args -var A
   ] \\right\]"
}
%</util>
%   \end{tcl}
% \end{proc}
% 
% \begin{thebibliography}{8}
% 
% \bibitem{AroraLeeNaor}
%    \textsc{Sanjeev Arora}, \textsc{James R. Lee}, and 
%    \textsc{Assaf Naor}:
%    Euclidean distortion and the Sparsest Cut,
%    \textit{J. Amer. Math. Soc.} \textbf{21} (2008), no. 1, 1--21.
% 
% \bibitem{Colley}
%    \textsc{Wesley N. Colley}: 
%    \textit{Colleys Bias Free College Football Ranking Method: 
%    The Colley Matrix Explained} (2003), 23~pp. 
%    Retrieved 18 November 2006 from \textsc{http:}/\slash
%    \texttt{www.colleyrankings.com}\slash \texttt{matrate.pdf}.
% 
% \bibitem{CMfonts}
%    \textsc{Donald E. Knuth}:
%    \textit{Computer Modern Typefaces} 
%    (volume E of \textit{Digital Typography}),
%    Addison-Wesley, 1986.
%    See also directory \texttt{fonts}\slash \texttt{cm}\slash 
%    \texttt{mf} in the Comprehensive \TeX\ Archive 
%    Network~(\texttt{ctan.org}).
% 
% \bibitem{MacLane}
%    \textsc{S. MacLane}:
%    Categorical Algebra,
%    \textit{Bull. Amer. Math. Soc.} \textbf{71} (1965), 40--106.
%    
% \bibitem{skiplist}
%    \textsc{William Pugh}: 
%    Skip lists: a probabilistic alternative to balanced trees,
%    \textit{Communications of the ACM}, June 1990, \textbf{33} (6), 
%    668-676.
% 
% \bibitem{Stefanescu}
%    \textsc{Gheorghe \c{S}tef\u{a}nescu}:
%    \textit{Network Algebra},
%    Springer, 2000; \ISBN~1-85233-195-\ISBNX.
% 
% \end{thebibliography}
% 
% 
\endinput
