% 
% \iffalse
%<*driver>
\documentclass{mtmtcl}
\begin{document}
\DocInput{tryout.dtx}
\end{document}
%</driver>
% \fi
% 
% \title{Some code fragments for trying out \mtl\ features}
% \author{Lars Hellstr\"om}
% \maketitle
% 
% \begin{abstract}
%   Since the term `test' has rather formal interpretation 
%   (\textsf{tcltest}, \texttt{.test} file) within the \Tcl\ 
%   community, these less organised tests are instead called tryouts. 
%   Basically they aim to achieve something with some feature, but 
%   may in the process make use of lots of other features, so they're 
%   not very isolated.
% \end{abstract}
% 
% 
% \section{Prefix}
% 
% The following loads the code in the basic files, using the 
% \textsf{docstrip} package. This is to facilitate |source|ing this 
% code into an interpreter.
% \begin{tcl}
%<*loadbase>
if {[info script] ne ""} then {
   set dir [file dirname [info script]]
} elseif {[info exists env(MTMTCL_SOURCE_DIR)]} then {
   set dir $env(MTMTCL_SOURCE_DIR)
} else {
   set dir ~/Projekt/Tcl-projekt/Algebra
}
if {[catch {
   package require APIutil
}]} then {
   source [file join [file dirname $dir] API apiutil.tcl]
}
package require docstrip
docstrip::sourcefrom [file join $dir export.dtx] {pkg}
docstrip::sourcefrom [file join $dir support.dtx] {pkg}
docstrip::sourcefrom [file join $dir groups.dtx] {}
docstrip::sourcefrom [file join $dir rings.dtx] {}
%</loadbase>
% \end{tcl}
% 
% 
% \section{Exporting a polynomial}
% 
% The idea for the following is to construct the polynomial 
% $\prod_{i=1}^4 (x -\nobreak i)$ and export it.
% 
% The first order of business is to construct a polynomial ring 
% $\mathbb{Z}[x]$. It can be done as the semigroup algabra over $\Z$ 
% of the abelian monoid generated by the finite set $\{x\}$, so we 
% end up with
% \begin{tcl}
%<*univpoly>
interp alias {} Zx {} ::mtmtcl::rings::semigroup_algebra {
   ::mtmtcl::rings::integer
} {
   ::mtmtcl::groups::power_product_monoid_1.3 {
      ::mtmtcl::sets::variable_set {x} {}
   }
}
% \end{tcl}
% For the future, it might actually be easier to keep that as a 
% command prefix in a variable, but for now an alias is fine.
% It is also likely that this construction should be provided by a 
% procedure, so that users won't have to concern themselves with the 
% syntax of the component structures (much).
% 
% Now for the actual polynomial. Since it is constructed as a 
% product, it is naturally computed in a loop where each iteration 
% computes one factor and multiplies it into the product. For the 
% purpose of computing the factor, it is however convenient to have 
% precomputed the |Zx| representations of $1$ and $x$.
% \begin{tcl}
set unit [Zx 1]
set x [Zx basiselement [Zx basis named x]]
set prod $unit
foreach i {1 2 3 4} {
   set prod [Zx * $prod [
      Zx - $x [Zx . [Zx scalar 1 $i] $unit]
   ]]
}
% \end{tcl}
% Even then the computation is rather roundabout, so one should 
% probably see to that |semigroup_algebra| implements an |integer.| 
% method.
% 
% But with that taken care of, we get to the main point of business: 
% exporting this polynomial.
% \begin{tcl}
set raw [Zx export $prod {}]
set typo [mtmtcl::present::typography $raw]
% \end{tcl}
% As far as exercises of edge cases go, this product is rather good. 
% It shows both a naked power term ($x^4$), product-and-power terms 
% ($-10x^3$ and $35x^2$), term without power ($-50x$), and naked 
% integer term ($24$).
% 
% If we're targeting OpenMath, then the next step would be
% \begin{tcl}
set strict [mtmtcl::openmath::stricten\
  {*}[mtmtcl::openmath::oma $typo *] 1]
% \end{tcl}
% In order to generate XML, it is convenient to use the \textsf{tdom} 
% package so that we get some indentation.
% \begin{tcl}
%<*tdom>
package require tdom
dom createDocumentNode obj
$obj appendFromList [list OMOBJ {} [list $strict]]
puts [$obj asXML]
unset obj
%</tdom>
% \end{tcl}
% 
% If we're targetting \LaTeX, there is a command which does all the 
% formatting.
% \begin{tcl}
set code [mtmtcl::latex::convertto $raw]
puts $code
% \end{tcl}
% 
% 
% 
% \begin{tcl}
%</univpoly>
% \end{tcl}
% 
% 
% \section{Exporting to \LaTeX}
% 
% The following tests the generation of \LaTeX\ code for formulae.
% \begin{tcl}
%<*LaTeX.export>
% \end{tcl}
% Since the last steps were completed first, that is where this will 
% start.
% 
% The first formula is \(f\bigl( g(a+b) - g(a,b)^2 \bigr)\).
% \begin{tcl}
set tree {mrow {} {
   {{#text} f} 
   {mfenced {} {
      {mrow {} {
         {mrow {} {
            {#text g}
            {mfenced {} { {mrow {} {
               {#text a} {#text +} {#text b}
            }} }}
         }}
         {#text -}
         {mrow {} {
            {mrow {} {
               {#text g}
               {mfenced {expand 1} {
                  {#text a} {#text b}
               }}
            }}
            {#text ^}
            {maybewrap {} { {#text 2} }}
         }}
      }}
   }}
}}
set temp [mtmtcl::latex::metax:: {*}$tree]
set tree [lindex $temp 0]
set code [mtmtcl::latex::fold $tree 20 1]
% \end{tcl}
% 
% 
% \begin{tcl}
%</LaTeX.export>
% \end{tcl}
% 
% 
% \section{PROP-expression comparisons}
% 
% The following is an attempt to find coefficients in a 
% representation of the free bialgebra PROP under which the matrix 
% order would order the axioms as I want them.
% 
% \begin{tcl}
%<*PROPcompare>
%<*loadbase>
docstrip::sourcefrom [file join $dir props.dtx] {pkg}
%</loadbase>
% \end{tcl}
% 
% \subsection{First attempt}
% 
% In this approach, the multiplication and comultiplication 
% representatatives are upper triangular with $1$ in the upper left 
% corner.
% 
% \begin{tcl}
interp alias {} Coeff_ring {} ::mtmtcl::rings::semigroup_algebra {
   ::mtmtcl::rings::integer
} {
   ::mtmtcl::groups::power_product_monoid_1.3 {
      ::mtmtcl::sets::variable_set {A B C D E F a b c d e f} {}
   }
}
interp alias {} PROP {} mtmtcl::matprop::homfdpower 2 Coeff_ring
% \end{tcl}
% 
% \begin{tcl}
set epsilon [list [
   list [Coeff_ring basiselement [Coeff_ring basis named E]]\
     [Coeff_ring basiselement [Coeff_ring basis named F]]
]]
set code [mtmtcl::latex::convertto [PROP export $epsilon {}]]
% \end{tcl}
% 
% 
% 
% \begin{tcl}
set Delta [
   list [
      list [Coeff_ring 1] [Coeff_ring named A]
   ] [
      list [Coeff_ring 0] [Coeff_ring named B]
   ] [
      list [Coeff_ring 0] [Coeff_ring named C]
   ] [
      list [Coeff_ring 0] [Coeff_ring named D]
   ]
]
set code [mtmtcl::latex::convertto [PROP export $Delta {}]]
% \end{tcl}
% 
% \begin{tcl}
set DeltaDelta [PROP tensor $Delta $Delta]
set code [mtmtcl::latex::convertto [PROP export $DeltaDelta {}]]
% \end{tcl}
% 
% \begin{tcl}
set mult [
   list [
      list [Coeff_ring 1] [Coeff_ring named a] [Coeff_ring named b]\
        [Coeff_ring named c]
   ] [
      list [Coeff_ring 0] [Coeff_ring 0] [Coeff_ring 0]\
        [Coeff_ring named d]
   ]
]
set code [mtmtcl::latex::convertto [PROP export $mult {}]]
% \end{tcl}
% 
% \begin{tcl}
set Delta_mult [PROP * $Delta $mult]
set reduced_Delta_mult [PROP * [
   PROP tensor $mult $mult
] [
   PROP perm. {0 2 1 3} $DeltaDelta
]]
set diff [PROP - $Delta_mult $reduced_Delta_mult]
set code [mtmtcl::latex::convertto [PROP export $diff {}]]
% \end{tcl}
% 
% \begin{equation} \label{Eq:Delta_mult}
%   \hss
%   \begin{pmatrix} 0 & a - A - B a - C a - D a^2 & 
%       b - A - B b - C b - D b^2 & 
%         \parbox{0.4\linewidth}{\(c + A d - A^2 - A B a - A B b - 
%         B^2 c - A C a - A D a^2 - 2 B C a b - B D a c - A C b - 
%         A D b^2 - B D b c - C^2 c - C D a c - C D b c - D^2 c^2\)}
%     \\ 0 & 0 & 0 & B d - B^2 d - B D a d - B D b d - D^2 c d \\ 
%     0 & 0 & 0 & C d - C^2 d - C D a d - C D b d - D^2 c d \\ 
%     0 & 0 & 0 & D d - D^2 d^2 \end{pmatrix} > 0
% \end{equation}
% 
% \begin{tcl}
set counit_Delta1 [PROP * [PROP tensorpad $epsilon 1] $Delta]
set counit_Delta2 [PROP *\
  [PROP tensor [PROP permutation 0] $epsilon] $Delta]
set diff1 [PROP - $counit_Delta1 [PROP permutation 0]]
set diff2 [PROP - $counit_Delta2 [PROP permutation 0]]
set code "
  [mtmtcl::latex::convertto [PROP export $diff1 {}]],
  [mtmtcl::latex::convertto [PROP export $diff2 {}]]"
% \end{tcl}
% \begin{equation} \label{Eq:epsilon_Delta}
%   \begin{pmatrix} E - 1 & A E + B F \\ 0 & C E + D F - 1 
%     \end{pmatrix} ,
%   \begin{pmatrix} E - 1 & A E + C F \\ 0 & B E + D F - 1 
%     \end{pmatrix} 
%   > 0
% \end{equation}
% 
% \begin{tcl}
set counit_counit [PROP tensor $epsilon $epsilon]
set counit_mult [PROP * $epsilon $mult]
set diff [PROP - $counit_mult $counit_counit]
set code [mtmtcl::latex::convertto [PROP export $diff {}]]
% \end{tcl}
% \begin{equation} \label{Eq:epsilon_mult}
%   \begin{pmatrix} 
%     E - E^2 & E a - E F & E b - E F & E c + F d - F^2 
%   \end{pmatrix} > 0
% \end{equation}
% 
% Conclusion: \(E = 1\). At least one variable less! Is it the same 
% for $e$?
% 
% \begin{tcl}
set unit [list [
   list [Coeff_ring named e]
] [
   list [Coeff_ring named f]
]]
set code [mtmtcl::latex::convertto [PROP export $unit {}]]
% \end{tcl}
% 
% \begin{tcl}
set mult_unit1 [PROP * $mult [PROP tensorpad $unit 1]]
set mult_unit2 [PROP * $mult [PROP tensor [PROP permutation 0] $unit]]
set diff1 [PROP - $mult_unit1 [PROP permutation 0]]
set diff2 [PROP - $mult_unit2 [PROP permutation 0]]
set code "
  [mtmtcl::latex::convertto [PROP export $diff1 {}]],
  [mtmtcl::latex::convertto [PROP export $diff2 {}]]"
% \end{tcl}
% \begin{equation} \label{Eq:mult_unit}
%   \begin{pmatrix} e + a f - 1 & b e + c f \\ 0 & d f - 1 \end{pmatrix} ,
%   \begin{pmatrix} e + b f - 1 & a e + c f \\ 0 & d f - 1 \end{pmatrix} 
%   > 0
% \end{equation}
% It appears not, but what is then the conclusion?
% 
% \begin{tcl}
set unit_unit [PROP tensor $unit $unit]
set Delta_unit [PROP * $Delta $unit]
set diff [PROP - $Delta_unit $unit_unit]
set code [mtmtcl::latex::convertto [PROP export $diff {}]]
% \end{tcl}
% \begin{equation} \label{Eq:Delta_unit}
%   \begin{pmatrix}
%     e + A f - e^2 \\ B f - e f \\ C f - e f \\ D f - f^2 
%   \end{pmatrix} > 0
% \end{equation}
% 
% Easy conclusions:
% \begin{enumerate}
%   \item
%     By \eqref{Eq:epsilon_Delta} and \eqref{Eq:epsilon_mult}, 
%     \(E=1\). Hence
%     \begin{align*}
%       a \geqslant{}& F  & 
%       b \geqslant{}& F \\
%       c \geqslant{}& F^2 - Fd \\
%       DF \geqslant{}& 1-C  &
%       DF \geqslant{}& 1-B
%     \end{align*}
%   \item
%     By \eqref{Eq:Delta_mult}, \(Dd \leqslant 1\).
%   \item
%     By \eqref{Eq:mult_unit}, \(df \geqslant 1\).
%   \item
%     By \eqref{Eq:Delta_unit}, \(Af \geqslant e^2 - e\).
%     Also, \(B,C \geqslant e\) and \(D \geqslant f\).
% \end{enumerate}
% Unfortunately, \(C d - C^2 d - C D a d - C D b d - D^2 c d = 
% (C - C^2 - C D a - C D b - D^2 c) d \geqslant 0\) by 
% \eqref{Eq:Delta_mult} but
% \begin{multline*}
%   C - C^2 - C D a - C D b =
%   C ( 1 - C - D a - D b) \leqslant
%   C ( DF - D a - D b ) = 
%   CD ( F - a - b) < 0
% \end{multline*}
% so there is a contradiction.
% 
% The best way to overcome this appears to be to let go of the 
% restriction that the upper left corner element in $\mathit{mult}$ and 
% $\Delta$ is $1$. It may seem that rescaling shouldn't buy us 
% anything if we anyway control all coefficients, but that isn't 
% true; the $1$s in the identity map (and other permutations) and the 
% $1$ of the nullary tensor product are unavoidable. Letting the 
% upper left corner drop below $1$ may well hold the key to making 
% $\Delta\otimes\Delta$ less than $\Delta$.
% 
% 
% \subsection{Second attempt}
% 
% So, we add two variables $G$ and $g$ for what used to be $1$. We 
% also list the variables in a different order to make $D$ and $d$ 
% show up next to each other.
% \begin{tcl}
interp alias {} Coeff_ring {} ::mtmtcl::rings::semigroup_algebra {
   ::mtmtcl::rings::integer
} {
   ::mtmtcl::groups::power_product_monoid_1.3 {
      ::mtmtcl::sets::variable_set {A a B b C c D d E e F f G g} {}
   }
}
interp alias {} PROP {} mtmtcl::matprop::homfdpower 2 Coeff_ring
% \end{tcl}
% Another difference is to use the |fuse| method when constructing 
% terms to compare.
% 
% \begin{proc}{fusediff}
%   This procedure takes two arguments, which have the form of |fuse| 
%   argument sequences except that the ``factors'' are indices into 
%   the |PROPgen| array of the actual factors. These are then 
%   |fuse|d, and the second is subtracted from the first, after which 
%   the difference is returned.
%   \begin{tcl}
proc fusediff {term1 term2} {
   variable PROPgen
   set call1 [list PROP fuse {*}[lrange $term1 0 1]]
   foreach {name h t} [lrange $term1 2 end] {
      lappend call1 $PROPgen($name) $h $t
   }
   set call2 [list PROP fuse {*}[lrange $term2 0 1]]
   foreach {name h t} [lrange $term2 2 end] {
      lappend call2 $PROPgen($name) $h $t
   }
   PROP - [eval $call1] [eval $call2]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{arrayvar}{PROPgen}
%   Except for the $g$ and $G$ entries, the generator values are 
%   constructed as above.
%   \begin{tcl}
set PROPgen(epsilon) [list [
   list [Coeff_ring named E] [Coeff_ring named F]
]]
set PROPgen(Delta) [
   list [
      list [Coeff_ring named G] [Coeff_ring named A]
   ] [
      list [Coeff_ring 0]       [Coeff_ring named B]
   ] [
      list [Coeff_ring 0]       [Coeff_ring named C]
   ] [
      list [Coeff_ring 0]       [Coeff_ring named D]
   ]
]
set PROPgen(mu) [
   list [
      list [Coeff_ring named g] [Coeff_ring named a]\
        [Coeff_ring named b] [Coeff_ring named c]
   ] [
      list [Coeff_ring 0] [Coeff_ring 0] [Coeff_ring 0]\
        [Coeff_ring named d]
   ]
]
set PROPgen(unit) [
   list [
      list [Coeff_ring named e]
   ] [
      list [Coeff_ring named f]
   ]
]
%   \end{tcl}
% \end{arrayvar}
% 
% Now for the list of pairs to compare.
% \begin{tcl}
set diffL {}
lappend diffL [fusediff {o1 o1 mu {m1 m2} m1 unit {} m2} {e e}]
lappend diffL [fusediff {o1 o1 mu {m2 m1} m1 unit {} m2} {e e}]
lappend diffL [fusediff {
  o1 o1 mu {m1 m2} m2 mu {i1 i2} {m1 i1 i2}
} {
  o1 o1 mu {m1 m2} m1 mu {i1 i2} {i1 i2 m2}
}]
% 
lappend diffL [fusediff {
  o1 {o1 m2} Delta i1 {} epsilon m2 i1
} {e e}]
lappend diffL [fusediff {
  o1 {m2 o1} Delta i1 {} epsilon m2 i1
} {e e}]
lappend diffL [fusediff {
  {o1 o2 o3} {o2 o3} Delta m1 {o1 m1} Delta i1 i1
} {
  {o1 o2 o3} {o1 o2} Delta m1 {m1 o3} Delta i1 i1
}]
%
lappend diffL [fusediff {
  {} {} epsilon m1 m1 unit {} {}
} {"" ""}]
lappend diffL [fusediff {
  {} {} epsilon m1 m1 mu {i1 i2} {i1 i2}
} {
  {} {} epsilon i1 {} epsilon i2 {i1 i2}
}]
lappend diffL [fusediff {
  {o1 o2} {o1 o2} Delta m1 m1 unit {} {}
} {
  {o1 o2} o1 unit {} o2 unit {} {}
}]
lappend diffL [fusediff {
  {o1 o2} {o1 o2} Delta m1 m1 mu {i1 i2} {i1 i2}
} {
  {o1 o2} o1 mu {m0 m1} o2 mu {m2 m3}
  {m0 m2} Delta i1 {m1 m3} Delta i2 {i1 i2}
}]
% \end{tcl}
% 
% And finally, made code of this list.
% \begin{tcl}
set codeL {}
foreach item $diffL {
   lappend codeL [mtmtcl::latex::convertto [PROP export $item {}]]
}
set code "\\begin{gather}\n  [
   join $codeL "\n  \\\\\n  "
]\n\\end{gather}"
% \end{tcl}
% And the result is:
% \begin{gather}
%   \begin{pmatrix} e g + a f - 1 & b e + c f \\ 0 & d f - 1 
%     \end{pmatrix} 
%   \\
%   \begin{pmatrix} e g + b f - 1 & a e + c f \\ 0 & d f - 1 
%     \end{pmatrix} 
%   \\
%   \begin{pmatrix} 0 & 0 & a g - b g & a^2 - c g - a d & 0 & 0 & 
%       c g + b d - b^2 & a c - b c 
%     \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \end{pmatrix} 
%   \\
%   \begin{pmatrix} E G - 1 & A E + C F \\ 0 & B E + D F - 1 
%     \end{pmatrix} 
%   \\
%   \begin{pmatrix} E G - 1 & A E + B F \\ 0 & C E + D F - 1 
%     \end{pmatrix} 
%     \label{Eq2:epsilon_Delta}
%   \\
%   \begin{pmatrix} 0 & A C - A B \\ 0 & B G + A D - B^2 \\ 0 & 0 \\ 
%     0 & 0 \\ 0 & C^2 - C G - A D \\ 0 & C D - B D \\ 0 & 0 \\ 0 & 0 
%     \end{pmatrix} 
%   \\
%   \begin{pmatrix} E e + F f - 1 \end{pmatrix} 
%   \\
%   \begin{pmatrix} E g - E^2 & a E - E F & b E - E F & c E + d F - F^2 
%     \end{pmatrix}
%     \label{Eq2:epsilon_mu} 
%   \\
%   \begin{pmatrix} e G + A f - e^2 \\ B f - e f \\ C f - e f \\ D f - f^2 
%     \end{pmatrix} 
%   \\
%   \hspace{-3cm}
%   \begin{pmatrix} 
%     G g - G^2 g^2 & 
%       \parbox{0.25\linewidth}{\(
%         a G - A G g^2 - a B G g - a C G g - a^2 D G 
%       \)}& 
%       \parbox{0.25\linewidth}{\(
%         b G - A G g^2 - b C G g - B b G g - b^2 D G
%       \)}& 
%       \parbox{0.4\linewidth}{\(
%       c G + A d - A^2 g^2 - A b C g - A a B g - 2 a B b C - A B b g - 
%         A b^2 D - B^2 c g - B b c D - A a C g - C^2 c g - A a^2 D - 
%         a C c D - b C c D - a B c D - c^2 D^2 
%       \)\vadjust{\kern4pt}}
%     \\ 0 & 0 & 0 & B d - B^2 d g - B b D d - a B D d - c D^2 d \\ 
%     0 & 0 & 0 & C d - C^2 d g - a C D d - b C D d - c D^2 d \\ 
%     0 & 0 & 0 & D d - D^2 d^2 \end{pmatrix} 
%     \label{Eq2:Delta_mu}
% \end{gather}
% Unfortunately, this still runs into the same problem\Ldash which 
% amazingly depends on only three PROP inequalities: \(\mathrm{id} 
% \otimes \varepsilon \circ \Delta \geqslant \mathrm{id}\) 
% \eqref{Eq2:epsilon_Delta} for \(EG \geqslant 1\) and \(1-CE 
% \leqslant DF\), \(\varepsilon \circ \mu \geqslant \varepsilon 
% \otimes \varepsilon\) \eqref{Eq2:epsilon_mu} for \(E (g - E) 
% \geqslant 0\), \(E(a-F) \geqslant 0\), and \(E(b-F) \geqslant 0\), 
% and finally \(\Delta \circ \mu \geqslant \mu\otimes\mu \circ (1\,2) 
% \circ \Delta\otimes\Delta\) \eqref{Eq2:Delta_mu} for \(G g \geqslant 
% G^2 g^2\) and \(C d - C^2 d g - a C D d - b C D d - c D^2 d 
% \geqslant 0\).
% 
% First, \(1 \geqslant Gg \geqslant GE \geqslant 1\) so \(E=g\). 
% Second, \(-a \leqslant -F\) and \(-b \leqslant -F\). Finally, 
% \(C - C^2 g - a C D - b C D - c D^2 \geqslant 0\) so \(cD^2 
% \leqslant C (1 - Cg - aD - bD) \leqslant C (1 - CE - FD - FD) 
% \leqslant -CFD\). This contradicts the positivity of these 
% variables, which is needed for preserving strict compatibility of 
% the matrix order with matrix multiplication. A similar 
% contradiction can be constructed with the dual axiom inequalities.
% 
% 
% \subsection{Third attempt}
% 
% At this point, all hope might seem to be lost; although the 
% possibilities have not been exhausted, the complexity of the 
% inequality systems that need to be solved (and the computational 
% complexity of computing the value of realistic networks) are 
% overwhelming. However, late night inspiration struck and suggested 
% a third PROP\Ldash quickly dubbed `the biaffine PROP'\Dash might be 
% of use in this situation. The definition of this PROP is a 
% restatement of the old path-counting order for networks, and it 
% combines the complexity of the trivial matrix PROP with the 
% $\hom$-PROP's capability to sensibly deal with nullary and 
% nullcoary elements.
% 
% \begin{tcl}
interp alias {} PROP {} mtmtcl::matprop::biaffine ::mtmtcl::rings::integer
if {[catch {
   lrepeat 0 0
}]} then {
   rename lrepeat _lrepeat
   proc lrepeat {num args} {
      if {$num>0 && [llength $args]} then {_lrepeat $num {*}$args}
   }
}
% \end{tcl}
% As in the previous attempt, the |fuse| method it used for constructing 
% terms to compare. The defintion of |fusediff| need not be repeated, 
% as it is the same as above.
% 
% \begin{arrayvar}{PROPgen}
%   The array of generator values is however quite different.
%   \begin{tcl}
set PROPgen(epsilon) [
   PROP fromparts 0 {} 1 {}
]
set PROPgen(Delta) [
   PROP fromparts 0 {0 0} 1 {1 1}
]
%   \end{tcl}
%   The first |1| in that definition represents the great innovation 
%   in this implementation round: a coproduct counts as being the 
%   endpoint for one path, as well as letting two paths through. This 
%   turns out to slant a surprising number of inequalities the right 
%   way.
%   \begin{tcl}
set PROPgen(m) [
   PROP fromparts 0 1 {0 0} {{1 1}}
]
set PROPgen(unit) [
   PROP fromparts 0 1 {} {}
]
set PROPgen(S) [
   PROP fromparts 0 0 0 2
]
%   \end{tcl}
%   Giving the antipode a weight greater than $1$ is another 
%   innovation. When combined with the end-point in a coproduct or 
%   begin-point in a product, it actually forces the antipode past 
%   the product or coproduct, even though this increases the total 
%   number of antipodes.
%   \begin{tcl}
set PROPgen(twist) [PROP permutation {1 0}]
%   \end{tcl}
%   It does not current seem like twists can be penalised at this 
%   level, so they are just treated as simple permutations.
% \end{arrayvar}
% 
% Now for the list of pairs to compare.
% \begin{tcl}
set diffL {}
lappend diffL [fusediff {o1 o1 m {m1 m2} m1 unit {} m2} {e e}]
lappend diffL [fusediff {o1 o1 m {m2 m1} m1 unit {} m2} {e e}]
lappend diffL [fusediff {
  o1 o1 m {m1 m2} m2 m {i1 i2} {m1 i1 i2}
} {
  o1 o1 m {m1 m2} m1 m {i1 i2} {i1 i2 m2}
}]
% 
lappend diffL [fusediff {
  o1 {o1 m2} Delta i1 {} epsilon m2 i1
} {e e}]
lappend diffL [fusediff {
  o1 {m2 o1} Delta i1 {} epsilon m2 i1
} {e e}]
lappend diffL [fusediff {
  {o1 o2 o3} {o2 o3} Delta m1 {o1 m1} Delta i1 i1
} {
  {o1 o2 o3} {o1 o2} Delta m1 {m1 o3} Delta i1 i1
}]
%
lappend diffL [fusediff {
  {} {} epsilon m1 m1 unit {} {}
} {"" ""}]
lappend diffL [fusediff {
  {} {} epsilon m1 m1 m {i1 i2} {i1 i2}
} {
  {} {} epsilon i1 {} epsilon i2 {i1 i2}
}]
lappend diffL [fusediff {
  {o1 o2} {o1 o2} Delta m1 m1 unit {} {}
} {
  {o1 o2} o1 unit {} o2 unit {} {}
}]
lappend diffL [fusediff {
  {o1 o2} {o1 o2} Delta m1 m1 m {i1 i2} {i1 i2}
} {
  {o1 o2} o1 m {m0 m1} o2 m {m2 m3}
  {m0 m2} Delta i1 {m1 m3} Delta i2 {i1 i2}
}]
%
lappend diffL [fusediff {
  o  o m {1 2}  2 S 3  {1 3} Delta i  i
} {
  o {} epsilon i o unit {} i
}]
lappend diffL [fusediff {
  o  o m {1 2}  1 S 3  {3 2} Delta i  i
} {
  o {} epsilon i o unit {} i
}]
% \end{tcl}
% All of these come out non-negative, and all but the 
% (co)associativity rules come out with at least one positive 
% element, which is the best that could be hoped for. Hence this 
% order is a success as far as the axioms go. Time to test it on the 
% total list of derived rules and equalities!
% 
% \begin{proc}{rulediff}
%   This procedure has the call syntax
%   \begin{displaysyntax}
%     rulediff \word{map} \word{rule}
%   \end{displaysyntax}
%   where \word{rule} is a \textsf{cmplutil1} rule and \word{map} is 
%   a dictionary mapping vertex annotations to |PROP| elements. It 
%   |PROP fuse|s both sides of the \word{rule} and returns their 
%   difference (left hand side minus right hand side).
%   \begin{tcl}
proc rulediff {map rule} {
   set sides {}
   foreach NW [list [lindex $rule 0 0] [lindex $rule 2 0]] {
      set call [list PROP fuse]
      lappend call [lindex $NW 0 0 2]
      foreach v [lrange [lindex $NW 0] 2 end] {
         lappend call [lindex $v 1] [dict get $map [lindex $v 0]]\
           [lindex $v 2]
      }
      lappend call [lindex $NW 0 1 1]
      lappend sides [eval $call]
   }
   PROP - {*}$sides
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{easysgn}
%   This procedure is a hacky test of whether a difference is 
%   positive, zero, negative, or other (implying incomparability), 
%   where the ordering is simply element-wise. This is quicker to 
%   do with regexps than by properly looping over the elements.
%   \begin{tcl}
proc easysgn {element} {
   lindex {0 - + incomparable} [
      expr {([string first - $element]>=0) +\
        2*[regexp {(^|\{| )[1-9]} $element]}
   ]
}
%   \end{tcl}
% \end{proc}
% 
% At this point, one should e.g.~|source Hopf+twist2.dump-tcl;\
% llength $rulesL|. The |llength| prevents dumping a megabyte-size 
% list in the console.
% 
% \begin{tcl}
array unset Histogram
set mainMap [array get PROPgen]
foreach list {rulesL equalitiesL} {
   set n -1; foreach rule [set $list] {incr n
      lappend Histogram($list,[easysgn [rulediff $mainMap $rule]]) $n
   }
}
% \end{tcl}
% Results are:
% \begin{itemize}
%   \item
%     $457$ rules were resolved as positive, $214$ are still neutral, 
%     none negative or incomparable.
%   \item
%     All $89$ equalities remained neutral.
% \end{itemize}
% That nothing incomparable is encountered is very promising!
% 
% The next step is to impose a distinction also between left- and 
% right-leaning combinations of the product and coproduct 
% respectively. The following |leftMap| penalises right-branching by 
% a factor $2$, but does as little as possible otherwise.
% \begin{tcl}
dict set leftMap epsilon [dict get $mainMap epsilon]
dict set leftMap unit [dict get $mainMap unit]
dict set leftMap Delta [
   PROP fromparts 0 {0 0} 0 {1 2}
]
dict set leftMap m [
   PROP fromparts 0 0 {0 0} {{1 2}}
]
dict set leftMap S [
   PROP fromparts 0 0 0 1
]
dict set leftMap twist [PROP permutation {1 0}]
% \end{tcl}
% 
% \begin{tcl}
foreach list {rulesL equalitiesL} {
   set entry "Histogram($list,0)"
   foreach n [set $entry] {
      lappend Histogram_leftMap($entry,[easysgn [
         rulediff $leftMap [lindex [set $list] $n]
      ]]) $n
   }
}
% \end{tcl}
% Produces some incomparabilities, and at least the first few are in 
% the open part. What if one only distinguishes left from right in 
% the multiplication?
% \begin{tcl}
set leftMap2 $leftMap
dict set leftMap2 Delta [
   PROP fromparts 0 {0 0} 0 {1 1}
]
foreach list {rulesL equalitiesL} {
   set entry "Histogram($list,0)"
   foreach n [set $entry] {
      lappend Histogram_leftMap2($entry,[easysgn [
         rulediff $leftMap2 [lindex [set $list] $n]
      ]]) $n
   }
}
% \end{tcl}
% 
% Hmm\dots\ it might be better to order by several maps in sequence.
% 
% \begin{proc}{direct_rule}
%   This procedure tries to direct a rule, by applying maps from a 
%   list until one is found which throws it off the neutral. The call 
%   syntax is
%   \begin{displaysyntax}
%     |direct_rule| \word{map-list} \word{rule}
%   \end{displaysyntax}
%   and the return value is a list
%   \begin{displaysyntax}
%     \word{index} \word{sign}
%   \end{displaysyntax}
%   where \word{index} is the index in the \word{map-list} of the 
%   last map tried, and \word{sign} is the |easysgn| of the 
%   corresponding |rulediff|.
%   \begin{tcl}
proc direct_rule {mapL rule} {
   set n -1; foreach map $mapL {incr n
      set sgn [easysgn [rulediff $map $rule]]
      if {$sgn != "0"} then {break}
   }
   return [list $n $sgn]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{direct_rulelist}
%   This procedure runs |direct_rule| on all rules in a list, and 
%   appends the rule indices to different entries in a histogram 
%   array depending on the return value from the |direct_rule| call. 
%   The syntax is
%   \begin{displaysyntax}
%     |direct_rulelist| \word{array-name} \word{prefix} 
%     \word{rule list} \word{map}\regstar
%   \end{displaysyntax}
%   where \word{prefix} is prepended to each rule index before it is  
%   appended to some array entry.
%   \begin{tcl}
proc direct_rulelist {arrname prefix ruleL args} {
   upvar 1 $arrname Hist
   set n -1; foreach rule $ruleL {incr n
      lappend Hist([join [direct_rule $args $rule] ,]) $prefix$n
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{tcl}
set vertexCountMap [dict create unit [
   PROP fromparts 1 1 {} {}
] epsilon [
   PROP fromparts 1 {} 1 {}
] Delta [
   PROP fromparts 1 {0 0} 1 {{1} {1}}
] m [
   PROP fromparts 1 {1} {0 0} {{1 1}}
] S [
   PROP fromparts 1 0 0 2
] twist [
   PROP fromparts 1 {0 0} {0 0} {{0 1} {1 0}}
]]
% \end{tcl}
% 
% \begin{tcl}
set slashMap [dict create unit [
   PROP fromparts 0 1 {} {}
] epsilon [
   PROP fromparts 0 {} 1 {}
] Delta [
   PROP fromparts 0 {0 0} 1 {{1} {1}}
] m [
   PROP fromparts 0 {1} {0 0} {{1 1}}
] S [
   PROP fromparts 0 0 0 2
] twist [
   PROP fromparts 0 {0 0} {0 0} {{0 2} {1 0}}
]]
% \end{tcl}
% 
% Roughly the |m| side of what was used to derive the 
% \texttt{Hopf+twist2} data.
% \begin{tcl}
set mslashmMap [dict create unit [
   PROP fromparts 0 0 {} {}
] epsilon [
   PROP fromparts 0 {} 0 {}
] Delta [
   PROP fromparts 0 {0 0} 0 {{0} {0}}
] m [
   PROP fromparts 0 {1} {0 0} {{0 1}}
] S [
   PROP fromparts 0 0 0 0
] twist [
   PROP fromparts 0 {0 0} {0 0} {{0 1} {0 0}}
]]
% \end{tcl}
% 
% Impose left-associativity using an end-entry.
% \begin{tcl}
set mleft2Map $mainMap
dict set mleft2Map m [
   PROP fromparts 0 {1} {0 1} {{1 1}}
]
% \end{tcl}
% 
% Slashify twist with end- and begin-points.
% \begin{tcl}
set slashMap2 $mainMap
dict set slashMap2 twist [
   PROP fromparts 0 {0 1} {0 1} {{0 1} {1 0}}
]
% \end{tcl}
% Not too bad, but causes some incompatibilities.
% 
% Symmetrically put endpoints at all corners of a twist.
% \begin{tcl}
set twistMap4 $mainMap
dict set twistMap4 twist [
   PROP fromparts 0 {1 1} {1 1} {{0 1} {1 0}}
]
% \end{tcl}
% Causes \emph{lots} of incompatibilities.
% 
% Connect every twist input with every twist output.
% \begin{tcl}
set zhaMap $mainMap
dict set zhaMap twist [
   PROP fromparts 0 {0 0} {0 0} {{1 1} {1 1}}
]
% \end{tcl}
% Doesn't resolve a single rule, but makes almost every one that 
% wasn't already resolved incompatible.
% 
% Penalise passage through a twist like passage through an antipode.
% \begin{tcl}
set twist2Map $mainMap
dict set twist2Map twist [
   PROP fromparts 0 {0 0} {0 0} {{0 2} {2 0}}
]
% \end{tcl}
% Doesn't resolve a single rule, but makes almost every one that 
% wasn't already resolved incompatible. This is disappointing, since 
% it is very natural in the context of a super-Hopf algebra (a 
% projection onto the odd part should be larger than the identity).
% 
% In conclusion, it is easy to invent ways of directing rules, but 
% apparently hard to find anything that doesn't cause 
% incomparabilities. In order to advance on that front, one might 
% return to the previous approach of indeterminate coefficients and 
% see how things work out for selected rules.
% 
% \subsubsection{With indeterminate experience}
% 
% The experiments below with indeterminates for matrix elements 
% suggest that it is hard to favour the left-leaning sides in the 
% associativity and coassociativity rules; very often the asymmetry 
% that should have this effect would leave other rules with more than 
% one leading term, so one is forced back to the symmteric situation 
% for multiplication and comultiplication. Interestingly enough the 
% same does not seem to hold for the |twist|, as its right hand side 
% can be penalised with few or no problems. There are some 
% indications that \(T_{2,2} \geqslant T_{0,2},T_{2,0}\), but that's 
% about it. Hence it becomes interesting to see what happens if one 
% sets these to $1$ and uses them for ordering.
% \begin{tcl}
set rtwistMap $mainMap
dict set rtwistMap twist [
   PROP fromparts 0 {0 1} {0 1} {{0 1} {1 1}}
]
array unset Hist
direct_rulelist Hist "" $rulesL $mainMap $rtwistMap
direct_rulelist Hist e $equalitiesL $mainMap $rtwistMap
% \end{tcl}
% Most things come out comparable, and interestingly enough rules 14 
% and 17 come out positive with respect to |rtwistMap| (as do many 
% other rules that |mainMap| left neutral) even though they are 
% deformed cases of the associativity rule 2 and coassociativity rule 
% 5, which remains neutral. The worrying thing about these results is 
% however that equality 2 comes out incomparable, which one would of 
% course prefer to avoid.
% 
% An indeterminate study of equality 2 shows that this isn't a matter 
% of picking suitable parameters\Dash different entries simply have 
% different signs. This rule is however derived from rules 171 and 
% 222, and rule 171 have a clear negative signature in the 
% indeterminate study. Might the derivation of equality 2 simply be a 
% mistake that shouldn't happen when the completion procedure is run 
% with a truly compatible order, since rule 171 should really be the 
% other way round? One might hope so, but no; rule 171 is oriented 
% the way it is because of |mainMap|, so what |rtwistMap| has to say 
% about it doesn't matter. Rule 171 is a $\Delta \circ m$ with an 
% extra |twist| in the middle, so it makes sense that the same 
% condition that would direct rule 9 the way it will get a similar 
% effect here.
% 
% So maybe the problem is that |mainMap| does too much? What if it 
% wasn't responsible for orienting rule 9, and instead left that to 
% some subsequent rule? This effect can be had by putting a closed 
% weight of $1$ on the |twist|:
% \begin{tcl}
set main1Map $mainMap
dict set main1Map twist [
   PROP fromparts 1 {0 0} {0 0} {{0 1} {1 0}}
]
array unset Hist2
direct_rulelist Hist2 "" $rulesL $main1Map
direct_rulelist Hist2 e $equalitiesL $main1Map
% \end{tcl}
% This certainly leaves all the troublesome rules and equalities 
% neutral, and has the advantage over |mainMap| that the twist and 
% (co)unit rules get properly oriented (which otherwise took an extra 
% round of ordering by number of vertices). Indeed, |main1Map| has 
% the great formal advantage that it fully imposes DCC; every type of 
% vertex carries a positive cost in some area. The only question is 
% how one might follow up on this order, as it leaves all of axioms 
% 2, 5, and 9 neutral.
% 
% One further modification that can be tried is to make the closed 
% weight on |twist| less than than in $\Delta \circ m$, but still 
% positive:
% \begin{tcl}
set main2Map $mainMap
dict set main2Map m [
   PROP fromparts 0 {2} {0 0} {{1 1}}
]
dict set main2Map Delta [
   PROP fromparts 0 {0 0} {2} {{1} {1}}
]
dict set main2Map twist [
   PROP fromparts 3 {0 0} {0 0} {{0 1} {1 0}}
]
array unset Hist3
direct_rulelist Hist3 "" $rulesL $main2Map
direct_rulelist Hist3 e $equalitiesL $main2Map
% \end{tcl}
% This restores the behaviour of |mainMap|, except that it keeps the 
% orientation of the (co)unit--twist rules. Thus an improvement, but 
% it doesn't help with rule 171.
% 
% There is however something very strange about rule 171: it should 
% really have been dropped almost immediately\Ldash the left hand 
% side's outward coproduct in the lower right corner can obviously be 
% removed by adding an extra counit and simplifying\Dash so why isn't 
% there a rule with this slightly smaller left hand side instead? As 
% it turns out, this is because the corresponding simplification of 
% the right hand side produces the exact same network! This isn't 
% as strange as it may seem; the same outward coproduct exists in 
% rule 9, and noone expects that to be dropped in favour of something 
% whose left hand side is just a product, because the only possible 
% right hand side for that is the same as the left hand side.
% 
% So I'm still stuck. But maybe the problems now are small enough 
% that one can hope for incomparable equalities to be resolved later, 
% when the necessary rule is resolved.
% 
% 
% \subsection{Fourth attempt}
% 
% In this setting, the vertices of interest are |m|~(product), 
% |Delta|~(coproduct), and |twist|~(the abstact twist) since it is 
% rules involving only these three that are the most troublesome. 
% These rules furthermore doesn't change the number of either type of 
% vertex, so the constant parts of the PROP elements are arbitrary; 
% it is best to fix it at $0$. This still leaves $18$ indeterminate 
% elements: $5$ each for |m| and |Delta|, and $8$ for the |twist|. 
% The former are named A--E in lower and upper case respectively, 
% whereas the latter are given names of the form $T_{i,j}$ for \(i,j 
% \in \{0,1,2\}\), where $0$ marks a termination.
% 
% Constructing a |pseudoexpression| for each $T$-entry is somewhat 
% complicated, so it is easiest done with a separate loop.
% \begin{tcl}
set extraD {}
foreach i {0 1 2} {
   foreach j {0 1 2} {
      dict set extraD pseudoexpression T$i$j [
         list OMA {form index} [list\
           [list OMS {cd linalg1b name matrix_selector} {}]\
           [list OMV {name T} {}]\
           [list integer [dict create value $i] {}]\
           [list integer [dict create value $j] {}]]
      ]
   }
}
% \end{tcl}
% \OMSref{linalg1b}{matrix_selector} is an imaginary symbol; the 
% catch is that \OMSref{linalg1}{matrix_selector} has the matrix 
% last, which doesn't match the |index| form of an |OMA|.
% \begin{tcl}
interp alias {} Coeff_ring {} ::mtmtcl::rings::semigroup_algebra {
   ::mtmtcl::rings::integer
} [list ::mtmtcl::groups::power_product_monoid_1.3 [
   list ::mtmtcl::sets::variable_set\
     {a b c d e A B C D E T01 T02 T10 T11 T12 T20 T21 T22} $extraD
]]
interp alias {} PROP {} mtmtcl::matprop::biaffine Coeff_ring
% \end{tcl}
% The |fusediff| procedure is again useful, but of course the 
% |PROPgen| array needs a new definition.
% \begin{tcl}
set PROPgen(Delta) [
   PROP fromparts [Coeff_ring 0]\
     [list [Coeff_ring named A] [Coeff_ring named B]]\
     [list [Coeff_ring named C]]\
     [list [list [Coeff_ring named D]] [list [Coeff_ring named E]]]
]
set PROPgen(m) [
   PROP fromparts [Coeff_ring 0]\
     [list [Coeff_ring named c]]\
     [list [Coeff_ring named a] [Coeff_ring named b]]\
     [list [list [Coeff_ring named d] [Coeff_ring named e]]]
]
set PROPgen(twist) [
   PROP fromparts [Coeff_ring 0] [
      list [Coeff_ring named T10] [Coeff_ring named T20]
   ] [
      list [Coeff_ring named T01] [Coeff_ring named T02]
   ] [
      list [list [Coeff_ring named T11] [Coeff_ring named T12]]\
        [list [Coeff_ring named T21] [Coeff_ring named T22]]
   ]
]
% \end{tcl}
% 
% The differences for associativity and coassociativity rules are 
% the same as above.
% \begin{tcl}
set diffL {}
lappend diffL [fusediff {
  o1 o1 m {m1 m2} m2 m {i1 i2} {m1 i1 i2}
} {
  o1 o1 m {m1 m2} m1 m {i1 i2} {i1 i2 m2}
}]
lappend diffL [fusediff {
  {o1 o2 o3} {o2 o3} Delta m1 {o1 m1} Delta i1 i1
} {
  {o1 o2 o3} {o1 o2} Delta m1 {m1 o3} Delta i1 i1
}]
% \end{tcl}
% As above, one can make code of this list.
% \begin{tcl}
set codeL {}
foreach item $diffL {
   lappend codeL [mtmtcl::latex::convertto [PROP export $item {}]]
}
set code "\\begin{gather}\n  [
   join $codeL "\n  \\\\\n  "
]\n\\end{gather}"
% \end{tcl}
% The result is
% \begin{gather}
%   \begin{pmatrix} 1 & b c - a c & - a d & a + b d - b - a e & b e \\ 
%     0 & 1 & 0 & 0 & 0 \\ 0 & c e - c d & d - d^2 & 0 & e^2 - e 
%   \end{pmatrix} \geqslant 0
%   \\
%   \begin{pmatrix} 1 & B C - A C & C E - C D \\ 0 & 1 & 0 \\ 
%     0 & - A D & D - D^2 \\ 0 & A + B D - B - A E & 0 \\ 
%     0 & B E & E^2 - E
%   \end{pmatrix} \geqslant 0
% \end{gather}
% From \(d - d^2 \geqslant 0\) and \(e^2 - e \geqslant 0\) follows 
% \(d \leqslant 1 \leqslant e\). Then it follows from 
% \(a + b d - b - a e = a(1 -\nobreak e) + b(d -\nobreak 1) \geqslant 
% 0\) that \(a=b=0\) or \(d=e=1\)! Furthermore \(-ad \geqslant 0\) 
% implies \(a=0\) or \(d=0\). Hence there are basically two solutions:
% \begin{equation}
%   \left\{ \begin{aligned}
%     a &{}= 0 \\
%     b &{}= 0 \\
%     c &\text{ arbitrary}\\
%     d &{}\leqslant 1\\
%     e &{}\geqslant 1
%   \end{aligned} \right.
%   \qquad\text{or}\qquad
%   \left\{ \begin{aligned}
%     a &{}= 0 \\
%     b &{}> 0 \\
%     c &\text{ arbitrary}\\
%     d &{}= 1\\
%     e &{}= 1
%   \end{aligned} \right.
% \end{equation}
% By symmetry same two cases exist for the upper case variables. 
% There is thus a total of eigth cases.
% 
% The following thus covers what multiplication and comultiplication 
% can be in this setting.
% \begin{tcl}
set mult1 [PROP fromparts [Coeff_ring 0]\
  [list [Coeff_ring named c]]\
  [list [Coeff_ring 0] [Coeff_ring 0]]\
  [list [list [Coeff_ring named d] [Coeff_ring named e]]]]
set mult2 [PROP fromparts [Coeff_ring 0]\
  [list [Coeff_ring named c]]\
  [list [Coeff_ring 0] [Coeff_ring named b]]\
  [list [list [Coeff_ring 1] [Coeff_ring 1]]]]
set comult1 [PROP fromparts [Coeff_ring 0]\
  [list [Coeff_ring 0] [Coeff_ring 0]]\
  [list [Coeff_ring named C]]\
  [list [list [Coeff_ring named D]] [list [Coeff_ring named E]]]]
set comult2 [PROP fromparts [Coeff_ring 0]\
  [list [Coeff_ring 0] [Coeff_ring named B]]\
  [list [Coeff_ring named C]]\
  [list [list [Coeff_ring 1]] [list [Coeff_ring 1]]]]
% \end{tcl}
% The problem is to find coefficients which also work with rules 14 
% and 17.
% 
% \begin{proc}{latex_inequalities}
%   This procedure maps existing rules into the |biaffine| PROP and 
%   manufactures a list of inequalities from the result, which are 
%   then turned into \LaTeX\ code (as an |enumerate| environment with 
%   the formulae in paragraphs, since they are frequently longer than 
%   the linewidth). The call syntax is
%   \begin{displaysyntax}
%     |latex_inequalities| \word{rule-number list} 
%     \begin{regblock}[\regstar] \word{vertex annotation} 
%     \word{PROP element} \end{regblock}
%   \end{displaysyntax}
%   where the \word{vertex annotation} \word{PROP element} uniquely 
%   define a map from the free (networks) to the |biaffine| PROPs. The 
%   \word{rule-number list} contains integers for elements of the 
%   |rulesL| variable and |e|\meta{integer} for elemnets of the 
%   |equalitiesL| variable.
%   \begin{tcl}
proc latex_inequalities {rulenoL args} {
   global rulesL equalitiesL othersL
   set res {\begin{enumerate}}
   set varL {}
   foreach name [Coeff_ring basis namestructure names] {
      lappend varL [Coeff_ring named $name]
   }
   set one [Coeff_ring 1]
   set count 0
   foreach ruleno $rulenoL {
      switch -regexp -- $ruleno {^[0-9]+$} {
         set rule [lindex $rulesL $ruleno]
      } {^e[0-9]+$} {
         set rule [lindex $equalitiesL [string trimleft $ruleno e]]
      } {^o[0-9]+$} {
         set rule [lindex $othersL [string trimleft $ruleno o]]
      } default {
         append res "\n%^^A Unknown rule number: $ruleno"
         continue
      }
      set diff [rulediff $args $rule]
      set L [list [PROP part closed $diff]]
      lappend L {*}[PROP part begin $diff] {*}[PROP part end $diff]
      lappend L {*}[concat {*}[PROP part open $diff]]
      append ruleno :
      foreach a $L {incr count
         if {[Coeff_ring iszero $a]} then {continue}
         append res \n {\item} "\[$ruleno$count\]" \n {  \(}
         set c $one
         foreach f $varL {
            while {![catch {Coeff_ring / $a $f} q]} {
               set a $q
               set c [Coeff_ring * $c $f]
            }
         }
         set tree [list OMA {form juxtaposed} [list\
           {OMS {cd arith1 name times} {}}\
           [Coeff_ring export $c {}] [Coeff_ring export $a {}]]]
         append res [mtmtcl::latex::convertto $tree] { \geqslant 0\).}
         set ruleno ""
      }
   }
   append res \n {\end{enumerate}}
}
interp alias {} inequalities1417 {} latex_inequalities {14 17}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsubsection{The case of mult2 and comult2}
% 
% \begin{table}
% \begin{enumerate}
% \item
%   \(c T_{0,2} + T_{0,2} T_{1,0} + B T_{0,2} T_{1,1} + b c T_{1,2} + 
%     b T_{1,0} T_{1,2} + b B T_{1,1} T_{1,2} + b T_{2,0} + b B T_{2,1} 
%     - b B - c T_{0,1} - T_{0,1} T_{2,0} - B T_{0,1} T_{2,1} - 
%     b c T_{1,1} - b T_{1,1} T_{2,0} - b B T_{1,1} T_{2,1}  \geqslant 0\).
% \item
%   \(- c - T_{1,0} - B T_{1,1} + c T_{1,2} + T_{1,0} T_{1,2} + 
%     B T_{1,1} T_{1,2} - c T_{1,1} - T_{1,1} T_{2,0} - 
%     B T_{1,1} T_{2,1}  \geqslant 0\).
% \item
%   \(c + T_{2,0} + B T_{2,1} + c T_{2,2} + T_{1,0} T_{2,2} + 
%     B T_{1,1} T_{2,2} - c T_{2,1} - T_{2,0} T_{2,1} - B T_{2,1} ^ 2  \geqslant 0\).
% \item
%   \(- T_{0,1} T_{2,1} - b T_{1,1} T_{2,1}  \geqslant 0\).
% \item
%   \(T_{0,2} T_{1,1} + b T_{1,1} T_{1,2} + b T_{2,1} - b - T_{0,1} T_{2,2} 
%     - b T_{1,1} T_{2,2}  \geqslant 0\).
% \item
%   \(T_{0,2} T_{1,2} + b T_{1,2} ^ 2 + b T_{2,2}  \geqslant 0\).
% \item
%   \(- T_{1,1} T_{2,1}  \geqslant 0\).
% \item
%   \(T_{1,1} T_{1,2} - T_{1,1} T_{2,2} - T_{1,1}  \geqslant 0\).
% \item
%   \(T_{1,2} ^ 2 - T_{1,2}  \geqslant 0\).
% \item
%   \(T_{2,1} - T_{2,1} ^ 2  \geqslant 0\).
% \item
%   \(T_{2,2} + T_{1,1} T_{2,2} - T_{2,1} T_{2,2}  \geqslant 0\).
% \item
%   \(T_{1,2} T_{2,2}  \geqslant 0\).
% \item
%   \(C T_{2,0} + B C T_{2,1} + T_{0,1} T_{2,0} + B T_{0,1} T_{2,1} + 
%     B T_{0,2} + b T_{1,1} T_{2,0} + b B T_{1,1} T_{2,1} + b B T_{1,2} 
%     - b B - C T_{1,0} - B C T_{1,1} - T_{0,2} T_{1,0} - 
%     B T_{0,2} T_{1,1} - b T_{1,0} T_{1,2} - b B T_{1,1} T_{1,2}  \geqslant 0\).
% \item
%   \(- T_{1,0} T_{1,2} - B T_{1,1} T_{1,2}  \geqslant 0\).
% \item
%   \(T_{1,1} T_{2,0} + B T_{1,1} T_{2,1} + B T_{1,2} - T_{1,0} T_{2,2} - 
%     B T_{1,1} T_{2,2} - B  \geqslant 0\).
% \item
%   \(T_{2,0} T_{2,1} + B T_{2,1} ^ 2 + B T_{2,2}  \geqslant 0\).
% \item
%   \(- C - T_{0,1} - b T_{1,1} + C T_{2,1} + T_{0,1} T_{2,1} + 
%     b T_{1,1} T_{2,1} - C T_{1,1} - T_{0,2} T_{1,1} - 
%     b T_{1,1} T_{1,2}  \geqslant 0\).
% \item
%   \(C + T_{0,2} + b T_{1,2} + C T_{2,2} + T_{0,1} T_{2,2} + 
%     b T_{1,1} T_{2,2} - C T_{1,2} - T_{0,2} T_{1,2} - b T_{1,2} ^ 2  \geqslant 0\).
% \item
%   \(- T_{1,1} T_{1,2}  \geqslant 0\).
% \item
%   \(T_{1,2} - T_{1,2} ^ 2  \geqslant 0\).
% \item
%   \(T_{1,1} T_{2,1} - T_{1,1} T_{2,2} - T_{1,1}  \geqslant 0\).
% \item
%   \(T_{2,2} + T_{1,1} T_{2,2} - T_{1,2} T_{2,2}  \geqslant 0\).
% \item
%   \(T_{2,1} ^ 2 - T_{2,1}  \geqslant 0\).
% \item
%   \(T_{2,1} T_{2,2}  \geqslant 0\).
% \end{enumerate}
% \caption{mult2 and comult2} \label{Tab:mult2 and comult2}
% \end{table}
% 
% The equations for the |mult2|\&|comult2| case can be found in 
% Table~\ref{Tab:mult2 and comult2}. A first observation is that 
% inequalities 9 and 20 go in opposide directions, implying the 
% equality \(T_{1,2}^2 = T_{1,2}\), and similarly inequalities 10 and 
% 23 imply the equality \(T_{2,1}^2 = T_{2,1}\). That inequalities 7 
% and 19 only have a non-positive term strongly suggests that 
% \(T_{1,1} = 0\), but the proof of this comes from combining 7 with 
% 21, the sum of which says \(0 \leqslant - T_{1,1} T_{2,2} - T_{1,1} 
% = -T_{1,1}(T_{2,2} +\nobreak 1)\), where the parenthesis is 
% strictly positive. Inserting this into the inequalities shortens 
% several of them considerably:
% \begin{enumerate}
% \item[1]
%   \(c T_{0,2} + T_{0,2} T_{1,0} + b c T_{1,2} + b T_{1,0} T_{1,2} + 
%     b T_{2,0} + b B T_{2,1} - b B - c T_{0,1} - T_{0,1} T_{2,0} - 
%     B T_{0,1} T_{2,1}  \geqslant 0\).
% \item[2]
%   \(- c - T_{1,0} + c T_{1,2} + T_{1,0} T_{1,2}  \geqslant 0\).
% \item[3]
%   \(c + T_{2,0} + B T_{2,1} + c T_{2,2} + T_{1,0} T_{2,2} - c T_{2,1} - 
%     T_{2,0} T_{2,1} - B T_{2,1} ^ 2  \geqslant 0\).
% \item[4]
%   \(- T_{0,1} T_{2,1}  \geqslant 0\).
% \item[5]
%   \(b T_{2,1} - b - T_{0,1} T_{2,2}  \geqslant 0\).
% \item[6]
%   \(T_{0,2} T_{1,2} + b T_{1,2} ^ 2 + b T_{2,2}  \geqslant 0\).
% \item[11]
%   \(T_{2,2} - T_{2,1} T_{2,2}  \geqslant 0\).
% \item[12]
%   \(T_{1,2} T_{2,2}  \geqslant 0\).
% \item[13]
%   \(C T_{2,0} + B C T_{2,1} + T_{0,1} T_{2,0} + B T_{0,1} T_{2,1} + 
%     B T_{0,2} + b B T_{1,2} - b B - C T_{1,0} - T_{0,2} T_{1,0} - 
%     b T_{1,0} T_{1,2}  \geqslant 0\).
% \item[14]
%   \(- T_{1,0} T_{1,2}  \geqslant 0\).
% \item[15]
%   \(B T_{1,2} - T_{1,0} T_{2,2} - B  \geqslant 0\).
% \item[16]
%   \(T_{2,0} T_{2,1} + B T_{2,1} ^ 2 + B T_{2,2}  \geqslant 0\).
% \item[17]
%   \(- C - T_{0,1} + C T_{2,1} + T_{0,1} T_{2,1}  \geqslant 0\).
% \item[18]
%   \(C + T_{0,2} + b T_{1,2} + C T_{2,2} + T_{0,1} T_{2,2} - C T_{1,2} - 
%     T_{0,2} T_{1,2} - b T_{1,2} ^ 2  \geqslant 0\).
% \item[22]
%   \(T_{2,2} - T_{1,2} T_{2,2}  \geqslant 0\).
% \item[24]
%   \(T_{2,1} T_{2,2}  \geqslant 0\).
% \end{enumerate}
% By the simplified inequality 5, \(b (T_{2,1} -\nobreak 1) \geqslant 
% T_{0,1} T_{2,2} \geqslant 0\), and since \(b>0\) this can only work 
% out if \(T_{2,1} = 1\). Similarly by the simplified inequality 15, 
% \(B (T_{1,2} -\nobreak 1) \geqslant T_{1,0} T_{2,2} \geqslant 0\), 
% and thus \(T_{1,2} = 1\). Hence \(T_{0,1} = 0\) by inequality 4 
% and \(T_{1,0} = 0\) by inequality 14. Since these identifications 
% turn 16 inequalities into \(0 \geqslant 0\) and make the others 
% trivial (a sum of nonnegative quantitites is to be $\geqslant 0$), 
% it is safe to say that this case has plenty of solutions, namely:
% \begin{equation}
%   \left\{ \begin{aligned}
%     && T_{0,1} &= 0 & T_{0,2}&\text{ arbitrary} \\
%     T_{1,0} &= 0 & T_{1,1} &= 0 & T_{1,2} &= 1 \\
%     T_{2,0} &\text{ arbitrary} & T_{2,1} &= 1 & 
%       T_{2,2} &\text{ arbitrary}
%   \end{aligned} \right.
% \end{equation}
% The parameters still available are thus $b$, $c$, $B$, $C$, 
% $T_{0,2}$, $T_{2,0}$, and $T_{2,2}$. Only the last can occur in the 
% open part of an expression, or with power larger than $1$.
% 
% A general conclusion is that what can be penalised in this setting 
% are the right parts of twists, products, and coproducts.
% 
% The solution gets into trouble when faced with the next rule that 
% needs to be ordered, though:
% \begin{enumerate}
% \item[155:1]
%   \(c T_{0,2} - b B + b c T_{2,2}  \geqslant 0\).
% \item[3]
%   \(c T_{2,2}  \geqslant 0\).
% \item[6]
%   \(- b  \geqslant 0\).
% \item[7]
%   \(T_{0,2} + b + b T_{2,2}  \geqslant 0\).
% \item[15]
%   \(T_{2,2}  \geqslant 0\).
% \end{enumerate}
% Since \(b>0\), inequality 6 above forbids the direct form of this 
% rule. On the other hand, inequality 7 forbids the reverse form of 
% this rule. Hence there is no way to make the sides of this rule 
% comparable using an ordering along these lines.
% 
% \subsubsection{The case of mult1 and comult2}
% 
% \begin{table}
% \begin{enumerate}
% \item[14:1]
%   \(B T_{0,1} + c T_{0,2} + e T_{0,2} T_{1,0} + e B T_{0,2} T_{1,1} - 
%     c T_{0,1} - d T_{0,1} T_{2,0} - d B T_{0,1} T_{2,1} - e B T_{0,1}  \geqslant 0\).
% \item[2]
%   \(e B T_{1,1} + c e T_{1,2} + e^2 T_{1,0} T_{1,2} + 
%     e^2 B T_{1,1} T_{1,2} - c d - d e T_{1,0} - d e B T_{1,1} - 
%     c e T_{1,1} - d e T_{1,1} T_{2,0} - d e B T_{1,1} T_{2,1} - 
%     e^2 B T_{1,1}  \geqslant 0\).
% \item[3]
%   \(d ( c + d T_{2,0} + d B T_{2,1} + c d T_{2,2} + d e T_{1,0} T_{2,2} + 
%       d e B T_{1,1} T_{2,2} + e T_{2,0} - T_{2,0} - c T_{2,1} - 
%       d T_{2,0} T_{2,1} - d B T_{2,1} ^ 2 )  \geqslant 0\).
% \item[4]
%   \(- d T_{0,1} T_{2,1}  \geqslant 0\).
% \item[5]
%   \(T_{0,1} + d T_{0,2} + e T_{0,2} T_{1,1} - T_{0,2} - d T_{0,1} T_{2,2} 
%     - e T_{0,1}  \geqslant 0\).
% \item[6]
%   \(e T_{0,2} T_{1,2}  \geqslant 0\).
% \item[7]
%   \(d + e T_{1,1} - d^2 - d e T_{1,1} - d e T_{1,1} T_{2,1}  \geqslant 0\).
% \item[8]
%   \(e T_{1,1} ( e T_{1,2} - d T_{2,2} - e )  \geqslant 0\).
% \item[9]
%   \(e T_{1,2} ( e T_{1,2} - 1 )  \geqslant 0\).
% \item[10]
%   \(d^2 T_{2,1} ( 1 - T_{2,1} )  \geqslant 0\).
% \item[11]
%   \(d^2 T_{2,2} ( d + e T_{1,1} - T_{2,1} )  \geqslant 0\).
% \item[12]
%   \(d T_{2,2} ( d e T_{1,2} + e - 1 )  \geqslant 0\).
% \item[17:13]
%   \(C T_{2,0} + B C T_{2,1} + T_{0,1} T_{2,0} + B T_{0,1} T_{2,1} + 
%     B T_{0,2} - C T_{1,0} - B C T_{1,1} - T_{0,2} T_{1,0} - 
%     B T_{0,2} T_{1,1}  \geqslant 0\).
% \item[14]
%   \(e T_{1,2} \bigl( - ( T_{1,0} ) - B T_{1,1} \bigr)  \geqslant 0\).
% \item[15]
%   \(e T_{1,1} T_{2,0} + e B T_{1,1} T_{2,1} + e B T_{1,2} - 
%     d T_{1,0} T_{2,2} - d B T_{1,1} T_{2,2} - e B  \geqslant 0\).
% \item[16]
%   \(d ( T_{2,0} T_{2,1} + B T_{2,1} ^ 2 + B T_{2,2} )  \geqslant 0\).
% \item[17]
%   \(- C - T_{0,1} + C T_{2,1} + T_{0,1} T_{2,1} - C T_{1,1} - 
%     T_{0,2} T_{1,1}  \geqslant 0\).
% \item[18]
%   \(C + T_{0,2} + C T_{2,2} + T_{0,1} T_{2,2} - C T_{1,2} - 
%     T_{0,2} T_{1,2}  \geqslant 0\).
% \item[19]
%   \(- e T_{1,1} T_{1,2}  \geqslant 0\).
% \item[20]
%   \(e T_{1,2} ( 1 - T_{1,2} )  \geqslant 0\).
% \item[21]
%   \(T_{1,1} ( e T_{2,1} - d T_{2,2} - e )  \geqslant 0\).
% \item[22]
%   \(T_{2,2} ( d + e T_{1,1} - d T_{1,2} )  \geqslant 0\).
% \item[23]
%   \(d T_{2,1} ( T_{2,1} - 1 )  \geqslant 0\).
% \item[24]
%   \(d T_{2,1} T_{2,2}  \geqslant 0\).
% \end{enumerate}
% \caption{mult1 and comult2} \label{Tab:mult1 and comult2}
% \end{table}
% 
% The equations for the |mult1|\&|comult2| case can be found in 
% Table~\ref{Tab:mult1 and comult2}. As in the previous case, 
% inequalities 10 and 23 go in opposide directions, from which 
% follows that \(T_{2,1}^2 = T_{2,1}\), but inequalities 9 and 20 
% don't similarly combine to \(T_{1,2}^2 = T_{1,2}\); only to 
% \(eT_{1,2}^2 \geqslant T_{1,2} \geqslant T_{1,2}^2\). What works is 
% instead to combine inequalities 19 and 8 to the conclusion that 
% \(T_{1,1}=0\). From inserting that into inequality 15, one gets 
% \(eB(T_{1,2} -\nobreak 1) \geqslant d T_{1,0} T_{2,2} \geqslant 
% 0\), and thus \(T_{1,2} \geqslant 1\), which combines with 
% inequality 20 to \(T_{1,2} = 1\). This brings us to the system
% \begin{enumerate}
% \item[14:1]
%   \(B T_{0,1} + c T_{0,2} - c T_{0,1} - d T_{0,1} T_{2,0} - 
%     d B T_{0,1} T_{2,1} - e B T_{0,1}  \geqslant 0\).
% \item[3]
%   \(d ( c + d T_{2,0} + d B T_{2,1} + c d T_{2,2} + e T_{2,0} - T_{2,0} - 
%       c T_{2,1} - d T_{2,0} T_{2,1} - d B T_{2,1} ^ 2 )  \geqslant 0\).
% \item[4]
%   \(- d T_{0,1} T_{2,1}  \geqslant 0\).
% \item[5]
%   \(T_{0,1} + d T_{0,2} - T_{0,2} - d T_{0,1} T_{2,2} - e T_{0,1} 
%   \geqslant 0\).
% \item[10]
%   \(d^2 T_{2,1} ( 1 - T_{2,1} )  \geqslant 0\).
% \item[11]
%   \(d^2 T_{2,2} ( d - T_{2,1} )  \geqslant 0\).
% \item[17]
%   \(- C - T_{0,1} + C T_{2,1} + T_{0,1} T_{2,1}  \geqslant 0\).
% \item[23]
%   \(d T_{2,1} ( T_{2,1} - 1 )  \geqslant 0\).
% \end{enumerate}
% Now inequality 17 becomes \((C + T_{0,1}) (T_{2,1} - 1) \geqslant 
% 0\) and inequality 4 imples \(T_{0,1} T_{2,1} = 0\). Hence if 
% \(T_{2,1} > 0\) then \(T_{0,1}=0\) by the latter and if 
% \(T_{2,1}=0\) then \(T_{0,1}=0\) by the former, so in either case 
% \(T_{0,1} = 0\). Since not all $T_{i,1}$ may be $0$ simultaneously, 
% it follows that \(T_{2,1} > 0\), or more precisely \(T_{2,1} = 1\). 
% Then all that remains is
% \begin{enumerate}
% \item[5]
%   \(T_{0,2} ( d - 1 )  \geqslant 0\).
% \item[11]
%   \(T_{2,2} ( d - 1 )  \geqslant 0\).
% \end{enumerate}
% which hints that \(d=1\). 
% 
% 
% \subsection{Fifth attempt}
% 
% My constant failure to direct \emph{all} derived equalities, in 
% combination with my realisation that \(\Delta \otimes \mathrm{id} 
% \circ T \equiv \mathrm{id} \otimes T \circ T \otimes \mathrm{id} 
% \circ \mathrm{id} \otimes \Delta\) in a super-Hopf algebra has led 
% me to susptect that I was heading in the wrong direction with this. 
% If, as this identity suggests, a twist on the simple side of a 
% product or coproduct can be moved to the other side of it (turning 
% one twist into two, but avoiding the left--right swap that an 
% antipode would cause) then one would expect all rules with such a 
% twist--(co)product combination to eventually be found unnecessary, 
% even if it takes a while. Moreover, an incomparable equality with 
% such a feature will similarly be reopened and hopefully resolved, 
% so that they even occur is just a consequence of the search space 
% not matching the natural order of a proof. To even have turned them 
% into rules in the first place may have seriously distorted the 
% search, since much time has been spent in unproductive parts of the 
% space consisting entirely of products, coproducts, and twists.
% 
% A consequence of setting these rules and equalities aside is that 
% the associativity and coassociativity rules can be given a more 
% prominent position in the ordering\Dash not in |mainMap|, but 
% immediately following it. The criteria for ordering twists relative 
% to products and coproducts can then be demoted to a tertiary 
% position, but what those criteria should be is at this time of 
% writing far from clear; the only thing I've come up with that works 
% both for \(\Delta \otimes \mathrm{id} \circ T \mapsto
% \mathrm{id} \otimes T \circ T \otimes \mathrm{id} 
% \circ \mathrm{id} \otimes \Delta\) and 
% \(\mathrm{id} \otimes \Delta \circ T \mapsto
% T \otimes \mathrm{id} \circ \mathrm{id} \otimes T \circ 
% \Delta \otimes \mathrm{id}\) is to put negative weight on the 
% twist, which would violate DCC! Hence it might be time for another 
% round of indeterminate calculations.
% 
% \subsubsection{Biaffine calculations}
% 
% The |biaffine| PROP has been good so far, so it should be given pole 
% position in this calculation, but I fear it won't be enough.
% \begin{tcl}
interp alias {} Coeff_ring {} ::mtmtcl::rings::semigroup_algebra {
   ::mtmtcl::rings::integer
} [list ::mtmtcl::groups::power_product_monoid_1.3 [
   list ::mtmtcl::sets::variable_set\
     {a b c d e A B C D E T01 T02 T10 T11 T12 T20 T21 T22} $extraD
]]
interp alias {} PROP {} mtmtcl::matprop::biaffine Coeff_ring
% \end{tcl}
% The inequalities are going to be computed using 
% |latex_inequalities|, which means the sides to compare will have to 
% be expressed as a rule. 
% \begin{tcl}
set othersL {}
add_rule {} pure [
   network::pure::construct $vertex_types {twist \r . Delta}
] pure [
   network::pure::construct $vertex_types\
     {Delta . \r . twist \r twist .}
] othersL
add_rule {} pure [
   network::pure::construct $vertex_types {twist \r Delta .}
] pure [
   network::pure::construct $vertex_types\
     {. Delta \r twist . \r . twist}
] othersL
% \end{tcl}
% 
% 
% \begin{tcl}
set code [
   latex_inequalities {o0 o1} Delta [
      PROP fromparts [Coeff_ring 0]\
        [list [Coeff_ring named A] [Coeff_ring named B]]\
        [list [Coeff_ring named C]]\
        [list [list [Coeff_ring named D]] [list [Coeff_ring named E]]]
   ] m [
      PROP fromparts [Coeff_ring 0]\
        [list [Coeff_ring named c]]\
        [list [Coeff_ring named a] [Coeff_ring named b]]\
        [list [list [Coeff_ring named d] [Coeff_ring named e]]]
   ] twist [
      PROP fromparts [Coeff_ring 0] [
         list [Coeff_ring named T10] [Coeff_ring named T20]
      ] [
         list [Coeff_ring named T01] [Coeff_ring named T02]
      ] [
         list [list [Coeff_ring named T11] [Coeff_ring named T12]]\
           [list [Coeff_ring named T21] [Coeff_ring named T22]]
      ]
   ]
]
% \end{tcl}
% The result can be found in Table~\ref{Tab:Twist-Delta-biaffine}.
% \begin{table}
% \begin{enumerate}
% \item[o0:1]
%   \(C T_{2,0} - B T_{0,1} - A T_{0,1} - T_{0,2} T_{1,0} - 
%     B T_{0,2} T_{1,1}  \geqslant 0\).
% \item[2]
%   \(- ( A T_{1,1} ) - T_{1,0} T_{1,2} - B T_{1,1} T_{1,2}  \geqslant 0\).
% \item[3]
%   \(A + D T_{2,0} - T_{2,0} - A T_{2,1} - T_{1,0} T_{2,2} - 
%     B T_{1,1} T_{2,2}  \geqslant 0\).
% \item[4]
%   \(B + E T_{2,0} - T_{2,0} - B T_{2,1}  \geqslant 0\).
% \item[5]
%   \(T_{0,1} + C T_{2,1} - C - E T_{0,1} - D T_{0,1} - E T_{0,2} T_{1,1}  
%   \geqslant 0\).
% \item[6]
%   \(C T_{2,2} - T_{0,2} T_{1,2}  \geqslant 0\).
% \item[7]
%   \(T_{1,1} ( 1 - D - E T_{1,2} )  \geqslant 0\).
% \item[8]
%   \(T_{1,2} ( 1 - T_{1,2} )  \geqslant 0\).
% \item[9]
%   \(- E T_{1,1} T_{2,2}  \geqslant 0\).
% \item[10]
%   \(T_{2,2} ( D - T_{1,2} )  \geqslant 0\).
% \item[12]
%   \(T_{2,2} ( E - 1 )  \geqslant 0\).
% \item[o1:13]
%   \(C T_{1,0} - A T_{0,2} - T_{0,1} T_{2,0} - A T_{0,1} T_{2,2} - 
%     B T_{0,2}  \geqslant 0\).
% \item[14]
%   \(A + D T_{1,0} - T_{1,0} - A T_{1,2}  \geqslant 0\).
% \item[15]
%   \(B + E T_{1,0} - T_{1,0} - T_{1,1} T_{2,0} - A T_{1,1} T_{2,2} - 
%     B T_{1,2}  \geqslant 0\).
% \item[16]
%   \(- ( T_{2,0} T_{2,1} ) - A T_{2,1} T_{2,2} - B T_{2,2}  \geqslant 0\).
% \item[17]
%   \(C T_{1,1} - T_{0,1} T_{2,1}  \geqslant 0\).
% \item[18]
%   \(T_{0,2} + C T_{1,2} - C - D T_{0,2} - D T_{0,1} T_{2,2} - E T_{0,2} 
%   \geqslant 0\).
% \item[19]
%   \(T_{1,1} ( D - 1 )  \geqslant 0\).
% \item[21]
%   \(T_{1,1} ( E - T_{2,1} )  \geqslant 0\).
% \item[22]
%   \(- D T_{1,1} T_{2,2}  \geqslant 0\).
% \item[23]
%   \(T_{2,1} ( 1 - T_{2,1} )  \geqslant 0\).
% \item[24]
%   \(T_{2,2} ( 1 - D T_{2,1} - E )  \geqslant 0\).
% \end{enumerate}
% \caption{Biaffine coefficients for \(\mathrm{id}\otimes\Delta \circ 
%   T\)}
% \label{Tab:Twist-Delta-biaffine}
% \end{table}
% A case-by-case analysis of this system reveals two solutions, both 
% with \(1 \geqslant T_{1,2},T_{2,1} > 0\) and \(T_{0,1} = T_{0,2} = 
% T_{1,0} = T_{1,1} = T_{2,0} = T_{2,2} = 0\), namely:
% \begin{itemize}
%   \item 
%     \(T_{1,2}=T_{2,1}=1\), and no restrictions on $A$, $B$, 
%     $C$, $D$, or $E$ besides the ``no zero row or column'' 
%     condition. This does not allow a strict inequality.
%   \item
%     \(T_{1,2}T_{2,1} < 1\), \(C=0\), and no restrictions on $A$, 
%     $B$, $D$, or $E$ besides the ``no zero row or column'' 
%     condition. This allows a strict inequality, but would violate 
%     the DCC.
% \end{itemize}
% 
% 
% \begin{tcl}
%</PROPcompare>
% \end{tcl}
% 
\endinput