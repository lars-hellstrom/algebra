% 
% \iffalse driver
%<*driver>
\documentclass{mtmtcl}
\begin{document}
\DocInput{support.dtx}
\end{document}
%</driver>
% \fi
% 
% 
% 
% \section{Auxilliary interfaces}
% 
% \begin{tcl}
%<*pkg>
namespace eval ::mtmtcl::support {}
% \end{tcl}
% \setnamespace{mtmtcl::support}
% 
% \begin{proc}{constant}
%   This procedure takes one argument and returns it.
%   \begin{tcl}
proc ::mtmtcl::support::constant {arg} {return $arg}
%   \end{tcl}
%   This is probably not needed; |::return -level 0| does this too.
% \end{proc}
% 
% \begin{proc}{sdAPI}
%   The |sdAPI| procedure can be used to give a uniform handling of 
%   static and dynamic API queries. It has the call syntax
%   \begin{displaysyntax}
%     ::mtmtcl::support::sdAPI \word{interface-list} 
%     \word{compute-prefix} \word{parameter count} \meta{parameters} 
%     \word{API-dict} \word{interface}\regopt\ \word{version}\regopt
%   \end{displaysyntax}
%   where the last three items are as for the |::APIutil::API| 
%   command. A nonempty \word{API-dict} signals that the API is 
%   precomputed and need only be parsed, but otherwise it is up to 
%   this command to supervise the computation of the API.
%   
%   The idea is that the \word{compute-prefix} should be an 
%   ensemble-like command prefix with interfaces as subcommands. 
%   The call syntax for these commands is
%   \begin{displaysyntax}
%     \meta{compute-prefix} \word{interface} \meta{parameters}
%     \word{API-dict} \word{interface}\regopt\ \word{version}\regopt
%   \end{displaysyntax}
%   and they return a list of versions that they support for this 
%   interface. The list would typically be the list of all versions 
%   supported, but \emph{if} there is an explicit \word{version} and 
%   it is cheaper to test for only this than to list all supported 
%   versions, then it is perfectly acceptable to return only this 
%   version.
%   
%   The \word{parameter count} argument is the number of 
%   elements in the \meta{parameters}, which is needed to identify 
%   the \word{API-dict} etc.~arguments. The reason for this call 
%   syntax is that |sdAPI| might be used as implementation of the 
%   |API| method in an ensemble with parameters.
%   
%   \begin{tcl}
proc ::mtmtcl::support::sdAPI {interfaces prefix paramcount args} {
   set tail [lrange $args $paramcount end]
   if {[dict size [lindex $tail 0]]} then {
      return [::APIutil::API {*}$tail]
   }
   if {[llength $tail] > 1} then {
      set verL [{*}$prefix [lindex $tail 1] {*}$args]
      if {[llength $tail] == 2} then {
         return $verL
      }
      foreach ver $verL {
         if {[package vsatisfies $ver [lindex $tail 2]]} then {
            return 1
         }
      }
      return 0
   }
   set res [dict create]
   foreach interface $interfaces {
      set verL [{*}$prefix $interface {*}$args]
      if {[llength $verL]} then {dict set res $interface $verL}
   }
   return $res
}
%   \end{tcl}
% \end{proc}
% 
% 
% \subsection{Equality}
% 
% In some cases, it is important to have a canonical representation for 
% an value. The most immediate need for this occurs when values are 
% used as keys in \Tcl\ dictionaries, as equality of keys is always 
% string equality. There are two naturally occurring approaches to 
% canonical representation: automatic and manual conversion to 
% canonical form. Automatic canonicity is something often seen with 
% numbers (in particular integers), whereas for quotient algebras the 
% problem of canonical representation (normal forms) is felt even at 
% the mathematical level.
% 
% In \Tcl, lists are containers with automatic canonicity\Ldash two 
% lists generated by list commands are equal as strings if and only if 
% they have the same number of elements and the $i$th elements of the 
% lists are equal as strings\Dash whereas dictionaries are not. The 
% catch for dictionaries is that the order of the keys is not uniquely 
% determined, and even though only a few orders occur in practice, 
% the exact order used depends on how the dictionary was constructed. 
% 
% 
% \begin{APIspec}{equality}{1.0}
%   The |equality| interface v\,1.0 is applicable to principal 
%   structures. It implies that there exists a method
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%     which returns a boolean, and thus constitutes a binary relation 
%     on the principal set of elements $S$. Moreover this relation 
%     must be an equivalence relation, i.e.,
%     \begin{displaysyntax}
%       [\meta{structure} = $a$ $a$]
%     \end{displaysyntax}
%     is boolean true for any \(a \in S\) (reflexivity),
%     \begin{displaysyntax}
%       [\meta{structure} = $a$ $b$]\par
%       [\meta{structure} = $b$ $a$]
%     \end{displaysyntax}
%     are equivalent for any \(a,b \in S\) (symmetry), and for all 
%     \(a,b,c \in S\) if both of 
%     \begin{displaysyntax}
%       [\meta{structure} = $a$ $b$]\par
%       [\meta{structure} = $b$ $c$]
%     \end{displaysyntax}
%     are true then
%     \begin{displaysyntax}
%       [\meta{structure} = $a$ $c$]
%     \end{displaysyntax}
%     must be true as well (transitivity).
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{definition}
%   A method taking as input zero or more elements of structures 
%   which support the |equality| v\,1.0 interface is said to be 
%   \defining{congruent} if two arguments lists which are pointwise 
%   |=|-equal produce equal output, where the latter `equal' should 
%   be interpreted in accordance to how the output values of the 
%   method is described.
% \end{definition}
% 
% \begin{APIspec}{equality}{1.1}
%   Version 1.1 of the |equality| interface extends the |=| to be 
%   variadic.
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{=}
%       \word{element}\regstar
%     \end{APImethod}
%     Returns boolean true if the binary form would return true for 
%     any two of \word{element}s.
%     
%     As usual, the status of |=| as equivalence relation implies that
%     \begin{displaysyntax}
%       [$S$ = $a_1$ $a_2$ $\dots$ $a_n$]
%     \end{displaysyntax}
%     is true if and only if all of
%     \begin{displaysyntax}
%       [$S$ = $a_1$ $a_2$]\par
%       [$S$ = $a_2$ $a_3$]\par
%       $\vdots$\par
%       [$S$ = $a_{n-1}$ $a_n$]
%     \end{displaysyntax}
%     are true.
%   \end{APIdescription}
%   The nullary and unary forms of |=| always return true, but this is 
%   sensible behaviour when applied to expanded lists. In particular, 
%   it is a consequence of having as property that adding extra 
%   \word{element}s can change the result from true to false, but not 
%   vice versa.
% \end{APIspec}
% 
% 
% \begin{APIspec}{canonise}{1.0}
%   The |canonise| interface v\,1.0 is applicable to principal 
%   structures. It implies that there exists a method
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{canonise}
%       \word{element}
%     \end{APImethod}
%       which returns the canonical form of the \word{element}. This 
%       method has to satisfy the property that
%       \begin{displaysyntax}
%         [$S$ canonise [$S$ canonise $a$]]\par
%         [$S$ canonise $a$]
%       \end{displaysyntax}
%       are equal as strings for all elements $a$ of the 
%       \meta{structure} $S$.
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{APIspec}{canonise}{1.1}
%   It is natural to relate canonicity to equality, but that requires 
%   having an equality relation to relate it to.
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       This method satisfies the \texttt{equality} (v\,1.0) interface.
%       
%     \begin{APImethod}{canonise}
%       \word{element}
%     \end{APImethod}
%       Two elements $a$ and $b$ of a \meta{structure} $S$ are 
%       |=|-equal if and only if the two expressions
%       \begin{displaysyntax}
%         [$S$ canonise $a$]\par
%         [$S$ canonise $b$]
%       \end{displaysyntax}
%       are equal as strings.
%   \end{APIdescription}
% \end{APIspec}
% 
% 
% \begin{APIspec}{onlycanonical}{1.0}
%   The |onlycanonical| interface is applicable to arbitrary structure. 
%   Version 1.0 of it means that the \emph{only} valid representations 
%   for elements are the canonical ones.
% \end{APIspec}
% 
% 
% \begin{APIspec}{autocanonical}{1.0}
%   The |autocanonical| interface v\,1.0 is applicable to 
%   arbitrary structures. It is supported if all elements computed 
%   by the structure methods are on canonical form.
% \end{APIspec}
% 
% Version~1.0 of |autocanonical| is problematic in that it makes a 
% vague reference to ``all elements computed by the structure''\Dash 
% a promise that it might be hard to verify. Two alternatives are:
% \begin{enumerate}
%   \item
%     Split |autocanonical| into a family of interfaces (one for each 
%     method).
%   \item
%     Create a new version of the interface which makes provides a 
%     method for quering whether a method is autocanonical.
% \end{enumerate}
% Both are possible, although the first looks a bit strange.
% 
% \begin{APIspec}{autocanonical \meta{method}}{1.0}
%   This interface claims that elements output from the \meta{method} 
%   are on canonical form.
% \end{APIspec}
% 
% \begin{APIspec}{autocanonical}{2.0}
%   Structures supporting version 2.0 of the |autocanonical| interface 
%   have a method
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{autocanonical}
%       \word{method}
%     \end{APImethod}
%       This call returns a boolean. If it returns boolean true, then 
%       this \meta{structure} has a method \word{method} which only 
%       outputs elements on canonical form.
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{tcl}
namespace eval ::mtmtcl::sets {}
% \end{tcl}
% \setnamespace{mtmtcl::set}
% 
% \begin{APIspec}{finite set}{1.0}
%   The |finite set| interface v\,1 is for sets like 
%   $\{a_1,\dotsc,a_n\}$ that are introduced by listing all the 
%   elements. It is in particular a single-sorted interface.
%   
%   \begin{APIdescription}{set}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies v\,1.0 of the |equality| interface.
%       
%     \begin{APImethod}{elements}
%     \end{APImethod}
%       The |elements| method returns the list of elements in the set. 
%       No two elements of this list may be |=|-equal.
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{APIspec}{finite set}{1.1}
%   Version 1.1 of |finite set| refines version 1.0 by making it 
%   possible to identify elements by index.
%   \begin{APIdescription}{set}
%     \begin{APImethod}{elements}
%     \end{APImethod}
%       The order of elements in the list returned by this method must 
%       not change over time.
%   \end{APIdescription}
% \end{APIspec}
% 
% 
% \begin{proc}{finite_ordinal}
%   In set theory (at least the most common flavours of it), the 
%   \emph{ordinal numbers} is a number system construction where each 
%   number is the set of all smaller numbers, so that \(0 = 
%   \emptyset\), \(1 = \{0\} = \{\emptyset\}\), \(2 = \{0,1\} = \bigl\{ 
%   \emptyset, \{\emptyset\} \bigr\}\), \(3 = \{0,1,2\} = \Bigl\{ 
%   \emptyset, \{\emptyset\}, \bigl\{ \emptyset, \{\emptyset\} \bigr\} 
%   \Bigr\}\), and so on. Theoretically this is useful mostly for the 
%   infinite ordinals, where one can define the first inifinite ordinal 
%   $\omega$ simply as the set of all finite ordinals (natural 
%   numbers), and then continue with \(\omega + 1 = \omega \cup 
%   \{\omega\}\), \(\omega + 2 = \omega \cup \{\omega, \omega+1\}\), 
%   etc., with the first uncountable ordinal arising precisely as the 
%   set of all countable ordinals. Obviously, these transfinite 
%   applications are not the subject here.
%   
%   Instead, this procedure merely usurps the name for the family of 
%   finite set structures of the form $\{0,\dotsc,n-1\}$, since these 
%   technically happen to be finite ordinals. The basic call syntax is
%   \begin{displaysyntax}
%     |::mtmtcl::sets::finite_ordinal| \word{cardinality}
%     \word{method} \word{argument}\regstar
%   \end{displaysyntax}
%   whereas the return value depends on the \word{method}.
%   \begin{tcl}
proc ::mtmtcl::sets::finite_ordinal {card method args} {
   switch -- $method {
%   \end{tcl}
%   
%   \begin{procmethod}{elements}
%     This is the main method of this structure: construct a list of 
%     the integers $0$ through one less than the cardinality.
%     \begin{tcl}
      elements {
         set res [list]
         for {set n 0} {$n < $card} {incr n} {lappend res $n}
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{=}
%     Equality is straightforward.
%     \begin{tcl}
      = { expr {[lindex $args 0] == [lindex $args 1]} }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{canonise}
%     However, since the above allows arbitrary integer 
%     representations, it might be best to define a canonisation 
%     method as well. This can be a good place to check argument 
%     validity.
%     \begin{tcl}
      canonise {
         if {
           [string is integer -strict [lindex $args 0]] &&\
           [lindex $args 0] >= 0 && [lindex $args 0] < $card
         } then {
            return [expr {[lindex $args 0] + 0}]
         } else {
            return -code error "Not an element"
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{API}
%     Finally, the supported interfaces must be listed.
%     \begin{tcl}
      API {
         ::APIutil::API {equality 1.0  "finite set" 1.1 \
            canonise 1.0} {*}$args
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{proc}{string_set}
%   This procedure implements a finite set of strings as a structure. 
%   The basic call syntax is
%   \begin{displaysyntax}
%     |::mtmtcl::sets::string_set| \word{element-list}
%     \word{method} \word{argument}\regstar
%   \end{displaysyntax}
%   whereas the return value depends on the \word{method}.
%   \begin{tcl}
proc ::mtmtcl::sets::string_set {elements method args} {
   switch -- $method {
%   \end{tcl}
%   
%   \begin{procmethod}{elements}
%     The list of elements is simply the |elements| parameter.
%     \begin{tcl}
      elements {return $elements}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{=}
%     Equality is as strings.
%     \begin{tcl}
      = { string equal [lindex $args 0] [lindex $args 1] }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{canonise}
%     The only valid representations are the canonical ones, but 
%     it is convenient to provide a canonisation method for users 
%     that expect one, even if it is trivial.
%     \begin{tcl}
      canonise {return [lindex $args 0]}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{export}
%     An appropriate implementation of this is to take the element 
%     as an |OMSTR| node.
%     \begin{tcl}
      export {
         return [list OMSTR [lindex $args 1]\
           [list [list \#text [lindex $args 0]]]]
      }
%     \end{tcl}
%     It is quite likely that this implementation may seem 
%     inappropriate, and that other outputs (|OMV| nodes, |OMS| 
%     nodes, either of the above with |OMATTR|) are wanted 
%     instead. This is not an error, but an opportunity to provide 
%     alternative methods implementing the |finite set| interface; 
%     regardless of how one proceeds, it would be necessary to 
%     provide additional parameters for the structure.
%   \end{procmethod}
%   
%   \begin{procmethod}{API}
%     Finally, the supported interfaces must be listed.
%     \begin{tcl}
      API {
         ::APIutil::API {equality 1.0  "finite set" 1.1 \
            canonise 1.0  onlycanonical 1.0  export 2.0} {*}$args
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% \subsection{Naming}
% 
% It is often useful to have symbolic names (that are independent of 
% the string representation) for important structure elements, and 
% translate back and forth between elements and names. Possible 
% applications of this include
% \begin{longtable}{ll}
%   \textbf{Command}& \textbf{Result}\endhead
%   |float named pi|& $3.14159265359$\\
%   |float named e|&  $2.71828182846$\\
%   |integer named Taxicab(2)|& $1729$\\
%   $\mathbb{C}$| named i|& $i = \sqrt{-1}$\\
%   $\mathbb{Q}[x,y]$| named x|& $x$
% \end{longtable}\noindent
% with the last two perhaps being the most interesting\Dash to give 
% practical access to distinguished generators of a structure. 
% Accordingly, some of the |generated|\dots\ interfaces below return 
% names of generators (rather than the actual generator elements) since 
% this is more convenient for several applications.
% 
% \begin{APIspec}{named element}{1.0}
%   The \verb*|named element| interface provides the basic 
%   functionality of mapping symbolic names to structure elements.
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{named}
%       \word{string}
%     \end{APImethod}
%       Returns the structure element whose symbolic name is 
%       \word{string}. It is not required that all return values are of 
%       the same sort, but whatever provides the name \word{string} 
%       should also provide information about what sort of element it 
%       denotes.
%   \end{APIdescription}
% \end{APIspec}
% 
% A natural extension would be to have an inverse operation |nameof| 
% which returns the name of an element (or throws an error if it isn't 
% one of the named elements), but this is complicated by the 
% possibility of having several sorts; it is in principle possible that 
% the same string could be the representation of two different named 
% elements (provided they have different sorts). On the other hand, it 
% could also be reasonable in some cases to have several names for a 
% single element\dots
% 
% Another natural extension is to have an operation |names| which 
% returns the list of known symbolic names of elements. This would in 
% particular imply that the list is finite, which is closely related to 
% the property of being finitely generated.
% 
% \begin{proc}{variable_set}
%   This procedure implements a finite set of variables as a 
%   structure. It improves upon |string_set| in that it offers 
%   control over the presentation of a variable, and in that it 
%   supports naming variables. The basic call syntax is
%   \begin{displaysyntax}
%     |::mtmtcl::sets::variable_set| \word{element-list} 
%     \word{extra-dict} \word{method} \word{argument}\regstar
%   \end{displaysyntax}
%   where \word{element-list} is the list of variable names (|name| 
%   attribute values) and \word{extra-dict} is a dictionary of 
%   additional information. The primary keys into this dictionary are 
%   very much like options, whereas element-specific information (if 
%   any) typically appears under a secondary key. The primary keys 
%   currently supported are:
%   \begin{description}
%     \renewcommand{\makelabel}[1]{\hspace\labelsep
%        \describeopt*+[mtmtcl::sets]{variable_sep}[proc]{#1}[key]^^A
%     }
%     \item[LaTeX_encoding]
%       This entry is a dictionary, indexed by elements. The value is 
%       the |LaTeX_encoding| for the element in question.
%     \item[names]
%       This entry is a dictionary, indexed by names recognised by 
%       the |named| method, and the entries are corresponding 
%       variable names. If for example a variable is technically 
%       |name|d $\delta$, but one wishes to write |delta| in one's 
%       code, then one can put
%       \begin{quote}
%         |names {delta \u03B4 |\dots| }|
%       \end{quote}
%       in one's \word{extra-dict}.
%     \item[pseudoexpression]
%       This entry is a dictionary, indexed by elements. The value 
%       is a near-OpenMath data-tree that is used as the ``content'' 
%       of the |OMV| node upon export. This can be used to improve 
%       the presentation of the variable.
%   \end{description}
%   
%   The internal representation of an element of this structure is as 
%   a string, more precisely as a string which is an element of the 
%   \word{element-list}.
%   \begin{tcl}
proc ::mtmtcl::sets::variable_set {elements extra method args} {
   switch -- $method {
%   \end{tcl}
%   
%   \begin{procmethod}{elements}
%     The list of elements is simply the |elements| parameter.
%     \begin{tcl}
      elements {return $elements}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{=}
%     Equality is as strings.
%     \begin{tcl}
      = { string equal [lindex $args 0] [lindex $args 1] }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{canonise}
%     The only valid representations are the canonical ones, but 
%     it is convenient to provide a canonisation method for users 
%     that expect one, even if it is trivial.
%     \begin{tcl}
      canonise {return [lindex $args 0]}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{named}
%     Names are first looked up in the |names| dictionary, then taken 
%     as explicit variable |name|s.
%     \begin{tcl}
      named {
         if {[llength $args] != 1} then {
            return -code error "wrong # arguments, should be:\
              <variable set> named {name}"
         }
         if {[dict exists $extra names [lindex $args 0]]} then {
            return [dict get $extra names [lindex $args 0]]
         } elseif {[lindex $args 0] in $elements} then {
            return [lindex $args 0]
         } else {
            return -code error "unknown variable: [lindex $args 0]"
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{names}
%     The set of variable names is just the set of elements.
%     \begin{tcl}
      names {return $elements}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{export}
%     This is the most complex method, since no less than two of the 
%     \word{extra-dict} entries exist to provide data for it. On the 
%     other hand, it's a pretty straightforward arrangement of 
%     available data in the requested format.
%     \begin{tcl}
      export {
         if {[llength $args] != 2} then {
            return -code error "wrong # arguments, should be:\
              <variable set> export {element} {attributes}"
         }
         foreach {var attr} $args break
         set res {}
         if {[dict exists $extra pseudoexpression $var]} then {
            lappend res [dict get $extra pseudoexpression $var]
         }
         set res [list OMV [dict replace $attr name $var] $res]
         if {[dict exists $extra LaTeX_encoding $var]} then {
            set res [list OMATTR $attr [list [
               list OMATP {} [list\
                 {OMS {cd altenc name LaTeX_encoding} {}}\
                 [list OMSTR {} [dict get $extra LaTeX_encoding $var]]]
            ] $res]
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{import}
%     Import is pretty straightforward here; the things that might 
%     occur at this point are precisely the OpenMath variables. The 
%     only complication is that they may carry an attribution, but 
%     that is ignored. Variable |name|s must match exactly.
%     \begin{tcl}
      import {
         if {[llength $args] != 2} then {
            return -code error "wrong # arguments, should be:\
              <variable set> import {tree} {path}"
         }
         set tree [lindex $args 0]
         while {[lindex $tree 0] eq "OMATTR"} {
            set tree [lindex $tree 2 1]
         }
         if {[lindex $tree 0] eq "OMV"} then {
            set var [dict get [lindex $tree 1] name]
            if {$var in $elements} then {return $var}
            return -code error\
              -errorcode [list API import EDOM $path $tree]\
              "unknown variable: $var"
         }
         return -code error\
           -errorcode [list API import EDOM $path $tree]\
           "Expected OMV, got [lindex $tree 0]"
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{API}
%     Finally, the supported interfaces must be listed.
%     \begin{tcl}
      API {
         ::APIutil::API {equality 1.0  "finite set" 1.1 \
            canonise 1.0  onlycanonical 1.0 "named element" 1.0 \
            export 2.0  import 1.0} {*}$args
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
      default {
         return -code error "Unknown subcommand \"$method\",\
           must be: =, API, canonise, elements, export, import,\
           or named"
      }
   }
}
%   \end{tcl}
% \end{proc}
% 
% 
% 
% 
% \subsection{Understructure access}
% 
% It could be convenient, as a curtesy by adapters and adaptors, to 
% provide access to the underlying structure. Algorithms should not 
% make use of this, but it can be awfully useful for debugging.
% 
% The natural format would be to have a method which accesses the 
% underlying structure, but what should it be called? Possibilities 
% are:
% \begin{longtable}{lp{0.6\linewidth}}
%   base& But that's too close to basis and such.\\
%   understructure& Surprisingly enough, an official English word. 
%     Feels a bit childish, though (perhaps because it mixes Germanic 
%     and Latin words).\\
%   foundation& Certainly posh enough, and seems unclaimed in math.\\
%   fundament& Ditto.\\
%   stem& To the point, but could perhaps be useful for other things.
% \end{longtable}
% Since it's not to be used in production, |understructure| might 
% actually be appropriate; otherwise |fundament| seems best.
% 
% 
% \subsection{Products}
% 
% \begin{APIspec}{direct product}{1.0}
%   A \texttt{direct product} of structures has elements composed from 
%   component structure elements.
%   
%   \begin{APIdescription}{product}
%     \begin{APImethod}{no.components}
%     \end{APImethod}
%       This method returns the number of factors (components) in the 
%       product.
%       
%     \begin{APImethod}{component}
%       \word{index} \word{method} \word{argument}\regstar
%     \end{APImethod}
%       This method gives easy access to component structure methods. 
%       The \word{index} $i$ is an integer \(0 \leqslant i < n\) where 
%       $n$ is the number of factors. The command prefix
%       \begin{displaysyntax}
%         \meta{product} component \word{index}
%       \end{displaysyntax}
%       is a command prefix for the \word{index}th component of the 
%       structure.
%       
%     \begin{APImethod}{index}
%       \word{index} \word{element}
%     \end{APImethod}
%       This returns the projection of the \word{element} onto the 
%       \word{index}th component, an element of the \word{index}th 
%       component structure.
%       
%     \begin{APImethod}{tuple}
%       \word{component}\regstar
%     \end{APImethod}
%       The $i$th \word{component} must be an element of the $i$th 
%       component structure, and there must be exactly 
%       \texttt{[\meta{product} no.components]} \word{component} 
%       arguments. This returns the element of the \meta{product} 
%       structure which consists of the specified \word{component}s.
%   \end{APIdescription}
% \end{APIspec}
% 
% Direct products are normally required to satisfy a decomposition 
% axiom\Ldash two tuples are equal iff they have the same 
% components\Dash but this requires having |equality|.
% 
% \begin{APIspec}{direct product}{1.1}
%   A \texttt{direct product} with equality 
%   
%   \begin{APIdescription}{product}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       This method satisfies the \APIref{equality}{1.0} interface.
%       
%     \begin{APImethod}{component}
%       \word{index} = \word{argument}\regstar
%     \end{APImethod}
%       Every component structure also satisfies the 
%       \APIref{equality}{1.0} interface.
%   \end{APIdescription}
%   
%   Furthermore the |index| and |tuple| methods have to be congruent, 
%   i.e., if $a$ and $b$ are |=|-equal in the \texttt{direct product} 
%   $P$, then
%   \begin{displaysyntax}
%     [$P$ index $k$ $a$]\par
%     [$P$ index $k$ $b$]
%   \end{displaysyntax}
%   are (\texttt{component}~$k$~|=|)-equal for every $k$, and if 
%   $a_k$ is (\texttt{component}~$k$~|=|)-equal to $b_k$ for every 
%   \(0 \leqslant k < n\),then
%   \begin{displaysyntax}
%     [$P$ tuple $a_0$ \dots~$a_{n-1}$]\par
%     [$P$ tuple $b_0$ \dots~$b_{n-1}$]
%   \end{displaysyntax}
%   are |=|-equal.
% \end{APIspec}
% 
% 
% \begin{ensemble}{cartesian_product}
%   The |cartesian_product| ensemble implements the direct product 
%   of two structures with equality. The general syntax is
%   \begin{displaysyntax}
%     |::mtmtcl::sets::cartesian_product| \word{substructures} 
%     \word{API} \word{method} \word{arg}\regstar
%   \end{displaysyntax}
%   where the \word{substructures} and \word{API} are parameters that 
%   would be part of the structure command prefix. The \word{API} may 
%   be empty, in which case API queries are computed at each call, or 
%   a dictionary.
%   
%   An element of the cartesian structure is a list of elements in 
%   the substructures; list element $i$ belongs to substructure $i$.
%   
%   \begin{tcl}
namespace eval ::mtmtcl::sets::cartesian_product {
   namespace ensemble create -prefix 0\
     -subcommands {API = component index tuple canonise}\
     -parameters {substructures API-dict}
%   \end{tcl}
%   
%   \begin{ensproc}{API}
%     The |API| method implementation makes use of a helper ensemble 
%     also named |API| to compute supported version lists for the 
%     relevant interfaces (\APIref{direct product}{1.1}, 
%     \APIref{equality}{1.0}, and \APIref{canonise}{1.0}), but the 
%     actual |API| method handler is the |::mtmtcl::support::sdAPI| 
%     command.
%     \begin{tcl}
   namespace ensemble create -command [namespace current]::API -map {
      equality  API,equality
      canonise  API,canonise
      "direct product" API,direct_product
   } -unknown {list apply {args {}}}
   namespace ensemble configure ::mtmtcl::sets::cartesian_product\
     -map [dict create API [
        list ::mtmtcl::support::sdAPI\
          {"direct product" "equality" "canonise"}\
          [namespace which API] 1
   ]]
%     \end{tcl}
%   \end{ensproc}
%   
%   \begin{ensproc}{no.components}
%     The number of components is the number of component structures.
%     \begin{tcl}
   proc no.components {substructures API} {llength $substructures}
%     \end{tcl}
%   \end{ensproc}
%   
%   \begin{ensproc}{component}
%     Accessing a component structure is mostly a matter of indexing. 
%     \begin{tcl}
   proc component {substructures API index args} {
      tailcall {*}[lindex $substructures $index] {*}$args
   }
%     \end{tcl}
%     Using |tailcall| makes it straightforward for the component 
%     structure to use |upvar| (an |uplevel| could work too, but 
%     raises a few issues for impure list command prefixes).
%   \end{ensproc}
%   
%   \begin{ensproc}{index}
%     Apart from the order of arguments, this just |lindex|.
%     \begin{tcl}
   proc index {substructures API index elem} {lindex $elem $index}
%     \end{tcl}
%   \end{ensproc}
%   
%   \begin{ensproc}{tuple}
%     And |tuple| is just |list|, on a subset of the arguments.
%     \begin{tcl}
   proc tuple {substructures API args} {return $args}
%     \end{tcl}
%   \end{ensproc}
%   
%   \begin{ensproc}{=}
%     Two elements are equal iff their components are equal.
%     \begin{tcl}
   proc = {substructures API a b} {
      foreach S $substructures ak $a bk $b {
         if {![{*}$S = $ak $bk]} then {return 0}
      }
      return 1
   }
%     \end{tcl}
%   \end{ensproc}
%   
%   \begin{proc}{API,equality}
%     Testing for \APIref+{equality}{1.0} thus requires that all 
%     component structures support it.
%     \begin{tcl}
   proc API,equality {substructures args} {
      foreach S $substructures {
         if {![{*}S API equality 1.0]} then {return ""}
      }
      return [list 1.0]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{API,direct product}
%     The \APIref{direct product}{1.1} version is 1.1 if the 
%     structure has \APIref{equality}{1.0}, and 1.0 otherwise.
%     \begin{tcl}
   proc {API,direct product} {substructures args} {
      foreach S $substructures {
         if {![{*}S API equality 1.0]} then {return [list 1.0]}
      }
      return [list 1.1]
   }
%     \end{tcl}
%     One could alternatively make use of |API,equality| here, but it 
%     is easier to duplicate the test than to parse the result of 
%     |API,equality|.
%   \end{proc}
%   
%   \begin{ensproc}{canonise}
%     A pure list will receive its canonical string representation 
%     when one is requested, so we're fine once the list elements 
%     have been canonised.
%     \begin{tcl}
   proc canonise {substructures API tuple} {
      set res {}
      foreach s $substructures t $tuple {
         lappend res [{*}$s canonise $t]
      }
      return $res
   }
%     \end{tcl}
%   \end{ensproc}
%   
%   \begin{proc}{API,canonise}
%     In order for the product to satisfy \APIref+{canonise}{1.1}, 
%     all its components need to do that as well, but if some only 
%     satisfy \APIref+{canonise}{1.0} then that is what it'll have to 
%     be.
%     \begin{tcl}
   proc API,canonise {substructures args} {
      set minor 1
      foreach S $substructures {
         if {$minor==1} then {
            if {![{*}$S API canonise 1.1]} then {set minor 0}
         }
         if {$minor==0} then {
            if {![{*}$S API canonise 1.0]} then {return ""}
         }
      }
      return [list 1.$minor]
   }
}
%     \end{tcl}
%   \end{proc}
%   
% \end{ensemble}
% 
% 
% \subsection{Random structure elements}
% 
% For e.g.~testing purposes, it is sometimes convenient to have a 
% source of arbitrary structure elements. Practically this can be 
% implemented as a method which generates ``random'' structure 
% elements from a given source of ``random'' data.
% 
% 
% \begin{APIspec}{random element}{1.0}
%   This interface is applicable to principal structures. 
%   \begin{APIdescription}{structure}
%     \begin{APImethod}{random}
%       \word{PRNG}
%     \end{APImethod}
%       This method returns a random element in the structure. 
%       The \word{PRNG} is a prefix supporting the \APIref+{random 
%       bit}{1.0} and \APIref+{random integer}{1.0} interfaces. 
%       The |random| method should use it as its source of random 
%       data.
%   \end{APIdescription}
% \end{APIspec}
% 
% 
% \subsection{Random number generators}
% 
% Random number generators are present in \mtl\ primarily because the 
% |random element| interface needs them. The definitions here follow 
% those of \emph{The API convention} documentation~\cite{LH:API}.
% 
% 
% \begin{APIspec}{random bit}{1.0}
%   Version 1.0 of |random bit| offers the basic ``flip of a coin''.
%   \begin{APIdescription}{PRNG}
%     \begin{APImethod}{bit}
%     \end{APImethod}
%     Returns |0| or |1|, randomly and with equal probability.
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{APIspec}{random bit}{2.0}
%   Version 2.0 of |random bit| adds the possibility that the 
%   mechanisms for pseudo-random number generation are present even if 
%   they are uninitialised.
%   \begin{APIdescription}{PRNG}
%     \begin{APImethod}{seeded}
%     \end{APImethod}
%     The |seeded| method is used to check whether \meta{PRNG} is 
%     seeded. It returns |0| if \meta{PRNG} is not fully seeded and 
%     therefore cannot produce output, |1| if \meta{PRNG} has been 
%     fully seeded, and |-1| if it has not been fully seeded but can 
%     generate output anyway.
%     
%     \begin{APImethod}{bit}
%     \end{APImethod}
%     If the |seeded| method returns a boolean true value, then |bit| 
%     will return |0| or |1|, randomly and with equal probability. 
%     The behaviour of |bit| is unspecified if |seeded| returns a 
%     boolean false value.
%   \end{APIdescription}
% \end{APIspec}
% 
% 
% \begin{APIspec}{random integer}{1.0}
%   Version 1.0 of |random integer| offers the basic ``throw of a 
%   dice'' (with variable number of sides).
%   \begin{APIdescription}{PRNG}
%     \begin{APImethod}{integer}
%       \word{min}\regopt\ \word{max}
%     \end{APImethod}
%     Returns an integer $n$ such that \(\mathit{min} \leqslant n 
%     \leqslant \mathit{max}\). If omitted, \word{min} defaults to 
%     $1$. It is an error if \(\mathit{min} > \mathit{max}\). All 
%     valid return values should have the same probability.
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{APIspec}{random integer}{2.0}
%   Version 2.0 of |random integer| adds the possibility of signalling 
%   that the mechanisms for pseudo-random number generation are present 
%   even if they are uninitialised.
%   
%   \begin{APIdescription}{PRNG}
%     \begin{APImethod}{seeded}
%     \end{APImethod}
%     The |seeded| method is used to check whether \meta{PRNG} is 
%     seeded. It returns |0| if \meta{PRNG} is not fully seeded and 
%     therefore cannot produce output, |1| if \meta{PRNG} has been 
%     fully seeded, and |-1| if it has not been fully seeded but can 
%     generate output anyway.
%     
%     \begin{APImethod}{integer}
%       \word{min}\regopt\ \word{max}
%     \end{APImethod}
%     If the |seeded| method returns a boolean true value, then 
%     |integer| returns an integer $n$ such that \(\mathit{min} 
%     \leqslant n \leqslant \mathit{max}\). If omitted, \word{min} 
%     defaults to $1$. It is an error if \(\mathit{min} > 
%     \mathit{max}\). All valid return values should have the same 
%     probability.
%     
%     The behaviour of |integer| is unspecified if |seeded| returns 
%     a boolean false value.
%   \end{APIdescription}
% \end{APIspec}
% 
% \begin{tcl}
%</pkg>
% \end{tcl}
% 
% 
\endinput

