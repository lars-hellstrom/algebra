% 
% \iffalse
%<*driver>
\documentclass{mtmtcl}
\begin{document}
\DocInput{rings.dtx}
\end{document}
%</driver>
% \fi
% 
% 
% \part{Rings and modules}
% 
% \section{Rings}
% 
% 
% \begin{APIspec}{ring}{2.0}
%   A |ring| is neither required to be unital nor associative, but it 
%   is easy to impose such conditions by claiming support for |monoid| 
%   and |semigroup| respectively.
%   
%   \begin{APIdescription}{ring}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{neg}
%       \word{element}
%     \end{APImethod}
%       The |+|, |0|, and |neg| methods are as required by the 
%       \APIref{additive group}{2.0} interface version 2.0, and in 
%       addition the |+| method must be commutative, i.e., for any 
%       two elements $a$ and $b$ of a \meta{ring} $R$, the two 
%       expressions
%       \begin{displaysyntax}
%         [$R$ + $a$ $b$]\par
%         [$R$ + $b$ $a$]
%       \end{displaysyntax}
%       are |=|-equal.
%       
%     \begin{APImethod}{*}
%       \word{element} \word{element}
%     \end{APImethod}
%       Returns the product of the two \word{element}s. The |*| 
%       operation must be distributive over |+|, i.e., for any three 
%       elements $a$, $b$, and $c$ of a \meta{ring} $R$ the two 
%       expressions
%       \begin{displaysyntax}
%         [$R$ * [$R$ + $a$ $b$] $c$]\par
%         [$R$ + [$R$ * $a$ $c$] [$R$ * $b$ $c$]]
%       \end{displaysyntax}
%       are |=|-equal, as are the two expressions
%       \begin{displaysyntax}
%         [$R$ * $a$ [$R$ + $b$ $c$]]\par
%         [$R$ + [$R$ * $a$ $b$] [$R$ * $a$ $c$]]
%       \end{displaysyntax}
%   \end{APIdescription}
%   All methods are congruent.
% \end{APIspec}
% 
% \begin{APIspec}{ring}{1.0}
%   Version~1.0 of |ring| was the same as version~2.0, except that it 
%   built upon \APIref{additive group}{1.0} verion~1.0 rather than 
%   ditto version~2.0.
% \end{APIspec}
% 
% During the \APIref+{ring}{1.0} timeframe, there was no definition 
% of a \texttt{field} interface however, so major version 1 is still 
% available in that case. The main reason to define a \texttt{field} 
% interface at this point is that several basic rings also happen to 
% be fields.
% 
% \begin{APIspec}{field}{1.0}
%   A |field| is an associative and commutative division ring.
%   
%   \begin{APIdescription}{field}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{*}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{1}
%     \end{APImethod}
%       The |1| and |*| methods are as required by the 
%       \APIref+{monoid}{1.0} interface . This says |*| is associative.
%       
%       The |*| is also commutative, i.e., for any two elements $a$ 
%       and $b$ of a \meta{field} $F$, the two expressions
%       \begin{displaysyntax}
%         [$F$ * $a$ $b$]\par
%         [$F$ * $b$ $a$]
%       \end{displaysyntax}
%       are |=|-equal.
%       
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{neg}
%       \word{element}
%     \end{APImethod}
%       The |+|, |0|, |neg|, and |*| methods are as required by the 
%       \APIref{ring}{2.0} interface version 2.0.
%       
%     \begin{APImethod}{/}
%       \word{numerator} \word{denominator}
%     \end{APImethod}
%       The |/| method satisfies the \APIref+{division}{1.0} 
%       interface. In addition, this method will not throw an error 
%       unless the \word{denominator} is zero.
%       
%       \begin{remark}
%         That amounts to saying that \(ax = b\) has a solution $x$ 
%         for any nonzero $a$. In particular there is a solution 
%         $a^{-1}$ to \(a a^{-1} = 1\), and thus if $x_1$ and $x_2$ 
%         satisfy \(a x_1 = b = a x_2\) then
%         \[
%           x_1 = (a a^{-1}) x_1 = a^{-1} (a x_1) = a^{-1} b =
%           a^{-1} (a x_2) = (a a^{-1}) x_2 = x_2
%           \text{,}
%         \]
%         hence this solution is unique.
%         
%         It follows from the \APIref{ring}{2.0} interface that 
%         \texttt{[$F$ * [$F$ 0] $a$]} is zero for all $a$, and thus 
%         there is no solution to \(ax = b\) when \(a=0\) and \(b 
%         \neq 0\), which means |/| must throw the |API division\
%         nosolution| error for $b/0$. It does \emph{not} follow 
%         that it must throw an error for $0/0$, since \(0x = 0\) 
%         actually has solutions, but it \emph{may} throw the 
%         |API division unimplemented| error in that case.
%       \end{remark}
%       
%     \begin{APImethod}{inverse}
%       \word{element}
%     \end{APImethod}
%       For any nonzero \word{element} $a$ of a \meta{field} $F$, 
%       the two expressions
%       \begin{displaysyntax}
%         [$F$ / [$F$ 1] $a$]\par
%         [$F$ inverse $a$]
%       \end{displaysyntax}
%       are |=|-equal.
%       
%       \begin{remark}
%         This means that the \APIref{subset}{1.0} of a |field| 
%         consisting of the nonzero elements will be a 
%         \APIref{group}{1.0}. There is however no requirement in 
%         the |field| interface to realise this possibility.
%       \end{remark}
%   \end{APIdescription}
%   With the possible exception of |/| (in the case $0/0$), all 
%   methods are congruent.
% \end{APIspec}
% 
% 
% \subsection{Integers}
% 
% The |mtmtcl::rings::integers| package provides two types of ring: 
% the ring $\mathbb{Z}$ of all integers, and rings $\mathbb{Z}_n$ of 
% integers-modulo-$n$. The main public commands of the package are 
% the structure generators
% \begin{displaysyntax}
%   mtmtcl::rings::integers::make\par
%   mtmtcl::rings::integers::|make_modulo| \word{n}
% \end{displaysyntax}
% which return command prefixes for the structures for $\mathbb{Z}$ 
% and $\mathbb{Z}_n$ respectively.
% 
% As of version~1.2, the package also provides a command
% \begin{displaysyntax}
%   mtmtcl::rings::integers::nonnegative \word{method} 
%   \word{arg}\regstar
% \end{displaysyntax}
% which is a fixed structure for the set of nonnegative integers 
% ($\mathbb{N}$) as a \APIref+{subset}{1.1} of $\mathbb{Z}$.
% 
% \begin{tcl}
%<*docstrip.tcl::catalogue>
pkgProvide mtmtcl::rings::integers 1.2 integers
%</docstrip.tcl::catalogue>
%<*integers>
package require Tcl 8.5
package require mtmtcl::openmath
package require API 1.0
catch {package require math::numtheory}
% \end{tcl}
% The |math::numtheory::isprime| command is used to check whether a 
% modulo-$n$ ring should also be a \APIref{field}{1.0}, but this is 
% rather peripheral, so all code related to that is wrapped in 
% |catch|es for a soft fallback should |math::numtheory| be 
% unavailable.
% 
% The purpose of setting a |namespace path| for 
% |::mtmtcl::rings:inegers| is to access |mtmtcl::openmath| commands 
% without the |mtmtcl| prefix.
% \begin{tcl}
namespace eval ::mtmtcl::rings::integers {
   namespace path ::mtmtcl
}
% \end{tcl}
% \setnamespace{mtmtcl::rings::integers}
% 
% \begin{tclcommand}{ensemble}{all}
%   A structure for integers can be implemented directly as an 
%   ensemble. Since the majority of all subcommands are implemented 
%   by commands in the |tcl::mathop| namespace however, the namespace 
%   of this ensemble will be that rather than 
%   |mtmtcl::rings::integers|.
%   \begin{tcl}
namespace eval ::tcl::mathop {
   namespace ensemble create -subcommands {
      API 
      = 
      + neg 0 - iszero integer.
      * 
      1 ^ 
      canonise
      /
      export
      div mod
   } -map {
      API {
         ::API::static {
            equality 1.1
            "additive group" {2.2 1.2}
            ring {2.0 1.0}
            magma 1.1 semigroup 1.2  monoid 1.2 
            "commutative *" 1.0
            canonise 1.1
            division 1.0
            export 2.0
            import 1.0
         }
      }
      = ==
      neg -
      0 {::return -level 0 0}
      iszero {== 0}
      integer. *
      1 *
      ^ **
      canonise +
%   \end{tcl}
%   I originally tried to use |::tcl::mathfunc::entier| for 
%   canonising integers, but it turned out that \emph{didn't} 
%   canonise them, whereas |::tcl::mathop::+| did.
%   \begin{tcl}
      / ::mtmtcl::rings::integers::divide
      div /
      mod %
      export ::mtmtcl::rings::integers::export
      import ::mtmtcl::rings::integers::import
   } -command ::mtmtcl::rings::integers::all
}
%   \end{tcl}
%   
%   \begin{proc}{divide}
%     This procedure implements strict division for integers.
%     \begin{tcl}
proc ::mtmtcl::rings::integers::divide {numer denom} {
   if {$numer % $denom == 0} then {
      return [expr {$numer / $denom}]
   } else {
      return -code error -errorcode {API division nosolution}\
        "Does not divide"
   }
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{export}
%     This procedure implements the \APIref+{export}{2.0} interface 
%     for integers. The call syntax is
%     \begin{displaysyntax}
%       |::mtmtcl::rings::integers::export| \word{element} 
%       \word{attributes}
%     \end{displaysyntax}
%     
%     \begin{tcl}
proc ::mtmtcl::rings::integers::export {elem attr} {
   list integer [dict create value $elem] {}
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{import}
%     This procedure implements the \APIref+{import}{1.0} interface 
%     for integers. The call syntax is
%     \begin{displaysyntax}
%       |::mtmtcl::rings::integers::import| \word{path} \word{data-tree}
%     \end{displaysyntax}
%     It understands both \describestring*+[node type]{integer} and 
%     \describestring*+[node type]{OMI} nodes, but the former is 
%     preferred. It also skips any |OMATTR| nodes that may surround 
%     the element.
%     
%     \begin{tcl}
proc ::mtmtcl::rings::integers::import {path tree} {
   while {[lindex $tree 0] eq "OMATTR"} {
      set tree [lindex $tree 2 1]
   }
   switch -- [lindex $tree 0] "integer" {
      set value [dict get [lindex $tree 1] value]
      if {[string is integer -strict $value]} then {return $value}
   } "OMI" {
      set str [openmath::gettext $tree]
      regsub -all {\s} $str {} str
      if {[regsub {[Xx]} $str {} str] ?\
        [scan $str %llx value] : [scan $str %lld value]} then {
         return $value
      }
   }
   return -code error -errorcode [list API import EDOM $path $tree]\
     "Not an integer"
}
%     \end{tcl}
%   \end{proc}
% \end{tclcommand}
% 
% \begin{proc}{make}
%   This is a constructor command for the ring of integers structure. 
%   It takes no arguments and returns a command prefix.
%   \begin{tcl}
proc mtmtcl::rings::integers::make {} {
   list [namespace which all]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{ensemble}{nonnegative}
%   The |nonnegative| ensemble has five methods, but four of them 
%   are redirections.
%   \begin{tcl}
namespace eval mtmtcl::rings::integers::nonnegative {
   namespace ensemble create -map [dict create \
%   \end{tcl}
%   The name of the |superset| is determined dynamically.
%   \begin{tcl}
      superset [::mtmtcl::rings::integers::make] \
%   \end{tcl}
%   Equality testing is done using the superset |=|.
%   \begin{tcl}
      = [list {*}[::mtmtcl::rings::integers::make] =] \
%   \end{tcl}
%   Ditto conversion to canonical form.
%   \begin{tcl}
      canonise [list {*}[::mtmtcl::rings::integers::make] canonise] \
%   \end{tcl}
%   The main API claimed support for is \APIref+{subset}{1.1}, but 
%   \APIref{equality}{1.0} and \APIref{canonise}{1.1} are thrown in 
%   for good measure.
%   \begin{tcl}
      API {::API::static {subset 1.1  equality 1.0  canonise 1.1}} \
   ] -subcommands {superset member = canonise API}
%   \end{tcl}
%   
%   \begin{proc}{member}
%     This means the only ground method that needs to be implemented 
%     is |member|.
%     \begin{tcl}
   proc member {integer} {expr {$integer >= 0}}
%     \end{tcl}
%     However, it could just as well have been implemented using a 
%     |-map| to |apply|.
%   \end{proc}
%   
%   \begin{tcl}
}
%   \end{tcl}
% \end{ensemble}
% 
% 
% 
% \begin{proc}{modulo}
%   This procedure implements the algebraic structure of `integers 
%   modulo $n$' (denoted $\mathbb{Z}_n$, $\mathbb{Z}/n$, or 
%   $\mathbb{Z}/n\mathbb{Z}$) for positive integers $n$. The call 
%   syntax is
%   \changes{0.2}{2010/05/23}{Added API parameter/argument. (LH)}
%   \begin{displaysyntax}
%     |::mtmtcl::rings::integers::modulo| \word{$n$} \word{API} 
%     \word{method} \word{argument}\regstar
%   \end{displaysyntax}
%   so the actual \meta{ring} is the three word prefix 
%   |::mtmtcl::rings::integers::modulo |\word{$n$} \word{API}. Here, 
%   \word{API} is the API dictionary.
%   
%   The canonical representation is as an integer $k$ satisfying \(0 
%   \leqslant k < n\), but all integers are valid representations for 
%   their cosets. It is assumed that $1$ is a canonical 
%   representation for the unit, so it is required that 
%   \(n \geqslant 2\).
%   
%   \begin{tcl}
proc ::mtmtcl::rings::integers::modulo {n API method args} {
   switch -- $method {
%   \end{tcl}
%   
%   \begin{procmethod}{=}
%     A variadic |=| seems more bother than it's worth, so the binary 
%     should do.
%     \begin{tcl}
      = {expr {([lindex $args 0] - [lindex $args 1]) % $n == 0}}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{+}
%     Variadic addition is however pretty straightforward\Dash just a 
%     |foreach| loop.
%     \begin{tcl}
      + {
         set res 0
         foreach term $args {set res [expr {($res+$term)%$n}]}
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{0}
%     The zero method is trivial.
%     \begin{tcl}
      0 {return 0}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{neg}
%     The |neg| method is also pretty easy.
%     \begin{tcl}
      neg {
         expr {(-[lindex $args 0]) % $n}
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{-}
%     As is the |-| method, since it only has one form.
%     \changes{0.1}{2010/03/25}{Dropping unary form of \texttt{-}, 
%        and thus \texttt{ring} 1.0 support. (LH)}
%     \begin{tcl}
      - {
         expr {([lindex $args 0] - [lindex $args 1]) % $n}
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{*}
%     Variadic multiplication is just like addition.
%     \begin{tcl}
      * {
         set res 1
         foreach factor $args {set res [expr {($res*$factor) % $n}]}
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   That completes the set of methods required by the |ring| 
%   interface.
%   
%   \begin{procmethod}{1}
%     The |1| method has the two forms
%     \begin{displaysyntax}
%       \meta{ring} 1\par
%       \meta{ring} 1 \word{integer}
%     \end{displaysyntax}
%     where the first is the unit constant required for a |monoid|. 
%     The second form is the canonical homomorphism of 
%     unital rings from integers into this ring: the \word{integer}th 
%     multiple of the ring unit.
%     \begin{tcl}
      1 {
         if {[llength $args]} then {
            return [expr {[lindex $args 0] % $n}]
         } else {
            return 1
         }
      }
%     \end{tcl}
%      This completes support for the |monoid| interface.
%   \end{procmethod}
%   
%   \begin{procmethod}{/}
%     The |/| method needed to support |division|~(v\,1.0) is the 
%     only one whose algorithm is nontrivial.
%     \begin{tcl}
      / {
%     \end{tcl}
%     Division \texttt{/ $a$ $b$} starts with applying Euclid's 
%     algorithm to the denominator $b$ and the modulo number $n$. 
%     One starts with \(b_0 = b\) and \(c_0 = n\). Then one 
%     recursively sets
%     \begin{align*}
%       q_k :={}& \lfloor c_{k-1}/b_{k-1}\rfloor \\
%       b_k :={}& c_{k-1} - q_k b_{k-1}\\
%       c_k :={}& b_{k-1}
%     \end{align*}
%     until \(b_k=0\), at which point \(c_k = \gcd(b_0,c_0)\). This 
%     is very standard. Slighly less standard is the need to find a 
%     number $r$ such that \(r b \equiv c_k \pmod{n}\). This is done 
%     by maintaining $r_k$ and $s_k$ such that \(r_k b \equiv c_k 
%     \pmod{n}\) and \(s_k b \equiv b_k \pmod{n}\). Clearly \(r_0=0\) 
%     and \(s_0=1\) satisfy these conditions, as do
%     \begin{align*}
%       s_k :={}& r_{k-1} - q_k s_{k-1}\\
%       r_k :={}& s_{k-1}
%     \end{align*}
%     Thus the wanted $r$ is $r_k$ when \(b_k=0\).
%     \begin{tcl}
         set b [lindex $args 1]
         set c $n
         set r 0
         set s 1
         while {$b} {
            set q [expr {$c / $b}]
            set b [expr {$c - $q*[set c $b]}]
            set s [expr {$r - $q*[set r $s]}]
         }
%     \end{tcl}
%     If at this point \(c=c_k \mid a\) then \(x = ra/c = 
%     r_k a / c_k\), otherwise there was no solution.
%     \begin{tcl}
         if {[lindex $args 0] % $c == 0} then {
            return [expr {$r * [lindex $args 0] / $c % $n}]
         } else {
            return -code error -errorcode {API division nosolution}\
              "No such quotient"
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{inverse}
%     A \APIref{group}{1.0}-style |inverse| method can be implemented 
%     as a recursive call to |/|.
%     \begin{tcl}
      inverse {
         modulo $n $API / 1 [lindex $args 0]
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{integer.}
%     Another way of importing integers is to form integer 
%     multiples of existing elements.
%     \begin{tcl}
      integer. {
         expr {([lindex $args 0] * [lindex $args 1]) % $n}
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{iszero}
%     The final method needed for v\,2.2 of \APIref{additive 
%     group}{2.2} is the unary test for being zero.
%     \begin{tcl}
      iszero { expr {[lindex $args 0] % $n == 0} }
%     \end{tcl}
%   \end{procmethod}
%   
%   Another useful interface to support would be some sort of 
%   ``generated additive group'', since that provides a syntactically 
%   pure way of extracting the integer representing a group element. 
%   It is however at the moment not quite clear what that interface 
%   should specify---the main question is whether the generators should 
%   be |named| or elements of a subordinate structure---so the 
%   existing code for this is by default not included.
%   
%   \begin{procmethod}{+ decomposition}
%     Since the additive group $\mathbb{Z}_n$ is cyclic, it can 
%     always be expressed as a multiple of one generator. The easiest 
%     generator is $1$.
%     \begin{tcl}
%<*groupDecomposition>
      "+ decomposition" {
         return [list 1 [expr {[lindex $args 0] % $n}]]
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{named}
%     To satisfy |named element| interface, it is necessary to 
%     provide translation of |1| (the name) to |1| (the element).
%     \begin{tcl}
      named {
         switch -- [lindex $args 0] "1" {
            return 1
         } default {
            return -code error "\"[lindex $args 0]\" is not an\
              element name"
         }
      }
%</groupDecomposition>
%     \end{tcl}
%   \end{procmethod}
%   
%   An alternative approach, which should definitely be considered, 
%   is to view $\mathbb{Z}_n$ as a $\mathbb{Z}$-module spanned by 
%   $\{1\}$.
%   
%   \begin{procmethod}{canonise}
%     The operations always return canonical representations, but 
%     adapters sometimes find it useful to have an explicit 
%     canonisation method.
%     \begin{tcl}
      canonise { expr {[lindex $args 0] % $n} }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{export}
%     This method implements the \APIref+{export}{2.0} interface, 
%     so the call syntax is
%     \begin{displaysyntax}
%       \meta{ring} export \word{element} \word{attributes}
%     \end{displaysyntax}
%     The export format is as an integer $k$ with \(2\lvert k\rvert 
%     \leqslant n\), since this is usually more appropriate for 
%     presentations.
%     
%     \changes{0.1}{2009/11/30}{Added \texttt{export} method. (LH)}
%     \begin{tcl}
      export {
        set elem [expr {[lindex $args 0] % $n}]
        list integer [dict replace [lindex $args 1] value [
           expr {2*$elem > $n ? $elem-$n : $elem}
        ]] {}
        
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{import}
%     The \APIref{import}{1.0} interface can be implemented by 
%     canonising the result of the general integer importer.
%     \begin{tcl}
      import {
         expr { [import {*}$args] % $n }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{API}
%     Finally, there is the |API| method, which takes all its data 
%     from the \word{API} parameter.
%     \begin{tcl}
      API {::API::static $API {*}$args}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
      default {
         return -code error "Unknown method \"$method\";\
           must be =, +, neg, -, *, /, 0, 1, API, canonise,\
           export, import, integer., or inverse"
      }
   }
}
%   \end{tcl}
% \end{proc}
% 
% \begin{proc}{make_modulo}
%   This constructor takes the characteristic $n$ as only argument 
%   and verifies that it is valid. It also tries to check whether $n$ 
%   is a prime, and if so declares the structure to additionally be a 
%   \APIref{field}{1.0}.
%   \begin{tcl}
proc mtmtcl::rings::integers::make_modulo {n} {
   if {$n != round($n) || $n < 2} then {
      return -code error "The characteristic must be at least 2"
   }
   set API {
       equality 1.0
       canonise 1.1
       autocanonical 1.0
       magma 1.1
       semigroup 1.1
       monoid 1.1
       "commutative *" 1.0
       "additive group" 2.2
       ring 2.0
       division 1.0
%<*groupDecomposition>
       "generated additive group" 2.0
       "named element" 1.0
%</groupDecomposition>
       export 2.0
       import 1.0
   }
   catch {
      if {[::math::numtheory::isprime $n]} then {
         dict set API field 1.0
      }
   }
   return [list [namespace which modulo] $n $API]
}
%</integers>
%   \end{tcl}
% \end{proc}
% 
% 
% \setnamespace{mtmtcl::rings}
% 
% \subsection{``Real'' numbers}
% 
%   \begin{tcl}
%<docstrip.tcl::catalogue>pkgProvide mtmtcl::rings::float 1.0 float
%<*float>
package require Tcl 8.5
package require mtmtcl::openmath 1.1
package require API 1.0
% \end{tcl}
% 
% 
% \begin{ensemble}{float}
%   \setnamespace{mtmtcl::rings}
%   Like integers, a structure for floating-point numbers can be 
%   implemented directly as an ensemble. The format of a |float| 
%   element is that of \Tcl's native |double| numbers.
%   \begin{tcl}
namespace eval ::tcl::mathop {
   namespace ensemble create -subcommands {
      API 
      = 
      + neg - 0 iszero integer.
      * 
      1 inverse ^
      canonise
      /
      export import
   } -map {
      API {
         ::API::static {
            equality 1.1
            "additive group" {2.2 1.2}
            ring {2.0 1.0}
            "commutative *" 1.0
            magma 1.1 semigroup 1.2  monoid 1.2  group 1.2
%   \end{tcl}
%   Unlike the case with |integer|, it is reasonable for |float| to 
%   claim it is a \APIref{group}{1.2}, even though it doesn't quite 
%   fit the description when $0$ is involved. Supporting |group| is 
%   however no reason not to also support \APIref{division}{1.0}.
%   \begin{tcl}
            division 1.0 field 1.0
            canonise 1.1
            export 2.0
            import 1.0
         }
      }
      =   ==
      0   {::return -level 0 0.0}
      neg -
      iszero {== 0}
      integer. *
      1   {::return -level 0 1.0}
      inverse /
      ^   **
      canonise +
      export ::mtmtcl::rings::float_export
      import {::mtmtcl::openmath::float_value 1}
   } -command ::mtmtcl::rings::float
}
%   \end{tcl}
%   The issue of \emph{which} |double| values are legal as elements 
%   of this ring is one that gets surprisingly technical. One might 
%   expect that $1/0$ (technically |[float / 1.0 0.0]|) should not be 
%   defined, and thus require a custom proc to convert \Tcl's native 
%   |ARITH DIVZERO| error to an |API division| error, but 
%   |[::tcl::mathfunc::/ 1.0 0.0]| returns |Inf|, so by including 
%   this (and |-Inf|) in the ``ring'' the issue solves itself. It is 
%   not possible to e.g.~add the two infinities together (an 
%   |ARITH DOMAIN| error will be thrown), but that feels reasonable.
%   
%   Similarly including |NaN| might seem like a good idea, but since 
%   not even |::tcl::mathfunc::double| will take that as input without 
%   throwing an error it seems more practical to leave it out.
%   
%   What turns out to be a thorny issue is however that of what to do 
%   with |-0.0|: this is in IEEE floating-point arithmetic a value 
%   which is distinct from the ordinary zero |0.0| in having inverse 
%   |-Inf| rather than |Inf|. Since |::tcl::mathfunc::==| sees the 
%   two zeroes as equal, one could argue that |-0.0| is merely a 
%   noncanonical representation for |0.0|, and in order to satisfy 
%   \APIref{canonise}{1.1} it becomes necessary to choose a 
%   |canonise| implementation which transform one into the other; the 
%   |+| command happens to fulfill this request. The only operation 
%   which can tell |0.0| and |-0.0| apart is |/|, and since this is 
%   not required to be congruent, we actually manage to get by 
%   without violating that part of any interface! (As is well known, 
%   floating-point arithmetic violates most axioms of a ring in one 
%   way or another, but these violations are generally overlooked as 
%   they are usually small.) An alternative could be to treat |0.0| 
%   and |-0.0| as distinct values, with |tcl::mathfunc::double| as 
%   |canonise|, but that would only satisfy version~1.0 of 
%   \APIref{canonise}{1.0}.
%   
%   
%   \begin{proc}{float_export}
%     This procedure implements the \APIref+{export}{2.0} interface 
%     for |float|s. The call syntax is
%     \begin{displaysyntax}
%       |::mtmtcl::rings::float_export| \word{element} 
%       \word{attributes}
%     \end{displaysyntax}
%     The default implementation is to use \Tcl's string 
%     representation of the canonical value as 
%     \describestring+[attribute]{dec} attribute, since that is much 
%     better than the default for e.g.~|format %g|, but just in case 
%     the syntax doesn't wholly match that of OpenMath, I've also 
%     included the \Module{hexfloat} variant which encodes the exact 
%     IEEE value in the \describestring+[attribute]{hex} attribute
%     \begin{tcl}
proc ::mtmtcl::rings::float_export {elem attr} {
%<*hexfloat>
   binary scan [binary format Q $elem] H* hex
   list OMF [dict create hex $hex] {}
%</hexfloat>
%<!hexfloat>   list OMF [dict create dec [expr {double($elem)}]] {}
}
%</float>
%     \end{tcl}
%   \end{proc}
% \end{ensemble}
% 
% 
% \subsection{Fractions}
% 
% Another important field is the field $\mathbb{Q}$ of rational 
% numbers. The preferable presentation of these is as quotients of 
% two integers, which calls for a corresponding interface.
% 
% \begin{APIspec}{fraction}{1.0}
%   The |fraction| interface provides for decomposing elements into 
%   numerator and denominator, and for constructing elements from a 
%   numberator and a denominator.
%   
%   \begin{APIdescription}{set of fractions}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{fracdomain}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%       The |fracdomain| method accesses the underlying structure 
%       that numerators and denominators belong to.
%       
%     \begin{APImethod}{frac}
%       \word{numerator} \word{denominator}
%     \end{APImethod}
%       This method constructs a fraction element from a 
%       \word{numerator} and \word{denominator} from the 
%       |fracdomain|, or throws an error if that combination of 
%       \word{numerator} and \word{denominator} is invalid or 
%       unsupported.
%       
%     \begin{APImethod}{numer}
%       \word{fraction}
%     \end{APImethod}
%     \begin{APImethod}{denom}
%       \word{fraction}
%     \end{APImethod}
%       These two methods extract the numerator and denominator 
%       respectively of a \word{fraction}.
%       
%       For any \meta{set of fractions} $F$ and element $x$ of $F$, 
%       it holds that
%       \begin{displaysyntax}
%         [$F$ frac [$F$ numer $x$] [$F$ denom $x$]]\par
%         $x$
%       \end{displaysyntax}
%       are |=|-equal.
%       
%       \begin{remark}
%         The converse does not hold; you cannot expect to always 
%         get back the same |numer|ator from a |frac|tion as you used 
%         to construct it.
%       \end{remark}
%   \end{APIdescription}
% \end{APIspec}
% 
% Note that the \APIref{fraction}{1.0} interface abstains from 
% axiomatising many of the properties that would be true for a field 
% of fractions constructed from an integral domain: equality in the 
% set of fractions is not related to arithmetic operations in the 
% |fracdomain|, indeed, neither the set of fractions nor the 
% |fracdomain| is required to possess any arithmetic operations 
% whatsoever. 
% 
% Having specified how to build and decompose fractions, an immediate 
% application is to build rational numbers. |Q| (for $\mathbb{Q}$) is 
% used as the part of the package and namespace name that says 
% `rational', since this looks right in the code.
% \begin{tcl}
%<*docstrip.tcl::catalogue>
pkgProvide mtmtcl::rings::Q 1.0 rationals
%</docstrip.tcl::catalogue>
%<*rationals>
package require Tcl 8.5
package require mtmtcl::rings::integers 1.0
package require mtmtcl::openmath 1.1
package require API 1.0
% \end{tcl}
% 
% \begin{ensemble}{Q}
%   A rational number $a/b$ is encoded as a pair `$a$ $b$', where \(b 
%   \neq 0\).
%   
%   \begin{tcl}
namespace eval ::mtmtcl::rings::Q {
%   \end{tcl}
%   
%   \begin{procmethod}{0}
%     Zero is $0/1$.
%     \begin{tcl}
   proc 0 {} {return {0 1}}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{iszero}
%     Something is zero when the numerator is $0$.
%     \begin{tcl}
   proc iszero {frac} {expr {[lindex $frac 0] == 0}}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{=}
%     More generally, \(a/b = c/d\) when \(ad = bc\).
%     \begin{tcl}
   proc = {ab cd} {
      expr {[lindex $ab 0]*[lindex $cd 1] ==\
        [lindex $ab 1]*[lindex $cd 0]}
   }
%     \end{tcl}
%     There seems little point in complicating that with checks for 
%     the denominator being $0$, as that constitutes errors in the 
%     operands. (The results in those cases are that any $a/0$ and 
%     $c/0$ are considered equal, and $0/0$ is equal to everything.)
%   \end{procmethod}
%   
%   \begin{procmethod}{canonise}
%     The canonical form of a fraction $a/b$ is $a'/b'$ such that 
%     \(\gcd(a',b') = 1\), \(b' > 0\), and of course \(a'/b' = a/b\). 
%     To that end, $d$ is first made a greatest common divisor of $a$ 
%     and $b$; we allow $d$ to be negative here, but will switch sign 
%     later if necessary. The algorithm used is that of Euclid, and 
%     overall the complexity should be quadratic; the built-in modulo 
%     operation may itself be quadratic in general, but in the small 
%     quotient regime where Euclid's algorithm primarily ends up 
%     using it, the built-in modulo operation is actually linear.
%     \begin{tcl}
   proc canonise {frac} {
      lassign $frac d r
      while {$r != 0} {
         set r [expr {$d % [set d $r]}]
      }
      set r [expr {[lindex $frac 1] / $d}]
      if {$r < 0} then {
         set r [::tcl::mathop::- $r]
         set d [::tcl::mathop::- $d]
      }
      return [list [expr {[lindex $frac 0] / $d}] $r]
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{+}
%     Addition is implemented as a zero-or-more terms operation, i.e.,
%     \begin{displaysyntax}
%       ::mtmtcl::rings::Q + \word{term}\regstar
%     \end{displaysyntax}
%     It is implemented in the naive way, using the formula
%     \[
%       \frac{n_1}{d_1} + \frac{n_2}{d_2} = 
%       \frac{n_1 d_2 + n_2 d_1}{d_1 d_2}
%     \]
%     followed by |canonise|ing to cancel factors common to numerator 
%     and denominator.
%     \begin{tcl}
   proc + {args} {
      set sum {0 1}
      foreach term $args {
         lassign $sum n1 d1
         lassign $term n2 d2
         set sum [list [expr {$n1*d2 + $n2*$d1}] [expr {$d1*d2}]]
      }
      canonise $sum
   }
%     \end{tcl}
%     Though simple, this may seem like an inefficient implementation 
%     since it uses the trivial common denominator $d_1 d_2$ rather 
%     than the least common multiple, therefore sometimes working 
%     with larger intermediate results than necessary. However the 
%     cost of computing the least common multiple would not really be 
%     offset by gains in other parts of the calculation.
%     
%     Realistically the dominant part of the calculation of a 
%     two-term sum is going to be the $\gcd$ calculation. Suppose 
%     that has complexity $\sim c n^2$ for operands up to $n$ bits 
%     large. Now consider adding two fractions where the numerators 
%     and denominators are up to $n$ bits in size. Without computing 
%     the least common multiple, the final $\gcd$ calculation will 
%     operate on integers of up to $2n$ bits, and so have complexity 
%     $\sim 4cn^2$. The $\gcd$ calculation for the initial least 
%     common multiple would 
%     have complexity $\sim cn^2$, and may avoid a factor of size 
%     $k$~(say) bits in the intermediate results, reducing the 
%     complexity of the final $\gcd$ to \(\sim c (2n -\nobreak k)^2 = 
%     4cn^2 - 4ckn + ck^2\). The net effect is a loss for all \(k < 
%     \frac{1}{4} n\)! Moreover the worst-case complexity of $\sim 
%     cn^2$ for Euclid's algorithm occurs precisely when the 
%     arguments are coprime; if the $\gcd$ turns out to be $k$ bits 
%     large then the bound on the number of iterations drops by some 
%     $O(k)$. This has not even begun to consider averaging over 
%     different numbers of equal bitsize; in that significant fraction 
%     of cases where the integers involved are coprime, a $\gcd$ 
%     calculation will achieve nothing, but still carry the full cost 
%     penalty.
%     
%     It simply doesn't seem worth it.
%   \end{procmethod}
%   
%   \begin{procmethod}{neg}
%     Negation is done by negating the numerator, so that canonical 
%     input produces canonical output.
%     \begin{tcl}
   proc neg {ab} {
      list [::tcl::mathop::- [lindex $ab 0]] [lindex $ab 1]
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{-}
%     Subtraction is just addition with a sign flip, specialised for 
%     the case of two operands.
%     \begin{tcl}
   proc - {t1 t2} {
      lassign $t1 n1 d1
      lassign $t2 n2 d2
      canonise [list [expr {$n1*d2 - $n2*$d1}] [expr {$d1*d2}]]
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{*}
%     Multiplication is just to multiply all numerators together and 
%     multiply all denominators together, followed by |canonise|. It 
%     is straightforward to do as a zero-or-more operands operation.
%     \begin{tcl}
   proc * {args} {
      set n 1
      set d 1
      foreach f $args {
         set n [expr {$n * [lindex $f 0]}]
         set d [expr {$d * [lindex $f 1]}]
      }
      canonise [list $n $d]
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{1}
%     The unit operation |1| also has a one-argument form for 
%     `integer multiple of unit'.
%     \begin{tcl}
   proc 1 {{multiple 1}} {list $multiple 1}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{inverse}
%     Inversion is just to check that the number isn't zero, and swap 
%     numerator with denominator.
%     \begin{tcl}
   proc inverse {ab} {
      if {[lindex $ab 0] != 0} then {
         return [lreverse $ab]
      } else {
         return -code error -errorcode {API division nosolution}\
           "0 is not invertible"
      }
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{/}
%     Division is like multiplication, with the second operand 
%     swapped, after one checks for division-by-zero. But for strict 
%     adherence to the |division| API, one must use a slightly 
%     different |-errorcode| for dividing $0$ by $0$; since this 
%     happens in an error case, there is no speed penalty for that.
%     \begin{tcl}
   proc / {ab cd} {
      if {[lindex $cd 0] == 0} then {
         return -code error -errorcode [
            list API division [lindex {nosolution unimplemented}\
              [expr {[lindex $ab 0] == 0}]]
         ] "divide by zero"
      }
      canonise [list [expr {[lindex $ab 0]*[lindex $cd 1]}]\
        [expr {[lindex $ab 1]*[lindex $cd 0]}]]
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{numer}
%   \begin{procmethod}{denom}
%     Decomposing a fraction is just picking out the right part.
%     \begin{tcl}
   proc numer {ab} {lindex $ab 0}
   proc denom {ab} {lindex $ab 1}
%     \end{tcl}
%   \end{procmethod}\end{procmethod}
%   
%   \begin{proc}{frac}
%     The denominator is checked for being zero when a fraction is 
%     constructed, and the whole is canonised.
%     \begin{tcl}
   proc frac {numer denom} {
      if {$denom == 0} then {
         return -code error -errorcode {API fraction bad-denom}\
           "zero denominator"
      } else {
         canonise [list $numer $denom]
      }
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{procmethod}{export}
%     The normal OpenMath (or at least MathML) way to encode a 
%     rational number is to use the \OMSref{nums1}{rational} symbol.
%     \begin{tcl}
   proc export {ab attr} {
      set res [
         ::mtmtcl::openmath::OM AS nums1 rational [
            ::mtmtcl::openmath::OM I [lindex $ab 0]
         ] [
            ::mtmtcl::openmath::OM I [lindex $ab 1]
         ]
      ]
      lset res 1 $attr
      return $res
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{import}
%     Thus the converse |import| operation should at least support 
%     objects in terms of \OMSref{nums1}{rational}, but it is quite 
%     reasonable to also allow \OMSref{arith1}{divide} since that 
%     ends up being effectively the same thing, and we may even 
%     throw in \OMSref{opnode}{divide} for the same reason (even 
%     though it is highly unlikely to become relevant, it costs 
%     almost nothing).
%     
%     The tricky matter is what else to allow. Integers don't require 
%     implementing anything new, and should be expected in input, so 
%     we'd better support that! One could (for convenience) also 
%     support floating-point numbers, but there one encounters the 
%     problem of whether to consider them as the dyadic numbers they 
%     technically are, or the (often decimal) fractions the user 
%     might expect, so it's probably easier to just not go there.
%     
%     \begin{tcl}
   proc import {path tree} {
      ::mtmtcl::openmath::OMAS_switch $tree {
         return [
            list [::mtmtcl::openmath::integer_value $path $tree] 1
         ]
      } http://www.openmath.org/cd/nums1#rational -\
        http://www.openmath.org/cd/arith1#divide -\
        http://www.openmath.org/cd/opnode#divide {
         if {[llength [lindex $tree 2]] != 3} then {
            return -code error -errorcode [
               list API import EDOM $path $tree
            ] "wrong # operands for nums1#rational"
         }
         set numer [::mtmtcl::openmath::integer_value $path\
           [lindex $tree 2 1]]
         set denom [::mtmtcl::openmath::integer_value $path\
           [lindex $tree 2 2]]
         return [canonise [list $numer $denom]]
      } default {
         return -code error -errorcode [
            list API import EDOM $path $tree
         ] "I don't know how this OMA produces a rational number"
      }
   }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
   namespace ensemble create -prefix no -commands {
      0 iszero = + neg - * 1 inverse /
      canonise
      numer denom frac fracdomain
      export import
   } -map [dict create\
      fracdomain [::mtmtcl::rings::integers::make]\
      API {::API::static {
            equality 1.0
            canonise 1.1
            export 2.0
            import 1.0
            fraction 1.0
%   \end{tcl}
%   This structure does \emph{not} support major version~1 of 
%   \APIref{additive group}{1.0}, because |-| does not have a unary 
%   form.
%   \begin{tcl}
            "additive group" 2.2
            ring 2.0
            magma 1.1 semigroup 1.2  monoid 1.2  group 1.2
            "commutative *" 1.0
            division 1.0  field 1.0
      }}
   ]
%   \end{tcl}
%   
% \end{ensemble}
% 
% \begin{tcl}
}
%</rationals>
% \end{tcl}
% 
% 
% 
% 
% 
% \section{Modules}
% 
% \begin{APIspec}{ring-module}{2.1}
%   The |ring-module| interface is for left modules over a ring 
%   (modules over e.g.~groups are not unheard of).
%   
%   \begin{remark}
%     The reason this interface has version number 2.1 (rather than 
%     2.0) is an expectation that concepts obtained by dropping some 
%     of the axioms might prove useful on their own.
%   \end{remark}
%   
%   \begin{APIdescription}{module}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{neg}
%       \word{element}
%     \end{APImethod}
%       The |+|, |0|, and |neg| methods are as required by the 
%       \APIref{additive group}{2.0} interface version 2.0. In 
%       addition the |+| method must be commutative, i.e., for any 
%       two elements $a$ and $b$ of a \meta{ring} $R$, the two 
%       expressions
%       \begin{displaysyntax}
%         [$R$ + $a$ $b$]\par
%         [$R$ + $b$ $a$]
%       \end{displaysyntax}
%       are |=|-equal.
%     
%     \begin{APImethod}{scalar}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%       The |scalar| method accesses a structure which is both a 
%       |ring|~v\,2.0 and a |monoid|~v\,1.0.
%       
%     \begin{APImethod}{.}
%       \word{scalar} \word{element}
%     \end{APImethod}
%       The |.| method is multiplication (on the left) by a scalar, 
%       i.e.,  the \word{scalar} is an element of the 
%       \meta{module}| scalar| ring and the \word{element} is an 
%       element of the \meta{module}, whereas the result is an 
%       element of the \meta{module}.
%       
%       For every element $a$ of a \meta{module} $M$, the expression
%       \begin{displaysyntax}
%         [$M$ . [$M$ scalar 1] $a$]
%       \end{displaysyntax}
%       is |=|-equal to $a$. Furthermore for all elements $a$ 
%       and $b$ of $M$ and element $r$ of $M$| scalar|, the two 
%       expressions
%       \begin{displaysyntax}
%         [$M$ . $r$ [$M$ + $a$ $b$]]\par
%         [$M$ + [$M$ . $r$ $a$] [$M$ . $r$ $b$]]
%       \end{displaysyntax}
%       are |=|-equal. Finally for every element $a$ of $M$ and 
%       all elements $r$ and $s$ of $M$| scalar|, the two 
%       expressions
%       \begin{displaysyntax}
%         [$M$ . [$M$ scalar + $r$ $s$] $a$]\par
%         [$M$ + [$M$ . $r$ $a$] [$M$ . $s$ $a$]]
%       \end{displaysyntax}
%       are |=|-equal, as are the two expressions
%       \begin{displaysyntax}
%         [$M$ . [$M$ scalar * $r$ $s$] $a$]\par
%         [$M$ . $r$ [$M$ . $s$ $a$]]
%       \end{displaysyntax}
%   \end{APIdescription}
%   All methods are congruent.
% \end{APIspec}
% 
% 
% \begin{APIspec}{free ring-module}{2.1}
%   A free module over a ring is a module which has a basis. 
%   Version~2.1 of this interface satisfies version~2.1 of the 
%   |ring-module| interface.
%   
%   \begin{APIdescription}{module}
%     \begin{APImethod}{basis}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%       The |basis| method accesses a principal structure which 
%       constitutes the set of (indices of) basis elements. This 
%       structure must satisfy v\,1.0 of the |equality| interface. 
%       \word{index}es below are elements of this structure, and 
%       need not be equal to their counterparts in the module (nor 
%       need they be integers).
%       
%     \begin{APImethod}{basiselement}
%       \word{index}
%     \end{APImethod}
%       Returns the \meta{module} basis element whose index is 
%       \word{index}. Every element of the \meta{module} must be 
%       possible to express in exactly one way as a linear 
%       combination of values of this method.
%       
%     \begin{APImethod}{coeff}
%       \word{index} \word{element}
%     \end{APImethod}
%       Returns the coefficient (an element of 
%       \meta{module}| scalar|) of the \word{index}th basis element 
%       for the \word{element}, i.e., if $M$ is the \meta{module}, then
%       \begin{displaysyntax}
%         $a \mapsto {}$[$M$ coeff $i$ $a$]
%       \end{displaysyntax}
%       is the $R$-module homomorphism for which
%       \begin{displaysyntax}
%         [$M$ coeff $i$ [$M$ basiselement $j$]]
%       \end{displaysyntax}
%       is |=|-equal to |[|$M$| scalar 1]| if $i$ is |basis =|-equal 
%       to $j$, and |=|-equal to |[|$M$| scalar 0]| otherwise.
%       
%     \begin{APImethod}{support}
%       \word{element}
%     \end{APImethod}
%       This method returns the \emph{support} of the \word{element}, 
%       i.e., a list of those basis indices $i$ such that
%       \begin{displaysyntax}
%         [$M$ coeff $i$ \word{element}]
%       \end{displaysyntax}
%       is nonzero.
%   \end{APIdescription}
%   The |basiselement| and |coeff| methods above are congruent.
%   
%   An identity linking the methods defined above is that $a$ is 
%   |=|-equal to 
%   \begin{displaysyntax}
%     $\displaystyle\sum_{i \in \text{[$M$ support $a$]}}$
%     [$M$ . [$M$ coeff $i$ $a$] [$M$ basiselement $i$]]
%   \end{displaysyntax}
%   for every element $a$ of the \meta{module}~$M$. 
%   That there exist methods satisfying this 
%   identity is not itself a sufficient condition for the 
%   \meta{module} to be free (it is in fact a necessary and 
%   sufficient condition for the \meta{module} to be 
%   \emph{projective}, which is slightly weaker), but combining it  
%   with the conditions on |coeff| above produces a sufficient 
%   condition for freeness.
% \end{APIspec}
% 
% 
% \begin{tcl}
%<*docstrip.tcl::catalogue>
pkgProvide mtmtcl::rings::free_rank_n_module 1.0 basicmodule
%</docstrip.tcl::catalogue>
% \end{tcl}
% 
% \begin{proc}{free_rank_n_module}
%   This procedure implements $R^n$ (the free $R$-module of rank $n$) 
%   for a given associative ring with unit $R$ and natural number 
%   $n$. The call syntax is
%   \begin{displaysyntax}
%     |::mtmtcl::rings::free_rank_n_module| \word{$R$} \word{$n$} 
%     \word{method} \word{argument}\regstar
%   \end{displaysyntax}
%   The element representation is as a length $n$ list of elements of 
%   $R$. Most methods are simply pointwise operations on these lists.
%   
%   \begin{tcl}
%<*basicmodule>
package require API 1.0
package require mtmtcl::sets::finite_ordinal 1.0
namespace eval ::mtmtcl::rings {}
proc ::mtmtcl::rings::free_rank_n_module {R n method args} {
   switch -- $method {
%   \end{tcl}
%   
%   \begin{procmethod}{.}
%     Multiplication by scalar is in many ways the characteristic 
%     operation for a module.
%     \begin{tcl}
      . {
         set res [list]
         set r [lindex $args 0]
         foreach a [lindex $args 1] {lappend res [{*}$R * $r $a]}
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{=}
%     Equality is made variadic from the start, since the extra loop 
%     needed for this is a minor overhead.
%     \begin{tcl}
      = {
         if {[llength $args]<2} then {return 1}
         set leftL [lindex $args 0]
         foreach rightL [lrange $args 1 end] {
            foreach l $leftL r $rightL {
               if {![{*}$R = $l $r]} then {return 0}
            }
         }
         return 1
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{iszero}
%     Testing for being zero is not as important in a module as it is 
%     in a ring, but it is needed to support 
%     \APIref+{additive group}{1.1}.
%     \begin{tcl}
      iszero {
         if {[{*}$R API "additive group" 1.1]} then {
            foreach a [lindex $args 0] {
               if {![{*}$R iszero $a]} then {return 0}
            }
         } else {
            set zero [{*}$R 0]
            foreach a [lindex $args 0] {
               if {![{*}$R = $zero $a]} then {return 0}
            }
         }
         return 1
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{+}
%     Variadic addition is similar, although this simple 
%     implementation could be considered wasteful if ring addition is 
%     expensive.
%     \begin{tcl}
      + {
         set res [lrepeat $n [{*}$R 0]]
         foreach term $args {
            set res2 [list]
            foreach l $res r $term {
               lappend res2 [{*}$R + $l $r]
            }
            set res $res2
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{0}
%     The implementation of |0| is implicit in the above.
%     \begin{tcl}
      0 {return [lrepeat $n [{*}$R 0]]}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{-}
%     Subtraction is straightforward.
%     \begin{tcl}
      - {
         set res [list]
         foreach t [lindex $args 0] u [lindex $args 1] {
            lappend res [{*}$R + $t [{*}$R neg $u]]
         }
%     \end{tcl}
%     It might be faster to use binary subtraction in the ring 
%     instead, but checking whether that is available isn't free 
%     either.
%     \begin{tcl}
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{neg}
%     Negation is even easier.
%     \begin{tcl}
      neg {
         set res [list]
         foreach t [lindex $args 0] {
            lappend res [{*}$R neg $t]
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{scalar}
%     The only nontrivial thing about the |scalar| method is that the 
%     call needs to be |uplevel|ed, in case the structure has some 
%     method that does an |upvar| or similar.
%     \begin{tcl}
      scalar {uplevel 1 $R $args}
%     \end{tcl}
%   \end{procmethod}
%   
%   This completes the support for the |ring-module| v\,2.1 
%   interface. The next part is to support \tclverb*|free ring-module|.
%   
%   \begin{procmethod}{basis}
%     The index set for the basis is taken to be $\{0,\dotsc,n 
%     -\nobreak 1\}$.
%     \begin{tcl}
      basis {::mtmtcl::sets::finite_ordinal $n {*}$args}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{basiselement}
%     The built-in basis is the standard basis where the $i$th basis 
%     element has the $i$th coordinate equal to $1$ and all others 
%     equal to $0$.
%     \begin{tcl}
      basiselement {
         set res [lrepeat $n [{*}$R 0]]
         lset res [lindex $args 0] [{*}$R 1]
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{support}
%     Using the standard basis makes it easy to determine the support 
%     for an element (but this could probably be done more 
%     efficiently if the ring had an |iszero| method).
%     \begin{tcl}
      support {
         set zero [{*}$R 0]
         set res [list]
         set i -1; foreach part [lindex $args 0] {incr i
            if {[{*}$R = $zero $part]} then {lappend res $i}
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{coord}
%   \begin{procmethod}{index}
%     The |coord| mathod of \tclverb*|free ring-module| and the 
%     |index| method of \tclverb*|direct product| turn out to be the 
%     same in this case.
%     \begin{tcl}
      coord - index {
         return [lindex [lindex $args 1] [lindex $args 0]]
      }
%     \end{tcl}
%     Thus endeth one interface, and beginneth yet another.
%   \end{procmethod}\end{procmethod}
%   
%   \begin{procmethod}{tuple}
%     Building a tuple is straightforward as long as one doesn't 
%     bother to enforce canonicity.
%     \begin{tcl}
      tuple {
         if {[llength $args] != $n} then {
            return -code error "Wrong \# arguments: must be $n\
              elements in tuple"
         } else {
            return $args
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{no.components}
%     The number of components in the direct product is $n$.
%     \begin{tcl}
      no.components {return $n}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{component}
%     Access to components is almost the same as |scalar|, but it has 
%     an extra argument that needs to be ignored.
%     \begin{tcl}
      component {
         uplevel 1 $R [lrange $args 1 end]
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{canonise}
%     Lacking automatic canonisation, there should at least be a 
%     manual canonisation operation.
%     \begin{tcl}
      canonise {
         set res [list]
         foreach part [lindex $args 0] {
            lappend res [{*}$R canonise $part]
         }
         return $res
      }
%     \end{tcl}
%     \textbf{ToDo:} declare support of this when available.
%   \end{procmethod}
%   
%   \begin{procmethod}{API}
%     The support for interfaces is as usual an all-or-nothing 
%     affair: everything follows if only the base structure is an 
%     associative unital ring, otherwise we promise nothing.
%     \begin{tcl}
      API {
         if {[{*}$R API ring 1.0] && [{*}$R API monoid 1.0]} then {
            ::API::static {
               equality 1.1
               ring-module 2.1
               "additive group" 2.1
               "free ring-module" 1.1
               "direct product" 1.0
            } {*}$args
         } else {
            ::API::static {} {*}$args
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
      default {
         return -code error "Unsupported method \"$method\""
      }
   }
}
%</basicmodule>
%   \end{tcl}
% \end{proc}
% 
% 
% \begin{APIspec}{ring-module}{1.1}
%   Version~1.1 of the \APIref{ring-module}{2.1} interface is the 
%   same as version~2.1, except that it supports version~1.0 of 
%   \APIref{additive group}{1.0} rather than version~2.0, and 
%   similarly the |scalar|s support version~1.0 of \APIref{ring}{1.0} 
%   rather than version~2.0, i.e., the various |neg| methods are 
%   called |-| instead.
% \end{APIspec}
% 
% \iffalse
% \begin{APIspec}{ring-module}{1.1}
%   The |ring-module| interface is for left modules over a ring 
%   (modules over e.g.~groups are not unheard of).
%   
%   \begin{remark}
%     The reason this interface has version number 1.1 (rather than 
%     1.0) is that concepts obtained by dropping some of the 
%     axioms might prove useful on their own.
%   \end{remark}
%   
%   \begin{APIdescription}{module}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{-}
%       \word{element}
%     \end{APImethod}
%       The |+|, |0|, and |-| methods are as required by the 
%       \APIref{additive group}{1.0} interface version 1.0. In 
%       addition the |+| method must be commutative, i.e., for any 
%       two elements $a$ and $b$ of a \meta{ring} $R$, the two 
%       expressions
%       \begin{displaysyntax}
%         [$R$ + $a$ $b$]\par
%         [$R$ + $b$ $a$]
%       \end{displaysyntax}
%       are |=|-equal.
%     
%     \begin{APImethod}{scalar}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%       The |scalar| method accesses a structure which is both a 
%       |ring|~v\,1.0 and a |monoid|~v\,1.0.
%       
%     \begin{APImethod}{.}
%       \word{scalar} \word{element}
%     \end{APImethod}
%       The |.| method is multiplication (on the left) by a scalar, 
%       i.e.,  the \word{scalar} is an element of the 
%       \meta{module}| scalar| ring and the \word{element} is an 
%       element of the \meta{module}, whereas the result is an 
%       element of the \meta{module}.
%       
%       For every element $a$ of a \meta{module} $M$, the expression
%       \begin{displaysyntax}
%         [$M$ . [$M$ scalar 1] $a$]
%       \end{displaysyntax}
%       is |=|-equal to $a$. Furthermore for all elements $a$ 
%       and $b$ of $M$ and element $r$ of $M$| scalar|, the two 
%       expressions
%       \begin{displaysyntax}
%         [$M$ . $r$ [$M$ + $a$ $b$]]\par
%         [$M$ + [$M$ . $r$ $a$] [$M$ . $r$ $b$]]
%       \end{displaysyntax}
%       are |=|-equal. Finally for every element $a$ of $M$ and 
%       all elements $r$ and $s$ of $M$| scalar|, the two 
%       expressions
%       \begin{displaysyntax}
%         [$M$ . [$M$ scalar + $r$ $s$] $a$]\par
%         [$M$ + [$M$ . $r$ $a$] [$M$ . $s$ $a$]]
%       \end{displaysyntax}
%       are |=|-equal, as are the two expressions
%       \begin{displaysyntax}
%         [$M$ . [$M$ scalar * $r$ $s$] $a$]\par
%         [$M$ . $r$ [$M$ . $s$ $a$]]
%       \end{displaysyntax}
%   \end{APIdescription}
%   All methods are congruent.
% \end{APIspec}
% \fi
% 
% \begin{APIspec}{free ring-module}{1.1}
%   Version~1.1 of \APIref{free ring-module}{2.1} is the same as 
%   version~2.1 except that it implies version~1.1 of 
%   \APIref{ring-module}{1.1} rather than version~2.1, i.e., the 
%   |neg| method is called |-| instead.
% \end{APIspec}
% 
% \iffalse
% \begin{APIspec}{free ring-module}{1.1}
%   A free module over a ring is a module which has a basis. 
%   Version~1.1 of this interface satisfies version~1.1 of the 
%   |ring-module| interface.
%   
%   \begin{APIdescription}{module}
%     \begin{APImethod}{basis}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%       The |basis| method accesses a principal structure which 
%       constitutes the set of (indices of) basis elements. This 
%       structure must satisfy v\,1.0 of the |equality| interface. 
%       \word{index}es below are elements of this structure, and 
%       need not be equal to their counterparts in the module.
%       
%     \begin{APImethod}{basiselement}
%       \word{index}
%     \end{APImethod}
%       Returns the \meta{module} basis element whose index is 
%       \word{index}. Every element of the \meta{module} must be 
%       possible to express in exactly one way as a linear 
%       combination of values of this method.
%       
%     \begin{APImethod}{coeff}
%       \word{index} \word{element}
%     \end{APImethod}
%       Returns the coefficient (an element of 
%       \meta{module}| scalar|) of the \word{index}th basis element 
%       for the \word{element}, i.e., if $M$ is the \meta{module}, then
%       \begin{displaysyntax}
%         $a \mapsto {}$[$M$ coeff $i$ $a$]
%       \end{displaysyntax}
%       is the $R$-module homomorphism for which
%       \begin{displaysyntax}
%         [$M$ coeff $i$ [$M$ basiselement $j$]]
%       \end{displaysyntax}
%       is |=|-equal to |[|$M$| scalar 1]| if $i$ is |basis =|-equal 
%       to $j$, and |=|-equal to |[|$M$| scalar 0]| otherwise.
%       
%     \begin{APImethod}{support}
%       \word{element}
%     \end{APImethod}
%       This method returns the \emph{support} of the \word{element}, 
%       i.e., a list of those basis indices $i$ such that
%       \begin{displaysyntax}
%         [$M$ coeff $i$ \word{element}]
%       \end{displaysyntax}
%       is nonzero.
%   \end{APIdescription}
%   The |basiselement| and |coeff| methods above are congruent.
%   
%   An identity linking the methods defined above is that $a$ is 
%   |=|-equal to 
%   \begin{displaysyntax}
%     $\displaystyle\sum_{i \in \text{[$M$ support $a$]}}$
%     [$M$ . [$M$ coeff $i$ $a$] [$M$ basiselement $i$]]
%   \end{displaysyntax}
%   for every element $a$ of the \meta{module}~$M$. 
%   That there exist methods satisfying this 
%   identity is not itself a sufficient condition for the 
%   \meta{module} to be free (it is in fact a necessary and 
%   sufficient condition for the \meta{module} to be 
%   \emph{projective}, which is slightly weaker), but combining it  
%   with the conditions on |coeff| above produces a sufficient 
%   condition for freeness.
% \end{APIspec}
% \fi
% 
% 
% \begin{APIspec}{inner product space}{1.1}
%   An inner product is a biliear operation which maps a pair of 
%   ``vectors'' back to a scalar. Version~1.1 of this interface 
%   satisfies version~2.1 of the \APIref{ring-module}{2.1} interface.
%   
%   \begin{APIdescription}{module}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{neg}
%       \word{element}
%     \end{APImethod}
%     \begin{APImethod}{scalar}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%     \begin{APImethod}{.}
%       \word{scalar} \word{element}
%     \end{APImethod}
%       These methods are as required by the 
%       \APIref+{ring-module}{2.1} interface.
%       
%     \begin{APImethod}{innerprod}
%       \word{element} \word{element}
%     \end{APImethod}
%       Given two elements of the \meta{module} $M$, this method 
%       returns an element of `\texttt{$M$~scalar}'. It is congruent, 
%       i.e., if $u$ and $u'$ are \texttt{=}-equal elements of $M$, and 
%       $v$ and $v'$ likewise are \texttt{=}-equal elements of $M$, then
%       \begin{displaysyntax}
%         [$M$ innerprod $u$ $v$]\par
%         [$M$ innerprod $u'$ $v'$]
%       \end{displaysyntax}
%       are `|scalar =|'-equal.
%       
%       In addition, the \texttt{innerprod} operation is symmetric 
%       and bilinear, i.e., for any \(u,v,w \in M\) and $r$ in 
%       \texttt{$M$~scalar}, the two formulae
%       \begin{displaysyntax}
%         [$M$ innerprod $u$ $v$]\par
%         [$M$ innerprod $v$ $u$]
%       \end{displaysyntax}
%       are `|scalar =|'-equal, as are
%       \begin{displaysyntax}
%         [$M$ innerprod [$M$ + $u$ $v$] $w$]\par
%         [$M$ scalar + [$M$ innerprod $u$ $w$] [$M$ innerprod $v$ $w$]]
%       \end{displaysyntax}
%       and
%       \begin{displaysyntax}
%         [$M$ innerprod [$M$ . $r$ $v$] $w$]\par
%         [$M$ scalar * $r$ [$M$ innerprod $v$ $w$]]
%       \end{displaysyntax}
%   \end{APIdescription}
%   
%   It is not required that the inner product of some $u$ with itself 
%   is nonnegative\Ldash there is not enough structure present to 
%   make such a claim\Rdash nor that such an inner product is nonzero 
%   for nonzero $u$ (definiteness). A Loretzian metric (i.e., inner 
%   product) would fail both of these requirements, but not this 
%   interface.
%   
%   What will typically not fit this interface are complex-valued 
%   inner products, as these are sesquilinear rather than bilinear 
%   and conjugate symmetric rather than fully symmetric. 
% \end{APIspec}
% 
% 
% 
% 
% \section{Algebras}
% 
% \begin{APIspec}{ring-algebra}{2.0}
%   An algebra over a ring is a module with a bilinear multiplication 
%   operation.
%   
%   \begin{APIdescription}{algebra}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{neg}
%       \word{element}
%     \end{APImethod}
%     \begin{APImethod}{scalar}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%     \begin{APImethod}{.}
%       \word{scalar} \word{element}
%     \end{APImethod}
%       These methods satisfy the \APIref+{ring-module}{2.1} interface.
%       
%     \begin{APImethod}{*}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |*| method satisfies the \APIref+{ring}{2.0} interface. In 
%       addition, the three expressions
%       \begin{displaysyntax}
%         [$R$ * [$R$ . $r$ $a$] $b$]\par
%         [$R$ * $a$ [$R$ . $r$ $b$]]\par
%         [$R$ . $r$ [$R$ * $a$ $b$]]
%       \end{displaysyntax}
%       are |=|-equal for all elements $a$ and $b$ of the 
%       \meta{algebra} $R$ and every element $r$ of $R$| scalar|.
%   \end{APIdescription}
% \end{APIspec}
% 
% 
% \subsection{Semigroup algebras}
% 
% \begin{tcl}
%<*docstrip.tcl::catalogue>
pkgProvide mtmtcl::rings::semigroup_algebra 1.0 SemigroupAlgebra
pkgProvide mtmtcl::rings::semigroup_algebra 1.1 {SemigroupAlgebra ens}
%</docstrip.tcl::catalogue>
%<*SemigroupAlgebra>
%<+ens>package require Tcl 8.6
%<-ens>package require Tcl 8.5
% \end{tcl}
% The modern ensemblified version of a semigroup algebra structure is 
% an ensemble with parameters, and thus requires \Tcllogo\,8.6.
% \begin{tcl}
package require API 1.1
%<ens>package require mtmtcl::openmath 1.0
namespace eval ::mtmtcl::rings {}
% \end{tcl}
% 
% But first let's implement the old |semigroup_algebra| structure, 
% for compatibility.
% 
% \begin{proc}{semigroup_algebra}
%   This procedure implements a semigroup algebra structure, with 
%   given ring of coefficients. The basic call syntax is
%   \begin{displaysyntax}
%     |mtmtcl::rings::semigroup_algebra| \word{coefficient ring} 
%     \word{semigroup} \word{method} \word{argument}\regstar
%   \end{displaysyntax}
%   whereas the return value depends on the \word{method}. The 
%   \meta{coefficient ring} must support \APIref+{additive 
%   group}{2.1}, since distinguishing zero coefficients is a very 
%   common operation.
%   
%   The representation format is a dictionary where the keys are 
%   semigroup elements and the values are coefficients. Values that 
%   are zero should be dropped. The keys must be on canonical format.
%   \begin{tcl}
proc mtmtcl::rings::semigroup_algebra {R S method args} {
   switch -- $method {
%   \end{tcl}
%   
%   \begin{procmethod}{=}
%     Equality is tested by comparing entry by entry. It is forgiving 
%     for entries with an explicit zero coefficient, since the 
%     overhead of this for canonical representations is at most one 
%     ring comparison.
%     \begin{tcl}
      = {
         lassign $args lD rD
         dict for {k v} $lD {
            if {![dict exists $rD $k]} then {
               if {![{*}$R iszero $v]} then {return 0}
            } elseif {[{*}$R = $v [dict get $rD $k]]} then {
               dict unset rD $k
            } else {
               return 0
            }
         }
         dict for {k v} $rD {
            if {![{*}$R iszero $v]} then {return 0}
         }
         return 1
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{+}
%     Addition is variadic.
%     \changes{0.1}{2010/03/30}{Remove zero elements at the end, 
%       rather than checking after each coefficient addition. (LH)}
%     \begin{tcl}
      + {
         if {![llength $args]} then {return {}}
         foreach term [lassign $args sum] {
            dict for {k v} $term {
               if {[dict exists $sum $k]} then {
                  dict set sum $k [{*}$R + [dict get $sum $k] $v]
               } else {
                  dict set sum $k $v
               }
            }
         }
         foreach k [dict keys $sum] {
            if {[{*}$R iszero [dict get $sum $k]]} then {
               dict unset sum $k
            }
         }
         return $sum
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{neg}
%     Negation is easy, since one only has to switch the sign of 
%     every coefficient.
%     \begin{tcl}
      neg {
         set res [dict create]
         dict for {k v} [lindex $args 0] {
            dict set res $k [{*}$R neg $v]
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{-}
%     Subtraction is more like addition, but here it makes sense to 
%     immediately check coefficients for being zero, since the 
%     operation is strictly binary.
%     \begin{tcl}
      - {
         lassign $args res term
         dict for {k v} $term {
            if {[dict exists $res $k]} then {
               dict update res $k s {
                  set s [{*}$R - $s $v]
                  if {[{*}$R iszero $s]} then {unset s}
               }
            } else {
               dict set res $k [{*}$R neg $v]
            }
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{0}
%     The zero value is an empty dictionary.
%     \begin{tcl}
      0 {return {}}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{.}
%     Multiplication by scalar is straightforward.
%     \begin{tcl}
      . {
         lassign $args r a
         set res [dict create]
         dict for {k v} $a {
            set rv [{*}$R * $r $v]
            if {![{*}$R iszero $rv]} then {dict set res $k $rv}
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{*}
%     The algebra multiplication operation is conceptually done in 
%     the trivial way, by expanding both factors:
%     \begin{equation*}
%       \biggl( \sum_{\mu \in S_1} a_\mu \mu \biggr)
%       \biggl( \sum_{\nu \in S_2} b_\nu \nu \biggr) =
%       \sum_{\mu \in S_1} \sum_{\nu \in S_2} (a_\mu b_\nu) (\mu\nu)
%       \text{.}
%     \end{equation*}
%     Since this gives rise to one nested loop per factor, it would 
%     be somewhat awkward to make variadic.
%     \begin{tcl}
      * {
         set res [dict create]
         dict for {lk lv} [lindex $args 0] {
            dict for {rk rv} [lindex $args 1] {
               set lrv [{*}$R * $lv $rv]
               set lrk [{*}$S canonise [{*}$S * $lk $rk]]
               if {[dict exists $res $lrk]} then {
                  dict set res $lrk [{*}$R + [dict get $res $lrk] $lrv]
               } elseif {![{*}$R iszero $lrv]} then {
                  dict set res $lrk $lrv
               }
               
            }
         }
         foreach k [dict keys $res] {
            if {[{*}$R iszero [dict get $res $k]]} then {
               dict unset res $k
            }
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{1}
%     The semigroup algebra has a unit iff the semigroup is a monoid. 
%     When this unit exists, it consists of the coefficient unit 
%     times the semigroup unit.
%     \begin{tcl}
      1 {
         if {[{*}$S API monoid 1.0]} then {
            return [
               dict create [{*}$S canonise [{*}$S 1]] [{*}$R 1]
            ]
         } else {
            return -code error "This is not a unital algebra"
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{scalar}
%     The |scalar| method gives access to the coefficient ring.
%     \begin{tcl}
      scalar {uplevel 1 $R $args}
%     \end{tcl}
%     This completes support for \APIref+{ring-module}{1.1}.
%   \end{procmethod}
%   
%   \begin{procmethod}{basis}
%     On to \APIref{free ring-module}{2.1}, where the |basis| method 
%     naturally provides access to the underlying semigroup.
%     \begin{tcl}
      basis {uplevel 1 $S $args}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{support}
%     The support for an element is a native |dict| subcommand.
%     \begin{tcl}
      support {dict keys [lindex $args 0]}
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{coeff}
%     The same is almost true for getting coefficients, but zero 
%     coefficients need to be provided explicitly.
%     \begin{tcl}
      coeff {
         set k [{*}$S canonise [lindex $args 0]]
         if {[dict exists [lindex $args 1] $k]} then {
            return [dict get [lindex $args 1] $k]
         } else {
            return [{*}$R 0]
         }
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{basiselement}
%     Converting a semigroup element to the corresponding algebra 
%     element is a matter of equipping it with a unit coefficient.
%     \begin{tcl}
      basiselement {
         dict create [{*}$S canonise [lindex $args 0]] [{*}$R 1]
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{iszero}
%     The thing missing to satisfy \APIref+{additive group}{2.1} is 
%     the |iszero| method. This is made tolerant for zero 
%     coefficients.
%     \begin{tcl}
      iszero {
         dict for {k v} [lindex $args 0] {
            if {![{*}$R iszero $v]} then {return 0}
         }
         return 1
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{named}
%     The |named| method is a shorthand for applying |basiselement| 
%     to the result of the |named| method of the semigroup.
%     \begin{tcl}
      named {
         dict create [{*}$S canonise [{*}$S named [lindex $args 0]]]\
           [{*}$R 1]
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{export}
%     The part of the internal representation that this structure 
%     needs to convert for export is the formal linear combination, 
%     since that is what is represented. The sum is addition 
%     throughout, even if the coefficients are negative, since a 
%     general coefficient ring doesn't have a concept of negative; 
%     if the minuses are to be extracted, then that should probably 
%     be done at a later stage. For now the multiplication by scalar 
%     is represented by the \texttt{arith1} \texttt{times} symbol, 
%     but this isn't quite right as it isn't really an associative 
%     operation.
%     \begin{tcl}
      export {
         lassign $args elemD attr
         set battr $attr
         set cattr $attr
         set mattr [dict replace $attr  cd arith1  name times]
         set aattr [dict replace $attr  cd arith1  name plus]
         dict lappend battr mtmtcl:path basis
         dict lappend cattr mtmtcl:path scalar
         dict lappend mattr mtmtcl:path .
         dict lappend aattr mtmtcl:path +
         set mnode        [list OMS $mattr {}]
         set childL [list [list OMS $aattr {}]]
         dict for {k v} $elemD {
            lappend childL [
               list OMA $attr [list $mnode\
                 [{*}$R export $v $cattr] [{*}$S export $k $battr]]
            ]
         }
         return [list OMA $attr $childL]
      }
%     \end{tcl}
%     
%     It would probably be a good idea to present the terms in some 
%     predictable order rather than the hash table order, but again 
%     it is hard to express this generally. It might be necessary to 
%     introduce a \tclverb*|totally ordered semigroup| interface to 
%     get that sorted out (although technically it suffices with a 
%     total order).
%   \end{procmethod}
%   
%   \begin{procmethod}{/}
%     Having a division-by-monomial operation is convenient for 
%     factoring.
%     \begin{tcl}
      / {
         lassign $args numer denom
         if {[dict size $denom] != 1} then {
            return -code error -errorcode {API division unimplemented}\
              "Sorry, I only know how to divide by monomials"
         }
%     \end{tcl}
%     This relies heavily on having division in the underlying ring 
%     and semigroup, and will in particular error out if any 
%     coefficient or monomial errors out. Each term in the numerator 
%     gives rise to a separate term in the result, since only 
%     $k = {}$\texttt{[$S$ * $\mathit{sd}$ $x$]} can give rise to a 
%     result term with key $x$.
%     \begin{tcl}
         lassign [dict get $denom] sd rd
         set res {}
         dict for {k v} $numer {
            dict set res [{*}$S canonise [{*}$S / $k $sd]]\
              [{*}$R / $v $rd]
         }
         return $res
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{procmethod}{API}
%     \changes{0.1}{2010/01/28}{Formalised usability as a free 
%        module even when not over a semigroup. (LH)}
%     \begin{tcl}
      API {
%<*old>
         if {![{*}$R API ring 2.0] || ![{*}$R API monoid 1.0] ||\
           ![{*}$R API "additive group" 2.1]} then {
            return [::APIutil::API {} {*}$args]
         }
         set D {
            "additive group" 2.1
            ring-module 2.1
            "free ring-module" 2.1
            equality 1.0
         }
         if {[{*}$S API semigroup 1.0]} then {
            set D [dict merge $D {
               ring-algebra 2.0
               ring 2.0
               semigroup 1.0
            }]
            if {[{*}$S API monoid 1.0]} then {dict lappend D monoid 1.0}
         }
         if {[{*}$R API export 2.0] && [{*}$S API export 2.0]} then {
            dict lappend D export 2.0
         }
         if {[{*}$R API division 1.0] && [{*}$S API division 1.0]} then {
            dict lappend D division 1.0
         }
         return [::APIutil::API $D {*}$args]
%</old>
%<*!old&!API1>
         ::API::dynamic $args {
            scalars {{
               eval {{*}$R API ring 2.0}
               eval {{*}$R API monoid 1.0}
               eval {{*}$R API "additive group" 2.1}
            }}
            basis {{
               eval {{*}$S API semigroup 1.0}
            }}
            "additive group" {2.1 {test scalars}}
            ring-module       {2.1 {test scalars}}
            "free ring-module" {2.1 {test scalars}}
            equality          {1.0 {test scalars}}
            ring-algebra {2.0 {
               test scalars  
               test basis
            }}
            ring {2.0 {
               test scalars  
               test basis
            }}
            semigroup {2.0 {
               test scalars  
               test basis
            }}
            monoid {1.0 {
               test scalars
               eval {{*}$S API monoid 1.0}
            }}
            export {2.0 {
               eval {{*}$R API export 2.0}
               eval {{*}$S API export 2.0}
            }}
            division {1.0 {
               eval {{*}$R API division 1.0}
               eval {{*}$S API division 1.0}
            }}
         }
%</!old&!API1>
%     \end{tcl}
%     Version~1 of the API package had a slightly different syntax for 
%     |API::dynamic|, but this procedure was the only one that even 
%     made use of that command. Preserved below is the original call; 
%     the above is a minimal edit to make the old tests work, but 
%     does not take advantage of new features. Nor are the tests 
%     mathematically sharp.
%     \begin{tcl}
%<*!old&API1>
         ::API::dynamic $args {
            "additive group" {2.1 {test scalars}}
            ring-module       {2.1 {test scalars}}
            "free ring-module" {2.1 {test scalars}}
            equality          {1.0 {test scalars}}
            ring-algebra {2.0 {
               test scalars  test semigroup
            }}
            ring {2.0 {
               test scalars  test semigroup
            }}
            semigroup {2.0 {
               test scalars  test semigroup
            }}
            monoid {1.0 {
               test scalars
               eval {{*}$S API monoid 1.0}
            }}
            export {2.0 {
               eval {{*}$R API export 2.0}
               eval {{*}$S API export 2.0}
            }}
            division {1.0 {
               eval {{*}$R API division 1.0}
               eval {{*}$S API division 1.0}
            }}
         } {
            scalars {
               eval {{*}$R API ring 2.0}
               eval {{*}$R API monoid 1.0}
               eval {{*}$R API "additive group" 2.1}
            }
            semigroup {
               eval {{*}$S API semigroup 1.0}
            }
         }
%</!old&API1>
      }
%     \end{tcl}
%   \end{procmethod}
%   
%   \begin{tcl}
      default {
         return -code error "Unsupported method \"$method\""
      }
%   \end{tcl}
%   \begin{tcl}
   }
}
%</SemigroupAlgebra>
%   \end{tcl}
% \end{proc}
% 
% \begin{APIspec}{ring-algebra}{1.0}
%   Version~1.0 of \APIref{ring-algebra}{2.0} is the same as 
%   version~2.0, except that it supports version~1.1 of 
%   \APIref{ring-module}{1.1} rather than version~2.1 and version~1.0 
%   of \APIref{ring}{1.0} rather than version~2.0, i.e., the |neg| 
%   method is called |-| instead.
% \end{APIspec}
% 
% \iffalse
% \begin{APIspec}{ring-algebra}{1.0}
%   An algebra over a ring is a module with a bilinear multiplication 
%   operation.
%   
%   \begin{APIdescription}{algebra}
%     \begin{APImethod}{=}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |=| method satisfies the |equality|~v\,1.0 interface.
%       
%     \begin{APImethod}{+}
%       \word{element} \word{element}
%     \end{APImethod}
%     \begin{APImethod}{0}
%     \end{APImethod}
%     \begin{APImethod}{-}
%       \word{element}
%     \end{APImethod}
%     \begin{APImethod}{scalar}
%       \word{submethod} \word{argument}\regstar
%     \end{APImethod}
%     \begin{APImethod}{.}
%       \word{scalar} \word{element}
%     \end{APImethod}
%       These methods satisfy the |ring-module| (v\,1.1) interface.
%       
%     \begin{APImethod}{*}
%       \word{element} \word{element}
%     \end{APImethod}
%       The |*| method satisfies the |ring| (v\,1.0) interface. In 
%       addition, the three expressions
%       \begin{displaysyntax}
%         [$R$ * [$R$ scalar . $r$ $a$] $b$]\par
%         [$R$ * $a$ [$R$ scalar . $r$ $b$]]\par
%         [$R$ scalar . $r$ [$R$ * $a$ $b$]]
%       \end{displaysyntax}
%       are |=|-equal for all elements $a$ and $b$ of the 
%       \meta{algebra} $R$ and every element $r$ of $R$| scalar|.
%   \end{APIdescription}
% \end{APIspec}
% \fi
% 
% \subsubsection{Ensemblified implementation}
% 
% \setnamespace{mtmtcl::rings::semigroup_algebra}
% \begin{ensemble}{ens}
%   The main implementation ensemble takes six parameters: the 
%   scalar ring |R|, a command prefix |iszero| performing tests for 
%   equality to $0$ in |R|, the semigroup |S|, two booleans |c1| and 
%   |c2| signalling whether canonisation is required in various 
%   circumstances, and the API dictionary. This dictates the 
%   following definitions:
%   \begin{tcl}
%<*SemigroupAlgebra&ens>
namespace eval mtmtcl::rings::semigroup_algebra::ens {
   namespace ensemble create -parameters {R iszero S c1 c2 API} -map {
      API {::API::nstatic 5}
   }
}
%   \end{tcl}
%   However, we'll hold off on specifying the list of subcommands 
%   until the end.
%   
%   \begin{proc}{=}
%     Equality is tested by comparing entry by entry. It is forgiving 
%     for entries with an explicit zero coefficient, since the 
%     overhead of this for canonical representations is at most one 
%     ring comparison (if canonical arguments have you do that 
%     comparison, you will then immediately discover that the answer 
%     is no).
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::= {R iszero S c1 c2 API lD rD} {
   dict for {k v} $lD {
      if {![dict exists $rD $k]} then {
         if {![{*}$iszero $v]} then {return 0}
      } elseif {[{*}$R = $v [dict get $rD $k]]} then {
         dict unset rD $k
      } else {
         return 0
      }
   }
   dict for {k v} $rD {
      if {![{*}$iszero $v]} then {return 0}
   }
   return 1
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{+}
%     Addition can be made variadic with little effort, since the 
%     algebra elements themselves are collections of terms.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::+ {R iszero S c1 c2 API args} {
   if {![llength $args]} then {return {}}
   foreach term [lassign $args sum] {
      dict for {k v} $term {
         if {[dict exists $sum $k]} then {
            dict set sum $k [{*}$R + [dict get $sum $k] $v]
         } else {
            dict set sum $k $v
         }
      }
   }
   foreach k [dict keys $sum] {
      if {[{*}$iszero [dict get $sum $k]]} then {
         dict unset sum $k
      }
   }
   return $sum
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{neg}
%     Negation is easy, since one only has to switch the sign of 
%     every coefficient.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::neg {R iszero S c1 c2 API arg} {
   set res [dict create]
   dict for {k v} $arg {
      dict set res $k [{*}$R neg $v]
   }
   return $res
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{-}
%     Subtraction makes use of subtraction in the underlying 
%     coefficient ring. If that doesn't support \APIref+{additive 
%     group}{2.0.1}, then neither will the semigroup algebra.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::- {R iszero S c1 c2 API res term} {
   dict for {k v} $term {
      if {[dict exists $res $k]} then {
         dict update res $k s {
            set s [{*}$R - $s $v]
            if {[{*}$iszero $s]} then {unset s}
         }
      } else {
         dict set res $k [{*}$R neg $v]
      }
   }
   return $res
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{0}
%     The zero value is an empty dictionary.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::0 {R iszero S c1 c2 API} {
   return {}
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{iszero}
%     At this point, the thing missing to satisfy 
%     \APIref+{additive group}{2.1} is the |iszero| method. This is 
%     made tolerant for zero coefficients.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::iszero {R iszero S c1 c2 API a} {
   dict for {k v} $a {
      if {![{*}$iszero $v]} then {return 0}
   }
   return 1
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{.}
%     Multiplication by scalar is straightforward.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::. {R iszero S c1 c2 API r a} {
   set res [dict create]
   dict for {k v} $a {
      set rv [{*}$R * $r $v]
      if {![{*}$iszero $rv]} then {dict set res $k $rv}
   }
   return $res
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{*}
%     The algebra multiplication operation is conceptually done in 
%     the trivial way, by expanding both factors:
%     \begin{equation*}
%       \biggl( \sum_{\mu \in S_1} a_\mu \mu \biggr)
%       \biggl( \sum_{\nu \in S_2} b_\nu \nu \biggr) =
%       \sum_{\mu \in S_1} \sum_{\nu \in S_2} (a_\mu b_\nu) (\mu\nu)
%       \text{.}
%     \end{equation*}
%     Since this gives rise to one nested loop per factor, it would 
%     be somewhat awkward to make variadic.
%     
%     The definition of the |c2| boolean is that it is true when the 
%     \word{semigroup} product of two keys are to undergo 
%     canonisation. Mnemonically, this is |c2| because |*| takes two 
%     operands.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::*\
  {R iszero S c1 c2 API left right} {
   set res [dict create]
   dict for {lk lv} $left {
      dict for {rk rv} $right {
         set lrv [{*}$R * $lv $rv]
         if {$c2} then {
            set lrk [{*}$S canonise [{*}$S * $lk $rk]]
         } else {
            set lrk [{*}$S * $lk $rk]
         }
         if {[dict exists $res $lrk]} then {
            dict set res $lrk [{*}$R + [dict get $res $lrk] $lrv]
         } else {
            dict set res $lrk $lrv
         }
         
      }
   }
   foreach k [dict keys $res] {
      if {[{*}$iszero [dict get $res $k]]} then {
         dict unset res $k
      }
   }
   return $res
}
%     \end{tcl}
%     Notable here is that the implementation does all |iszero| tests 
%     at the end, rather than when adding terms together. This is 
%     because that avoids doing the test more than once for each 
%     term in the result, which typically reduces the number of ring 
%     structure calls actually made since several pairs of terms from 
%     the two operands usually contribute to the same term in the 
%     result.
%   \end{proc}
%   
%   \begin{proc}{1}
%     The semigroup algebra has a unit iff the semigroup is a monoid. 
%     When this unit exists, it consists of the coefficient unit 
%     times the semigroup unit.
%     
%     The definition of the |c1| boolean is that it is true when the 
%     \word{semigroup} unit is to undergo canonisation.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::1 {R iszero S c1 c2 API} {
   return [dict create [
      if {$c1} then {{*}$S canonise [{*}$S 1]} else {{*}$S 1}
   ] [{*}$R 1]]
}
%     \end{tcl}
%   \end{proc}
%   
%   Other operations taking a \word{semigroup} element and turning it 
%   into a dictionary key always canonise. For |coeff| and 
%   |basiselement|, this is because the only case in which it could 
%   be avoided is that the \word{semigroup} structure is 
%   \APIref{onlycanonical}{1.0}, and in that case the |canonise| 
%   method can be made very cheap. By contrast, the |*| and |1| 
%   operations can be simplified also when the \word{semigroup} is 
%   some manner of autocanonical. Technically a similar argument could 
%   be made for the |named| and |/| operations, but the number of 
%   canonisations that would be saved for these is much smaller than 
%   for |*| (with comparable input sizes), so it is not clearly worth 
%   bothering. |1| is similar to |named| in that it only does one 
%   canonisation, but |1| is called from lots of places, so it makes 
%   sense to optimise it.
%   
%   \begin{proc}{scalar}
%     The |scalar| method gives access to the coefficient ring.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::scalar {R iszero S c1 c2 API args} {
   tailcall {*}$R {*}$args
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{basis}
%     The |basis| method gives access to monomial semigroup.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::basis {R iszero S c1 c2 API args} {
   tailcall {*}$S {*}$args
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{support}
%     The support for an element is a native |dict| subcommand.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::support {R iszero S c1 c2 API a} {
   dict keys $a
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{coeff}
%     The |coeff| method is almost a |dict get|, but sometimes it 
%     needs to supply a $0$ by itself.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::coeff {R iszero S c1 c2 API k a} {
   set k [{*}$S canonise $k]
   if {[dict exists $a $k]} then {
      return [dict get $a $k]
   } else {
      return [{*}$R 0]
   }
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{basiselement}
%     Converting a semigroup element to the corresponding algebra 
%     element is a matter of equipping it with a unit coefficient, 
%     but to stay on the safe side the semigroup element must also be 
%     canonised.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::basiselement {R iszero S c1 c2 API k} {
   dict create [{*}$S canonise $k] [{*}$R 1]
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{named}
%     The |named| method is a shorthand for applying |basiselement| 
%     to the result of the |named| method of the semigroup; the 
%     algebra does not add any names of its own.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::named {R iszero S c1 c2 API k} {
   dict create [{*}$S canonise [{*}$S named $k]] [{*}$R 1]
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{/}
%     Having a division-by-monomial operation is convenient for 
%     factoring.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::/ {R iszero S c1 c2 API numer denom} {
   if {[dict size $denom] != 1} then {
      return -code error -errorcode {API division unimplemented}\
        "Sorry, I only know how to handle single term denominators"
   }
%     \end{tcl}
%     This relies heavily on having division in the underlying ring 
%     and semigroup, and will in particular error out if any 
%     coefficient or monomial errors out. Each term in the numerator 
%     gives rise to a separate term in the result, since only 
%     $k = {}$\texttt{[$S$ * $\mathit{sd}$ $x$]} can give rise to a 
%     result term with key $x$.
%     \begin{tcl}
   lassign [dict get $denom] sd rd
   set res {}
   dict for {k v} $numer {
      dict set res [{*}$S canonise [{*}$S / $k $sd]]\
        [{*}$R / $v $rd]
   }
   return $res
}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{export}
%     The part of the internal representation that this structure 
%     needs to convert for export is the formal linear combination, 
%     since that is what is represented. The sum is addition 
%     throughout, even if the coefficients are negative, since a 
%     general coefficient ring doesn't have a concept of negative; 
%     if the minuses are to be extracted, then that should probably 
%     be done at a later stage. For now the multiplication by scalar 
%     is represented by the \OMSref{arith1}{times} symbol, 
%     but this isn't quite right as it isn't really an associative 
%     operation.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::export\
  {R iszero S c1 c2 API elemD attr} {
   set battr $attr
   set cattr $attr
   set mattr [dict replace $attr  cd arith1  name times]
   set aattr [dict replace $attr  cd arith1  name plus]
   dict lappend battr mtmtcl:path basis
   dict lappend cattr mtmtcl:path scalar
   dict lappend mattr mtmtcl:path .
   dict lappend aattr mtmtcl:path +
   set mnode        [list OMS $mattr {}]
   set childL [list [list OMS $aattr {}]]
   dict for {k v} $elemD {
      lappend childL [
         list OMA $attr [list $mnode\
           [{*}$R export $v $cattr] [{*}$S export $k $battr]]
      ]
   }
   return [list OMA $attr $childL]
}
%     \end{tcl}
%     
%     It would probably be a good idea to present the terms in some 
%     predictable order rather than the dict insertion order, but again 
%     it is hard to express this generally. Canonising an element 
%     before exporting it is probably the most practical solution, 
%     but one could also consider providing a method that would 
%     reorder the terms based on some custom order of semigroup 
%     elements.
%   \end{proc}
%   
%   \begin{proc}{canonise}
%     A similar concern exists for canonisation of values, since this 
%     means the terms have to be ordered somehow. An |lsort\
%     -dictionary| of the string representations is one way to do 
%     that, which probably isn't very mathematically meaningful, but 
%     still has a chance of looking sort-of intuitive to the user.
%     \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::ens::canonise {R iszero S c1 c2 API a} {
   set res [dict create]
   foreach k [lsort -dictionary [dict keys $a]] {
      set r [{*}$R canonise [dict get $a $k]]
      if {![{*}$iszero $r]} then {dict set res $k $r}
   }
   return $res
}
%     \end{tcl}
%     One subtle detail in this procedure is that it first canonises 
%     and then checks the result for being zero; this order of things 
%     is needed for the algebra to satisfy \APIref+{canonise}{1.0} 
%     without the ring satisfying \APIref+{canonise}{1.1}, as the 
%     difference is precisely whether canonisation can change the 
%     equality class of an element (in particular from zero to 
%     nonzero)! This order of operations is probably also good 
%     performance-wise, since equality testing often begins with 
%     canonising.
%   \end{proc}
%   
%   
%   \begin{tcl}
namespace ensemble configure mtmtcl::rings::semigroup_algebra::ens\
  -commands {
   API = + neg - 0 . * 1 iszero / 
   scalar basis support coeff basiselement 
   named export canonise
}
%   \end{tcl}
%   
% \end{ensemble}
% 
% \begin{proc}{make}
%   This brings us to the matter of a |make| command for semigroup 
%   algebras, which has the call syntax
%   \begin{displaysyntax}
%     |mtmtcl::rings::semigroup_algebra::make| \word{ring} 
%     \word{semigroup}
%   \end{displaysyntax}
%   and as usual returns the command prefix for the semigroup algebra.
%   
%   The preferred \word{iszero}-prefix refers to an underlying |iszero| 
%   subcommand, but a perfectly good alternative is to compare with an 
%   explicit (and thus cached) zero value. However if there is no 
%   known way of producing such a zero value, then all 
%   ``\word{ring}'' elements are considered automatically nonzero.
%   \begin{tcl}
proc mtmtcl::rings::semigroup_algebra::make {R S} {
   if {[{*}$R API "additive group" 2.1]} then {
      set iszero [list {*}$R iszero]
   } elseif {[{*}$R API "additive group" 2.0] ||\
     [{*}$R API "additive group" 1.0]} then {
      set iszero [list {*}$R = [{*}$R 0]]
   } else {
      set iszero [list ::apply {arg {return 0}}]
   }
%   \end{tcl}
%   The |c1| and |c2| booleans need more tests to set. They are set 
%   to the noncanonical boolean false value |no| when canonisation 
%   would be needed but isn't available, and to |yes| when it is 
%   available and needed but possibly not good enough; performing 
%   operations without proper canonisation make them slightly wrong, 
%   but not so much that they are obviously useless.
%   \begin{tcl}
   if {[{*}$S API onlycanonical 1.0] || [{*}$S API autocanonical 1.0]} then {
      set c1 0
      set c2 0
   } else {
      set c1 [expr {![{*}$S API "autocanonical 1" 1.0]}]
      set c2 [expr {![{*}$S API "autocanonical *" 1.0]}]
      if {[{*}$S API autocanonical 2.0]} then {
         set c1 [expr {$c1 && ![{*}$S autocanonical 1]}]
         set c2 [expr {$c2 && ![{*}$S autocanonical *]}]
      }
   }
   if {![{*}$S API canonise 1.0]} then {
      if {$c1} then {set c1 no}
      if {$c2} then {set c2 no}
   } elseif {![{*}$S API canonise 1.1]} then {
      if {$c1} then {set c1 yes}
      if {$c2} then {set c2 yes}
   }
%   \end{tcl}
%   It looks from this as though the \APIref{autocanonical 
%   \meta{method}}{1.0} interface is a more convenient mechanism than 
%   \APIref+{autocanonical}{2.0}.
%   
%   Most work lies in computing the API, which is done using 
%   |API::recursive|. The \word{ring} and \word{semigroup} are in 
%   recursive API tests referred to by the keys |R| and |S| 
%   respectively.
%   \begin{tcl}
   set API [::API::recursive {} {
%   \end{tcl}
%   The first order of business is to consider equality and related 
%   concepts. The ensemble subcommands use semigroup elements as 
%   dictionary keys, so \emph{any dictionary key must already be on 
%   canonical form} (putting newly generated semigroup elements on that 
%   form will be a separate problem)\Dash this means equality in the 
%   algebra hinges only upon equality in ring.
%   \begin{tcl}
      equality {1.0 {API R equality 1.0}}
%   \end{tcl}
%   There are some non-obvious implications here, however. Since the 
%   |=| procedure also makes use of the |iszero| prefix in tests, and 
%   since that has the fallback implementation of just returning 
%   false when no $0$ element is known, the semigroup algebra 
%   structure ends up implicitly adjoining a $0$ element to every 
%   \word{ring} that is not an \APIref{additive group}{2.0}. (This 
%   point should be revisited if ever an additive monoid interface 
%   gets formalised.)
%   
%   Closely related is \APIref{canonise}{1.0}. Here the versions for 
%   the \word{ring} just filter down to to the algebra, but in the 
%   case of version~1.0 that is not entirely trivial, since 
%   canonisation not supporting version~1.1 is allowed to change the 
%   equality class of elements, and terms with coefficient equal to 
%   zero are dropped. Canonising before equality test ensures that 
%   canonisation is an idempotent operation.
%   \begin{tcl}
      canonise {
         1.1 {API R canonise 1.1}
         1.0 {API R canonise 1.0}
      }
%   \end{tcl}
%   
%   For the algebraic interfaces, one begins with \APIref{additive 
%   group}{2.0}, which gets inherited by the algebra from the ring 
%   essentially because a space of group-valued functions inherits a 
%   group structure. Major version~1 is never supported since |-| only 
%   has the binary form, but major version~2 is supported whenever 
%   reasonable. Variadic addition and |iszero| tests are provided 
%   even if the ring does not have them, but subtraction is hardwired 
%   to use the subtraction method of the ring. (Changing this would 
%   not be hard, but the gain of doing so is unclear.)
%   \begin{tcl}
      "additive group" {
         2.1 {API R "additive group" 2.0.1}
         2.0 {API R "additive group" 2.0}
      }
%   \end{tcl}
%   Adding support for \APIref{additive group}{2.2} versions 
%   2.2 or~2.3 would be quite feasible, but the methods aren't there 
%   right now. Adding them would probably require another prefix 
%   parameter containing the efficient implementation of integer 
%   multiple in the ring.
%   
%   Support for the \APIref{ring}{2.0} interface requires the 
%   \word{ring} to be a ring, but it also requires the 
%   \word{semigroup} to contribute a |*| operation, although merely 
%   having that operation is sufficient; it need not have any 
%   particular properties, as distributivity boils down to 
%   distibutivity for individual terms:
%   \begin{multline*}
%     q\mu * (r\nu + s\nu) = 
%     q\mu * (r+s)\nu =
%     \bigl(q * (r+s)\bigr) (\mu*\nu) = 
%     (q*r + q*s)(\mu*\nu) = \\ =
%     (q*r)(\mu*\nu) + (q*s)(\mu*\nu) =
%     q\mu * r\nu + q\mu * s\nu
%   \end{multline*}
%   for $q,r,s$ in the \word{ring} and $\mu,\nu$ in the 
%   \word{semigroup}. At first sight it might rather appear that the 
%   more subtle \APIref{ring}{2.0} interface requirement of 
%   congruence will become decisive, since \APIref+{magma}{1.0} does 
%   not promise congruence whereas \APIref+{magma}{1.1} can. However 
%   the congruence in question for the algebra |*| deals with algebra 
%   equality, which only asks whether identical keys are associated 
%   with equal coefficients; the semigroup products that are computed 
%   get identical pairs of operands, so they will produce identical 
%   results.\footnote{
%     Or do they? The assumption here is that the semigroup \texttt{*} 
%     operation is a function, whose output is determined solely by 
%     the input, but it is not inconceivable that the implementation 
%     of an algebraic operation might utilise randomness\Ldash 
%     picking a random starting point is in many algorithms the key 
%     to achieving good average complexity by avoiding degenerate 
%     cases, even if it is rare to see such algorithms for 
%     multiplication type operations\Rdash and then the exact 
%     representation picked might depend on the random component, 
%     even if the operation is mathematically deterministic. However 
%     in such cases the structure can reasonably be expected to also 
%     provide means of canonising values, so to the extent that this 
%     congruence is a lie, it it is a lie-to-children.
%   } Therefore congruence in the \word{semigroup} is not a 
%   requirement for the algebra to be a ring.
%   \begin{tcl}
      ring  {2.0 {
         API R ring 2.0
         API S magma 1.0
      }}
      magma {1.1 {self ring 2.0}}
%   \end{tcl}
%   
%   What are then the requirements for the algebra to be a 
%   \APIref{semigroup}{1.0} or \APIref{monoid}{1.0}? At the very 
%   least that the \word{ring} and \word{semigroup} both have these 
%   properties, as algebra multiplication of single term operands 
%   perform one multiplication in each. The \word{ring} also needs to 
%   be a \APIref{ring}{2.0} (well, semiring might suffice), since 
%   reordering terms can result in coefficients being computed in 
%   different ways. Finally there must be a way to ensure congruent 
%   canonicity of \word{semigroup} elements.
%   \begin{tcl}
      semigroup {1.0 {
         API S semigroup 1.0
         API R semigroup 1.0
         self ring 2.0
         expr {$c2 in {0 1}}
      }}
      monoid {1.0 {
         API S monoid 1.0
         API R monoid 1.0
         self ring 2.0
         expr {$c2 in {0 1} && $c1 in {0 1}}
      }}
%   \end{tcl}
%   (Higher versions of these interfaces are out, since |*| is not 
%   variadic.) Similarly, commutativity of |*| requires both the 
%   \word{ring} and the \word{semigroup} to be commutative.
%   \begin{tcl}
      "commutative *" {1.0 {
         API S "commutative *" 1.0
         API R "commutative *" 1.0
         self ring 2.0
         expr {$c2 in {0 1}}
      }}
%   \end{tcl}
%   
%   The other algebraic direction is that towards the 
%   \APIref{ring-module}{2.1} interface; here we explicitly get the 
%   requirement that the \word{ring} is both a \APIref{ring}{2.0} and 
%   a \APIref{monoid}{1.0}, which in fact is what suffices.
%   \begin{tcl}
      ring-module {2.1 {
         API R ring 2.0
         API R monoid 1.0
      }}
%   \end{tcl}
%   Mathematically, the module of formal linear combinations is 
%   always free, but for this implementation to satisfy the 
%   \APIref{free ring-module}{2.1} interface, the \word{semigroup} 
%   must also know how to canonise (for the |basiselement| and 
%   |coeff| methods both).
%   \begin{tcl}
      "free ring-module" {2.1 {
         self ring-module 2.1
         API S canonise 1.1
      }}
%   \end{tcl}
%   
%   The two directions combine in the \APIref{ring-algebra}{2.0} 
%   interface, which however adds one more requirement: that the 
%   \word{ring} is commutative, since
%   \begin{multline*}
%     (r*s)(\mu*\nu) = 
%     r\bigl(s (\mu*\nu) \bigr) = 
%     s\bigl( (r\mu) * \nu \bigr) =
%     (r\mu) * (s\nu) = \\ =
%     r\bigl( \mu * (s\nu) \bigr) =
%     s\bigl( r (\mu*\nu) \bigr) =
%     (s*r)(\mu*\nu)
%     \text{;}
%   \end{multline*}
%   for algebras in general this is merely a sufficient (although 
%   very natural) condition, but in the semigroup algebra 
%   construction the above implies \(rs=sr\) regardless of what 
%   happens in the \word{semigroup}.
%   \begin{tcl}
      ring-algebra {2.0 {
         self ring-module 2.1
         self ring 2.0
         API R "commutative *" 1.0
      }}
%   \end{tcl}
%   
%   The remaining algebra-flavoured interface is 
%   \APIref{division}{1.0}, which divides in \word{ring} and 
%   \word{semigroup}, as well as canonises in the \word{semigroup}.
%   \begin{tcl}
      division {1.0 {
         API R division 1.0
         API S division 1.0
         API S canonise 1.1
      }}
%   \end{tcl}
%   
%   For import--export interfaces, there are 
%   \APIref{named element}{1.0} and \APIref{export}{2.0}, whose 
%   requirements from underlying structures are straightforwardly 
%   about ensuring that the called methods are available.
%   \begin{tcl}
      "named element" {1.0 {
         API S "named element" 1.0
         API S canonise 1.0
         API R monoid 1.0
      }}
      export {2.0 {
         API R export 2.0
         API S export 2.0
      }}
%   \end{tcl}
%   And that's it.
%   \begin{tcl}
   } R $R S $S]
   return [list [namespace current]::ens $R $iszero $S $c1 $c2 $API]
}
%   \end{tcl}
% \end{proc}
% 
% \begin{tcl}
%</SemigroupAlgebra&ens>
% \end{tcl}
% 
% 
% \subsection{Complex numbers}
% 
% The field of complex numbers $\mathbb{C}$ can of course be viewed 
% purely as a ring, but it is (among other things) also an 
% $\mathbb{R}$-algebra and may therefore expose such an interface.
% 
% It would be possible to define a generic ``complexification'' 
% constructor and define the complex numbers as the result of 
% applying that to |::mtmtcl::rings::float|, but complex numbers are 
% frequent enough that it makes sense to hardwire the arithmetic 
% instead.
% 
% \setnamespace{mtmcl::rings}
% \begin{ensemble}{complex}
%   Unsurprisingly, a complex number is going to be implemented as a 
%   two element list of |double|s, where the first element is the 
%   real part and the second is the imaginary part.
%   
%   \begin{tcl}
%<docstrip.tcl::catalogue>pkgProvide mtmtcl::rings::complex 1.1 complex
%<*complex>
package require Tcl 8.5
package require mtmtcl::openmath 1.1
package require API 1.0
package require mtmtcl::rings::float 1.0
package require mtmtcl::sets::finite_ordinal 1.0
namespace eval ::mtmtcl::rings::complex {
%   \end{tcl}
%   
%   Since most operations can be implemented as simple |expr| 
%   commands, it makes sense to only implement the most basic binary 
%   form of them. This implies it will support 
%   \APIref+{equality}{1.0}, \APIref+{additive group}{2.0}, 
%   
%   \begin{proc}{=}
%     \begin{tcl}
   proc = {z w} {
      expr {[lindex $z 0] == [lindex $w 0] &&\
        [lindex $z 1] == [lindex $w 1]}
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{+}
%     \begin{tcl}
   proc + {z w} {
      list [expr {[lindex $z 0] + [lindex $w 0]}] \
        [expr {[lindex $z 1] + [lindex $w 1]}]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{neg}
%     \begin{tcl}
   proc neg {z} {
      list [::tcl::mathop::- [lindex $z 0]]\
        [::tcl::mathop::- [lindex $z 1]]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{0}
%     \begin{tcl}
   proc 0 {} {list 0.0 0.0}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{-}
%     Subtraction is a natural operation to define, completing 
%     support for \APIref+{additive group}{2.0.1}.
%     \begin{tcl}
   proc - {z w} {
      list [expr {[lindex $z 0] - [lindex $w 0]}] \
        [expr {[lindex $z 1] - [lindex $w 1]}]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{canonise}
%     Canonising complex numbers is perhaps not so common, but it 
%     doesn't hurt to add it. The purpose of |::tcl::mathop::+| is to 
%     canonise the |double| values.
%     \begin{tcl}
   proc canonise {z} {
      list [::tcl::mathop::+ [lindex $z 0]]\
        [::tcl::mathop::+ [lindex $z 1]]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{*}
%     \begin{tcl}
   proc * {z w} {
      list [
         expr {[lindex $z 0]*[lindex $w 0] - [lindex $z 1]*[lindex $w 1]}
      ] [
         expr {[lindex $z 0]*[lindex $w 1] + [lindex $z 1]*[lindex $w 0]}
      ]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{1}
%     \begin{tcl}
   proc 1 {} {list 1.0 0.0}
%     \end{tcl}
%   \end{proc}
%   
%   Next on the list of field operations would be division, but it is 
%   natural to define a few other things first.
%   
%   \begin{proc}{abs}
%     The absolute value is preferably computed using |hypot|. This 
%     is a map \(\mathbb{C} \longrightarrow \mathbb{R}\).
%     \begin{tcl}
   proc abs {z} {::tcl::mathfunc::hypot {*}$z}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{abssqr}
%     The absolute value squared, on the other hand, is a matter of 
%     multiplication and addition.
%     \begin{tcl}
   proc abssqr {w} {
      expr {[lindex $w 0]*[lindex $w 0] +\
        [lindex $w 1]*[lindex $w 1]}
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{/}
%   \begin{proc}{inverse}
%     The division $z/w$ is implemented as \texttt{[complex * $z$ 
%     [complex inverse $w$]]}, where |inverse| is the inverse in the 
%     multiplicative group $\mathbb{C}\setminus\{0\}$ and computed 
%     using the formula $\bar{w} \big/ \lvert w\rvert^2$. It is 
%     however |inverse| that fulfills \APIref{division}{1.0} 
%     interface requirements of throwing an error when the 
%     denominator is $0$.
%     \begin{tcl}
   proc / {z w} {* $z [inverse $w]}
   proc inverse {w} {
      set abs2 [abssqr $w]
      if {$abs2 == 0} then {
         return -code error -errorcode {API division nosolution}\
           "Division by zero"
      }
      return [list [expr {[lindex $w 0] / $abs2}]\
        [expr {-[lindex $w 1] / $abs2}]]
   }
%     \end{tcl}
%   \end{proc}\end{proc}
%   
%   \begin{proc}{conjugate}
%     The main concern for the operation of conjugating a complex 
%     number is the matter of what to call it.
%     \begin{tcl}
   proc conjugate {z} {
      list [lindex $z 0] [::tcl::mathop::- [lindex $z 1]]
   }
%     \end{tcl}
%     |conjugate| is a very elementary name, which however reappears in 
%     more advanced settings such as the Hermitian conjugate. An 
%     alternative name could be |star| or |involution|, as $\mathbb{C}$ 
%     is a very small $C^*$-algebra; this is star as in the adjoint of 
%     an operator. 
%   \end{proc}
%   
%   
%   \begin{proc}{export}
%     The basic export format for a complex number is as a pair of 
%     real and imaginary part, so one would use 
%     \OMSref{complex1}{complex_cartesian} for this.
%     \begin{tcl}
   proc export {z attrs} {
      list OMA $attrs [list [
         list OMS [dict replace $attrs cd complex1 name complex_cartesian] {}
      ] [
         ::mtmtcl::rings::float_export [lindex $z 0] $attrs
      ] [
         ::mtmtcl::rings::float_export [lindex $z 1] $attrs
      ]]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{cartesian}
%     Conversely, it is reasonable to have a method that constructs a 
%     complex number from its real and imaginary parts. It is named 
%     |cartesian| after the above OM symbol.
%     \begin{tcl}
   proc cartesian {re im} {
      list [::tcl::mathfunc::double $re] [::tcl::mathfunc::double $im]
   }
%     \end{tcl}
%     The explicit |double| calls ensure that the number will behave 
%     correctly with respect to division.
%   \end{proc}
%   
%   \begin{proc}{Re}
%   \begin{proc}{Im}
%     Having done the construction of a complex number from real and 
%     imaginary parts, one might as well also do the opposite. Note 
%     that the |Re| and |Im| methods return a |double|, i.e.~(if one 
%     wishes to put it abstractly), an element of the 
%     |::mtmtcl::rings::float| structure.
%     \begin{tcl}
   proc Re {z} {lindex $z 0}
   proc Im {z} {lindex $z 1}
%     \end{tcl}
%   \end{proc}\end{proc}
%   
%   
%   \begin{proc}{import}
%     Importing data is, as usual, much trickier than exporting it. 
%     First, there's the usual part of throwing away surrounding 
%     \texttt{OMATTR} nodes.
%     \begin{tcl}
   proc import {path tree} {
      while {[lindex $tree 0] eq "OMATTR"} {
         set tree [lindex $tree 2 1]
      }
      ::mtmtcl::openmath::OMAS_switch $tree {
%     \end{tcl}
%     When reaching a non-\texttt{OMATTR} node, there are two basic 
%     cases: If it is an |OMA| node then it may natively be a complex 
%     number, but otherwise the only way for it to be something 
%     relevant is that it is the real part of something that can be 
%     parsed as a float, so hand all such cases over to 
%     |::mtmtcl::openmath::float_value|.
%     \begin{tcl}
         if {[catch {
            ::mtmtcl::openmath::float_value 1 $path $tree
         } res dict]} then {
            return -code error -options $dict "Not a complex number"
         } else {
            return [list $res 0.0]
         }
%     \end{tcl}
%     The two applications that are valid symbols in this main case 
%     are (i)~the above \OMSref{complex1}{complex_cartesian} and 
%     (ii)~its sibling \OMSref{complex1}{complex_polar}. Either way, 
%     there must be a total of three children, and the last two must 
%     have a float value.
%     \begin{tcl}
      } http://www.openmath.org/cd/complex1#complex_cartesian {
         if {[llength [lindex $tree 2]] == 3} then {
            return [list [
               ::mtmtcl::openmath::float_value 1 $path\
                 [lindex $tree 2 1]
            ] [
               ::mtmtcl::openmath::float_value 1 $path\
                 [lindex $tree 2 2]
            ]]
         }
      } http://www.openmath.org/cd/complex1#complex_polar {
         if {[llength [lindex $tree 2]] == 3} then {
            return [polar [
               ::mtmtcl::openmath::float_value 1 $path\
                 [lindex $tree 2 1]
            ] [
               ::mtmtcl::openmath::float_value 1 $path\
                 [lindex $tree 2 2]
            ] rad]
         }
      } 
      return -code error -errorcode [list API import EDOM $path $tree]\
        "Not a complex number"
   }
%     \end{tcl}
%     One further thing one could consider accepting would be the 
%     explicit OpenMath symbol for the imaginary unit, but if 
%     accepting that, then why not the sibling symbols for $0$, $1$, 
%     $\pi$, and $e$ as well? There seems to be little practical 
%     value in this.
%   \end{proc}
%   
%   \begin{proc}{polar}
%     On the other hand, it makes sense to offer a method that 
%     constructs a complex number from a polar representation. This 
%     method has the call syntax
%     \begin{displaysyntax}
%       complex polar \word{radius} \word{angle} 
%       \word{angle-unit}\regopt
%     \end{displaysyntax}
%     The \word{radius} is the absolute value of the complex number 
%     to construct and \word{angle} is its argument (counterclockwise 
%     from the positive real axis). The \word{angle-unit} must be one 
%     of |rad| (radians, the default) and |deg| (degrees), and 
%     specifies the unit of \word{angle}.
%     \begin{tcl}
   proc polar {r theta {unit rad}} {
      if {$unit eq "deg"} then {
         set theta [expr {acos(-1)/180*$theta}]
      }
      return [list [expr {$r*cos($theta)}] [expr {$r*sin($theta)}]]
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{Arg}
%     For going the opposite way, |abs| already returns the 
%     \word{radius} of the polar representation of a complex number, 
%     so what is missing is the argument. This is spelt with a 
%     capital A, since it is the principal branch of the argument.
%     \begin{tcl}
   proc Arg {z} {::tcl::mathfunc::atan2 [lindex $z 1] [lindex $z 0]}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{exp}
%   \begin{proc}{Log}
%     While we're at that, we might as well throw in implementations 
%     of the complex exponential function |exp| and the 
%     principal branch of the logarithm function |Log|.
%     \begin{tcl}
   proc Log {z} {
      list [::tcl::mathfunc::log [abs $z$]] [Arg $z]
   }
   proc exp {z} {
      set r [::tcl::mathfunc::exp [lindex $z 0]]
      list [expr {$r * cos([lindex $z 1])}] [expr {$r * sin([lindex $z 1])}] 
   }
%     \end{tcl}
%   \end{proc}\end{proc}
%   
%   \begin{proc}{named}
%     But back to things covered by an established interface. That 
%     the complex number |named i| is the imaginary unit was more or 
%     less promised in the commentary to that interface, so one 
%     should better make sure it is so.
%     \begin{tcl}
   proc named {name} {
      switch -- $name "i" {
         return {0.0 1.0}
      }
      return -code error "Unknown element name: $name"
   }
%     \end{tcl}
%   \end{proc}
%   
%   A case could be made for equipping the complex numbers with the 
%   interface of a \APIref{direct product}{1.1} of the real numbers 
%   with themselves, but for now I don't quite see a use-case.
%   
%   \begin{tclcommand}{alias}{scalar}
%     As mentioned above, |complex| has the interface of a real 
%     vector space, where the |scalar| structure is |float|.
%     \begin{tcl}
   interp alias {} [namespace current]::scalar {} ::mtmtcl::rings::float
%     \end{tcl}
%   \end{tclcommand}
%   
%   \begin{proc}{.}
%     A vector space structure requires a scalar multiple operation.
%     \begin{tcl}
   proc . {t z} {
      list [expr {$t * [lindex $z 0]}] [expr {$t * [lindex $z 1]}]
   }
%     \end{tcl}
%   \end{proc}
%   
%   The standard basis for $\mathbb{C}$ is obviously $\{1,i\}$, but 
%   the matter of how that basis should be indexed is not so 
%   obvious. It would seem appropriate to somehow use the named 
%   symbols \OMSref{alg1}{one} and \OMSref{nums1}{i} as the elements 
%   of the index set, but I don't have a finite-set-of-symbols 
%   structure yet (|mtmtcl::sets::variable_set| is a set of 
%   \emph{variables} rather than symbols).
%   
%   \begin{tclcommand}{alias}{basis}
%     Another approach, which greatly simplifies the implementation 
%     of related methods, is to let the index set be $\{0,1\}$; this 
%     means the index values can really be used as list indices into 
%     the |complex| elements.
%     \begin{tcl}
   interp alias {} [namespace current]::basis {}\
     ::mtmtcl::sets:finite_ordinal 2
%     \end{tcl}
%   \end{tclcommand}
%   
%   \begin{proc}{coeff}
%     For example, getting the coefficient of a basis element is a 
%     superficially wrapped |lindex|.
%     \begin{tcl}
   proc coeff {i z} {lindex $z $i}
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{basiselement}
%     Similarly, one can use a single |lreplace| to produce a basis 
%     element.
%     \begin{tcl}
   proc basiselement {i} {lreplace {0.0 0.0} $i $i 1.0}
%     \end{tcl}
%     An alternative approach would be to index into a list of the 
%     basis elements.
%   \end{proc}
%   
%   \begin{proc}{support}
%     Constructing the support is only mildly more complicated.
%     \begin{tcl}
   proc support {z} {
      set res {}
      set i 0; foreach x $z {
         if {$x != 0} then {lappend res $i}
         incr i
      }
      return $res
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{iszero}
%     While at that, one may as well do an |iszero| test too.
%     \begin{tcl}
   proc iszero {z} {
      expr {[lindex $z 0]==0 && [lindex $z 1]==0}
   }
%     \end{tcl}
%   \end{proc}
%   
%   \begin{proc}{distance}
%     Another operation that it makes sense for complex numbers to 
%     support is |distance|, which turns them into a \APIref{metric 
%     space}{1.2}.
%     \begin{tcl}
   proc distance {z w} {
      expr {hypot(
        [lindex $z 0] - [lindex $w 0], [lindex $z 1] - [lindex $w 1]
      )}
   }
%     \end{tcl}
%   \end{proc}
%   
%   
%   \begin{tcl}

   interp alias {} [namespace current]::API {} ::API::static {
      equality 1.0
      "additive group" 2.0.1
      canonise 1.1
      export 2.0
      import 1.0
      "named element" 1.0
      magma 1.1
      semigroup 1.0
      monoid 1.0
      "commutative *" 1.0
      ring 2.0
      division 1.0
      ring-module 2.1
      "free ring-module" 2.1
      ring-algebra 2.0
      "metric space" 1.2
   }
   namespace export *
   namespace ensemble create -prefix no
}
%</complex>
%   \end{tcl}
% \end{ensemble}
% 
%
\endinput
